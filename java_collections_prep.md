# Java Collections



* [Основные типы коллекций в Java](#основные-типы-коллекций-в-java)
* [Разница между ArrayList и LinkedList](#разница-между-arraylist-и-linkedlist)
* [Как работает хэш-таблица `HashMap` в Java](#как-работает-хэш-таблица-hashmap-в-java)
* [Особенности коллекций, поддерживающих обобщенный тип `Generics`](#особенности-коллекций-поддерживающих-обобщенный-тип-generics)



## Основные типы коллекций в Java

В Java существует несколько основных типов коллекций, которые предоставляют различные способы организации и хранения данных. Вот некоторые из них:

1. **Списки** (`Lists`):

    * `ArrayList`: Реализация списка на основе массива. Позволяет быстрый доступ к элементам по индексу, но менее эффективен при вставке и удалении элементов.
    * `LinkedList`: Реализация списка на основе связанных узлов. Обеспечивает быстрые вставку и удаление элементов, но медленный доступ по индексу.
    * `Vector`: представляет собой динамический массив объектов, является `thread-safe` что достигается с помощью синхронизации, что может сказаться на производительности. Если не нужна потокобезопасность, то `ArrayList` будет более эффективен
    * `Stack`: представляет собой структуру `LIFO`, расшираяет класс `Vector`и наследует потокобезопасность. Это делает его менее эффективным чем специализированные структуры данных, такие как `Deque`, если нужна работа с элементами стека.

2. **Множества** (`Sets`):
    * `HashSet`: Реализация множества на основе хеш-таблицы. Основное преимущество - быстрое добавление и поиск элементов, но **нет гарантии порядка элементов**.
    * `TreeSet`: Реализация множества на основе дерева (красно-черного дерева). Гарантирует упорядоченное хранение элементов по их значениям.

3. **Очереди** (`Queues`):
    * `PriorityQueue`: реализация очереди с приоритетом, элемент с наивысшим приоритетом будет извлечен первым. Базируется на структуре `Heap`, приоритетные элементы будут находеться в ее корне. Не допускает дубликатов. Несинхронизированный.

4.  **Двусторонние очереди** `Deque`: расширяет интерфейс `Queue`, может добавлять элементы и с начала и с конца. Поддерживает и `LIFO` и `FIFO`
    * `ArrayDeque`: реализация интерфейса `Deque`, использует динамический массив, обеспечивает быстрый случайный доступ к элементам, занимает меньше памяти на каждый элемент, но имеет худшую амортизированную сложность для вставки/удаления в середину списка.
    * `LinkedList`: уже упомянутый `LinkedList` может использоваться как очередь. Подходит больше если вставки/удаления происходят чаще не с начала или конца списка, а в середине.

5. **Наборы** (`Sets`): неупорядоченное множество уникальных элементов, не гарантирует какой-либо порядок
    * `HashSet`: основан на хешировании, элементы не имеют порядка, предоставляет быструю проверку наличия и быстрое время досупа к элементам
    * `LinkedHashSet`: поддерживает порядок вставки элементов. Элементы упорядочены в порядке добавления

6. **Сортированные наборы** (`SortedSet`): упорядоченный набор никальных элементовв в соответсвии с критерием сортировки, при добавлении новых они автоматически сортируются
    * `TreeSet`: упорядочевает элементы в естественном порядке (или по заданному компаратору), гарантирует что элементы находятся в упорядоченном состоянии. Поиск осуществляет медленнее, чем в `HashSet` и `LinkedHashSet`, но быстрее, чем в обычном списке

7. **Отображения** (`Maps`): представляют из себя неупорядоченное отображение пар `key-value`, не гарантирует порядок. Элементы хранятся в `map`, досупной по `key`
    * `HashMap`: основан на хэшировании и предоставляет высокую скорость доступа к элементам.
    * `LinkedHashMap`: поддерживает порядок вставки элементов, упорядочены в порядке добавления
    * `HashTable`: устаревший класс, потокобезопасный, все операции синхронизированы

8. **Сортированные отображения** (`SortedMaps`): так же представляет отображение `key-value`, упорядоченные в соответствии с критерием сортировки. Ключи автоматически сортируются при добавлении
    * `TreeMap`: основан на структуре `красно-черное дерево`, элементы автоматически сортируются по ключам, устойчив к вставкам-удалениям, дерево всегда остается сбалансированным - время выполнения вставики-удаления всегда логарифмическое. Непотокобезопано, не может вставить `null`.


[наверх](#java-core)

## Разница между `ArrayList` и `LinkedList`

`ArrayList` и `LinkedList` - это две разные реализации интерфейса `List` в `Java`, и они имеют ряд существенных различий. Вот основные различия между ними:

### Внутреннее представление данных:
* `ArrayList` использует динамический массив для хранения элементов. Это означает, что его элементы хранятся в непрерывном блоке памяти, что делает операции доступа по индексу быстрыми.
* `LinkedList` представляет собой двунаправленный связанный список, где каждый элемент (узел) ссылается на предыдущий и следующий элемент. Это позволяет эффективно вставлять и удалять элементы в середине списка, но доступ по индексу медленнее.

### Скорость доступа:
* `ArrayList` обеспечивает быстрый доступ к элементам по индексу (O(1)), так как он использует массив.
* `LinkedList` требует прохождения от начала или конца списка до нужного элемента для доступа по индексу, поэтому скорость доступа по индексу медленнее (O(n)), где n - индекс элемента.

### Вставка и удаление элементов:
* `ArrayList` медленно работает при вставке или удалении элементов в середине списка, так как это может потребовать перемещения всех последующих элементов.
* `LinkedList` эффективно обрабатывает операции вставки и удаления в середине списка, так как не требует перемещения всех элементов.

### Занимаемая память:
* `ArrayList` обычно занимает меньше памяти, чем LinkedList, так как он хранит только данные и размер массива.
* `LinkedList` требует дополнительной памяти для хранения ссылок на предыдущий и следующий элементы.

### Использование:
* `ArrayList` хорошо подходит для сценариев, где требуется быстрый доступ по индексу и медленные вставки/удаления в середине.
* `LinkedList` лучше использовать, когда нужно часто выполнять вставку и удаление элементов в середине списка, а доступ по индексу менее важен.

Оба типа имеют свои сильные и слабые стороны, и выбор между ними зависит от конкретных требований вашего приложения.

[наверх](#java-core)

## Как работает хэш-таблица `HashMap` в Java

[наверх](#java-core)

## Особенности коллекций, поддерживающих обобщенный тип `Generics`

Коллекции, поддерживающие обобщенные типы `Generics`, имеют следующие особенности:

1. **Безопасность типов**: Использование `Generics` позволяет обеспечить безопасность типов данных. Это означает, что вы можете определить, какой тип данных будет храниться в коллекции, и компилятор будет проверять соответствие типов на этапе компиляции, что помогает избегать ошибок времени выполнения, связанных с неправильными типами.

2. **Исключение приведения типов** `Type Casting`: Благодаря `Generics`, вы можете избежать необходимости приведения типов при извлечении элементов из коллекции. Это упрощает код и делает его более читаемым.

3. **Более высокая производительность**: Использование `Generics` может повысить производительность вашего кода, так как компилятор может оптимизировать код для конкретных типов данных, что может уменьшить накладные расходы на выполнение.

4. **Более читаемый и понятный код**: Обобщенные коллекции делают ваш код более читаемым и самодокументирующимся. Когда вы видите объявление коллекции с обобщенным типом, сразу становится понятно, какие данные она хранит.

5. **Избегание ошибок времени выполнения**: За счет проверки типов на этапе компиляции с помощью `Generics`, вы снижаете риск возникновения ошибок времени выполнения, таких как `ClassCastException`.

Примеры обобщенных коллекций в `Java` включают `ArrayList<E>`, `LinkedList<E>`, `HashSet<E>`, `HashMap<K, V>` и многие другие. Обобщенные типы позволяют создавать более безопасные и эффективные программы, а также снижают вероятность ошибок при работе с коллекциями данных.
```java
public class GenericsExample {
    public static void main(String[] args) {
        // Объявляем и инициализируем список строк с использованием Generics
        List<String> stringList = new ArrayList<>();

        // Добавляем элементы в список
        stringList.add("Привет");
        stringList.add("Мир");
        stringList.add("!");

        // Итерируемся по списку и выводим каждый элемент
        for (String str : stringList) {
            System.out.println(str);
        }
    }
}
```

[наверх](#java-core)
