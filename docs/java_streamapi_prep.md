# Java Stream API

[назад](../README.md)

* [Что такое `Java Stream API`](#что-такое-java-stream-api)
* [Как работать с `Java Stream API`](#как-работать-с-java-stream-api)
* [Как создать поток данных (`Stream`) в Java](#как-создать-поток-данных-stream-в-java)
* [Какие преимущества предоставляет Java Stream API](#какие-преимущества-предоставляет-java-stream-api)
* [Какие операции над потоками данных бывают в Java Stream API](#какие-операции-над-потоками-данных-бывают-в-java-stream-api)
* [Как различаются промежуточные и терминальные операции в Java Stream API](#как-различаются-промежуточные-и-терминальные-операции-в-java-stream-api)
* [Примеры промежуточных операций в Java Stream API](#примеры-промежуточных-операций-в-java-stream-api)
* [Примеры терминальных операций в Java Stream API](#примеры-терминальных-операций-в-java-stream-api)
* [Какие промежуточные операции могут выполнять фильтрацию данных](#какие-промежуточные-операции-могут-выполнять-фильтрацию-данных)
* [Сортировка данных с использованием `Java Stream API`](#сортировка-данных-с-использованием-java-stream-api)
* [Операция маппинга в `Java Stream API`](#операция-маппинга-в-java-stream-api)
* [Как выполнить операцию маппинга с помощью метода `map`](#как-выполнить-операцию-маппинга-с-помощью-метода-map)
* [Как выполнить операцию фильтрации с использованием `filter`](#как-выполнить-операцию-фильтрации-с-использованием-filter)
* [Как выполнить операцию отображения с помощью `forEach`](#как-выполнить-операцию-отображения-с-помощью-foreach)
* [Операция преобразования элементов с использованием `flatMap`](#операция-преобразования-элементов-с-использованием-flatmap)
* [Что такое операция редукции в `Java Stream API`](#что-такое-операция-редукции-в-java-stream-api)
* [Как выполнить операцию редукции с использованием `reduce`](#как-выполнить-операцию-редукции-с-использованием-reduce)
* [Какие методы `Java Stream API` поддерживают сборку (collecting) элементов в коллекции](#какие-методы-java-stream-api-поддерживают-сборку-collecting-элементов-в-коллекции)
* [Как выполнить сборку элементов в `List` с помощью Java Stream API](#как-выполнить-сборку-элементов-в-list-с-помощью-java-stream-api)
* [Как выполнить сборку элементов в `Set` с помощью Java Stream API](#как-выполнить-сборку-элементов-в-set-с-помощью-java-stream-api)
* [Как выполнить группировку элементов с использованием метода `Collectors.groupingBy`](#как-выполнить-группировку-элементов-с-использованием-метода-collectorsgroupingby)
* [Как выполнить агрегирование данных с использованием метода Collectors.summingInt](#как-выполнить-агрегирование-данных-с-использованием-метода-collectorssummingint)
* [Как выполнить конкатенацию строк с использованием метода Collectors.joining](#как-выполнить-конкатенацию-строк-с-использованием-метода-collectorsjoining)
* [Как выполнить подсчет элементов с использованием метода Collectors.counting](#как-выполнить-подсчет-элементов-с-использованием-метода-collectorscounting)
* [Как использовать `Parallel Streams` в Java Stream API](#как-использовать-parallel-streams-в-java-stream-api)
* [Как проверить, пуст ли поток данных с использованием метода isEmpty](#как-проверить-пуст-ли-поток-данных-с-использованием-метода-isempty)
* [Как проверить, содержит ли поток данных определенный элемент с использованием `anyMatch`](#как-проверить-содержит-ли-поток-данных-определенный-элемент-с-использованием-anymatch)
* [Проверить, все ли элементы потока данных соответствуют определенному условию с `allMatch`](#проверить-все-ли-элементы-потока-данных-соответствуют-определенному-условию-с-allmatch)
* [Проверить что ни один элемент потока данных не соответствует определенному условию с `noneMatch`](#проверить-что-ни-один-элемент-потока-данных-не-соответствует-определенному-условию-с-nonematch)
* [Выполнить операцию пропуска элементов с использованием метода `skip`](#выполнить-операцию-пропуска-элементов-с-использованием-метода-skip)
* [Выполнить операцию ограничения числа элементов с использованием `limit`](#выполнить-операцию-ограничения-числа-элементов-с-использованием-limit)
* [Какие функции предоставляются интерфейсом `Function` и как они используются в `Java Stream API`](#какие-функции-предоставляются-интерфейсом-function-и-как-они-используются-в-java-stream-api)
* [Какие функции предоставляются интерфейсом `Predicate` и как они используются в `Java Stream API`](#какие-функции-предоставляются-интерфейсом-predicate-и-как-они-используются-в-java-stream-api)
* [Какие функции предоставляются интерфейсом `Comparator` и как они используются для сортировки элементов](#какие-функции-предоставляются-интерфейсом-comparator-и-как-они-используются-для-сортировки-элементов)
* [Как выполнить операцию объединения нескольких потоков данных с использованием метода `concat`](#как-выполнить-операцию-объединения-нескольких-потоков-данных-с-использованием-метода-concat)
* [Операции поиска мин и макс элементов с использованием методов `min` и `max`](#операции-поиска-мин-и-макс-элементов-с-использованием-методов-min-и-max)
* [Операции преобразования элементов с использованием метода `mapToInt`, `mapToDouble` и `mapToObj`](#операции-преобразования-элементов-с-использованием-метода-maptoint-maptodouble-и-maptoobj)
* [Операция дистинкции (удаления дубликатов) с использованием метода `distinct`](#операция-дистинкции-удаления-дубликатов-с-использованием-метода-distinct)
* [Операция объединения элементов в одну строку с использованием метода reduce](#операция-объединения-элементов-в-одну-строку-с-использованием-метода-reduce)
* [Как выполнить операцию суммирования элементов с использованием метода `sum`](#как-выполнить-операцию-суммирования-элементов-с-использованием-метода-sum)
* [Операция нахождения среднего значения элементов с использованием метода `average`](#операция-нахождения-среднего-значения-элементов-с-использованием-метода-average)
* [Операция поиска первого элемента с использованием метода `findFirst`](#операция-поиска-первого-элемента-с-использованием-метода-findfirst)
* [Операция поиска случайного элемента с использованием метода `findAny`](#операция-поиска-случайного-элемента-с-использованием-метода-findany)
* [Какие промежуточные операции поддерживают `lazy evaluation`](#какие-промежуточные-операции-поддерживают-lazy-evaluation)
* [Какие промежуточные операции поддерживают `short-circuiting`](#какие-промежуточные-операции-поддерживают-short-circuiting)
* [Операцию пересечения (intersection) двух потоков данных с использованием метода `filter` и `collect`](#операцию-пересечения-intersection-двух-потоков-данных-с-использованием-метода-filter-и-collect)
* [Операция объединения (union) двух потоков данных с использованием метода concat и distinct](#операция-объединения-union-двух-потоков-данных-с-использованием-метода-concat-и-distinct)
* [Операция разности (difference) двух потоков данных с использованием метода filter и collect](#операция-разности-difference-двух-потоков-данных-с-использованием-метода-filter-и-collect)
* [Как использовать Stream API с пользовательскими классами и объектами](#как-использовать-stream-api-с-пользовательскими-классами-и-объектами)
* [Исключения при использовании Java Stream API и как их обрабатывать](#исключения-при-использовании-java-stream-api-и-как-их-обрабатывать)
* [Какие альтернативные подходы существуют для манипуляции данными в Java, помимо Stream API](#какие-альтернативные-подходы-существуют-для-манипуляции-данными-в-java-помимо-stream-api)
* [Что такое `stream`](#что-такое-stream)


[наверх](#java-stream-api)



##  Что такое Java Stream API

`Java Stream API` - это нововведение в языке программирования `Java`, введенное в `Java 8`, которое предоставляет удобные и эффективные средства для работы с последовательностями данных (коллекциями, массивами и другими источниками данных) в функциональном стиле. Этот `API` позволяет выполнять разнообразные операции над данными, такие как фильтрация, отображение, сортировка, агрегация и другие, с использованием выразительных и компактных функциональных выражений.

### Основные характеристики `Java Stream API`:

### 1. Ленивые вычисления (`Lazy Evaluation`)
Операции над потоком данных выполняются только при вызове терминальной операции (например, `collect`, `forEach`, `reduce`), что позволяет оптимизировать использование ресурсов.

### 2. Параллельные потоки данных (`Parallel Streams`)
`Java Stream API` обеспечивает поддержку параллельной обработки данных, что позволяет использовать многопоточность для увеличения производительности операций.

### 3. Функциональный стиль программирования
`Stream API` использует функциональные интерфейсы, лямбда-выражения и методы ссылки для более краткой и читаемой записи кода.

### 4. Цепочки операций
Множество операций можно объединить в цепочки, что упрощает создание выразительных и мощных запросов к данным.

### 5. Поддержка различных источников данных
`Stream API` может работать с коллекциями, массивами, файлами, числами и другими типами данных.

Пример использования `Java Stream API`:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
int sum = numbers.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(Integer::intValue)
                .sum();
System.out.println(sum); // Выводит: 30
```
В этом примере мы создаем поток данных из списка чисел, фильтруем только четные числа, затем преобразуем их в примитивы `int` и находим сумму всех четных чисел. Весь процесс записан в функциональном стиле и компактно. `Java Stream API` позволяет писать более читаемый и выразительный код для манипуляции данными.

[наверх](#java-stream-api)


## Как работать с `Java Stream API`

`Stream API` в `Java` представляет собой мощный инструмент для работы с данными в функциональном стиле. Он введен в `Java 8` и предоставляет способ выполнения операций над данными, таких как фильтрация, отображение (`map`), свертка (`reduce`) и другие, с использованием выражений лямбда-функций. Это позволяет писать более краткий и читаемый код при обработке данных.

Вот основные понятия и операции, связанные с Stream API:

### 1. Создание Stream

Вы можете создавать потоки данных из коллекций, массивов, файлов и других источников с использованием методов `stream()` и `parallelStream()`.

```java
List<String> list = Arrays.asList("apple", "banana", "cherry");
Stream<String> stream = list.stream();

int[] array = {1, 2, 3, 4, 5};
IntStream intStream = Arrays.stream(array);

Stream<String> lines = Files.lines(Paths.get("file.txt"));
```
### 2. Промежуточные `Intermediate` операции

Промежуточные операции выполняются над элементами потока и могут быть объединены цепочкой. Некоторые из них включают `filter()`, `map()`, `flatMap()`, `distinct()`, `sorted()`, `limit()`, `skip()` и другие.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

List<Integer> evenSquares = numbers.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * n)
    .collect(Collectors.toList());

Stream<String> words = Stream.of("apple", "banana", "cherry");
long count = words.filter(word -> word.startsWith("a")).count();
```

### 3. Завершающие `Terminal` операции

Завершающие операции завершают операции над потоком и производят результат. Это могут быть операции, такие как `collect()`, `forEach()`, `toArray()`, `reduce()`, `min()`, `max()`, `count()` и другие.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.stream().reduce(0, (a, b) -> a + b);
System.out.println("Сумма: " + sum);

List<String> fruits = Arrays.asList("apple", "banana", "cherry");
String result = fruits.stream().collect(Collectors.joining(", "));
System.out.println("Фрукты: " + result);
```

### 4. Параллельные потоки

`Stream API` позволяет создавать параллельные потоки данных с использованием метода `parallelStream()`, что может ускорить обработку данных на многопроцессорных системах.

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

int sum = numbers.parallelStream().reduce(0, (a, b) -> a + b);
```

### 5. Операции Short-circuit

Некоторые операции могут быть краткозамкнутыми (`short-circuit`), что означает, что они могут завершиться раньше, если достигнуто определенное условие. Например, `findFirst()`, `findAny()`, `anyMatch()`, `allMatch()`.

```java
List<String> fruits = Arrays.asList("apple", "banana", "cherry");

Optional<String> first = fruits.stream().findFirst();
boolean anyStartsWithA = fruits.stream().anyMatch(s -> s.startsWith("a"));
```

`Stream API` делает код более читаемым и функциональным, позволяя более эффективно обрабатывать данные. Он является важной частью функционального программирования в `Java` и может значительно упростить разработку.

[наверх](#java-stream-api)



## Как создать поток данных (`Stream`) в Java

В `Java` можно создать поток данных (`Stream`) из различных источников данных, таких как `коллекции`, `массивы`, `файлы` и другие. 

Вот несколько способов создания потока данных в `Java`:

### Из коллекции (List, Set, Map)
```java
List<String> myList = Arrays.asList("apple", "banana", "cherry");
Stream<String> stream = myList.stream();
```
### Из статического массива
```java
String[] array = {"apple", "banana", "cherry"};
Stream<String> stream = Arrays.stream(array);
```
### Из значений (`varargs`)
```java
Stream<String> stream = Stream.of("apple", "banana", "cherry");
```
### Из диапазона чисел:
```java
IntStream intStream = IntStream.range(1, 6); // создание потока чисел от 1 до 5
```
### Из файла (представление строк файла в потоке)
```java
try (Stream<String> lines = Files.lines(Paths.get("file.txt"), Charset.defaultCharset())) {
    // Ваш код обработки строк из файла
} catch (IOException e) {
    e.printStackTrace();
}
```
### Из строки (каждый символ строки как элемент потока)
```java
String str = "Hello, World!";
IntStream charStream = str.chars();
```
### С использованием метода `Stream.generate()`
```java
Stream<String> generatedStream = Stream.generate(() -> "Hello");
```
### С использованием метода `Stream.iterate()`
```java
Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 1);
```
Это лишь несколько примеров. `Java Stream API` предоставляет разнообразные методы для создания потоков данных из различных источников. После создания потока вы можете применять к нему различные операции, такие как фильтрация, маппинг, сортировка и др., для обработки данных.

[наверх](#java-stream-api)

## Какие преимущества предоставляет `Java Stream API`

`Java Stream API` предоставляет несколько значительных преимуществ, которые делают его мощным и удобным инструментом для работы с данными в `Java`:

### 1. Удобство и выразительность кода
`Stream API` позволяет писать код более кратко и выразительно, что делает его более читаемым и понятным. Функциональный стиль программирования с использованием лямбда-выражений и методов ссылки упрощает манипуляции данными.

### 2. Ленивые вычисления (Lazy Evaluation)
Операции над потоками данных выполняются только при вызове терминальных операций. Это позволяет оптимизировать использование ресурсов и выполнять операции только на необходимых элементах данных.

### 3. Параллельные вычисления
`Java Stream API` поддерживает параллельную обработку данных, что позволяет использовать многопоточность для ускорения выполнения операций над большими объемами данных.

### 4. Читаемость и поддерживаемость кода
Использование цепочек операций над потоками данных делает код более структурированным и понятным, что упрощает его поддержку и дальнейшее развитие.

### 5. Высокая производительность
В большинстве случаев `Stream API` обеспечивает хорошую производительность благодаря оптимизированным внутренним реализациям операций.

### 6. Универсальность
`Java Stream API` может работать с различными типами данных, включая коллекции, массивы, файлы и другие. Это позволяет использовать один и тот же набор операций для различных источников данных.

### 7. Сокращение объема кода
Многие операции, такие как фильтрация, сортировка и сборка, могут быть выполнены с минимальным объемом кода благодаря `Stream API`.

### 8. Поддержка функционального программирования
`Stream API` способствует применению функциональных принципов программирования, что может улучшить структуру и качество кода.

### 9. Поддержка параллельных алгоритмов
`Java Stream API` облегчает реализацию параллельных алгоритмов для обработки данных, что особенно полезно при работе с большими объемами информации.

### 10. Интеграция с другими функциональными возможностями `Java`
`Stream API` хорошо интегрируется с лямбда-выражениями, функциональными интерфейсами и другими функциональными возможностями `Java`, что способствует созданию более функционального и модульного кода.

`Java Stream API` стал важной частью языка `Java` и обеспечивает множество преимуществ при обработке и манипуляции данными в приложениях.

[наверх](#java-stream-api)

## Какие операции над потоками данных бывают в `Java Stream API`

`В Java Stream API` операции над потоками данных делятся на две основные категории: промежуточные (`intermediate`) и терминальные (`terminal`). 

**Промежуточные операции** применяются к потоку данных и возвращают новый поток данных, сохраняя исходный поток неизменным. 

**Терминальные операции**, напротив, завершают обработку потока данных и могут возвращать результат, коллекцию, значение или ничего не возвращать. 

Вот некоторые распространенные операции каждой категории:

### Промежуточные операции (`Intermediate Operations`):

* `filter(Predicate<T> predicate)`: Фильтрация элементов, удовлетворяющих заданному условию.

* `map(Function<T, R> mapper)`: Преобразование элементов из одного типа в другой с помощью заданной функции.

* `flatMap(Function<T, Stream<R>> mapper)`: Преобразование элементов в потоки данных и объединение их в один поток.

* `distinct()`: Удаление дубликатов из потока данных.

* `sorted()`: Сортировка элементов по их естественному порядку (если применимо).

* `sorted(Comparator<T> comparator)`: Сортировка элементов с использованием заданного компаратора.

* `peek(Consumer<T> action)`: Выполнение заданной операции над каждым элементом потока без изменения самого потока. Используется для отладки.

* `limit(long maxSize)`: Ограничение потока указанным максимальным количеством элементов.

* `skip(long n)`: Пропуск указанного количества элементов в потоке.

### Терминальные операции (`Terminal Operations`):

* `forEach(Consumer<T> action)`: Применение заданной операции к каждому элементу потока.

* `toArray()`: Преобразование потока в массив.

* `collect(Collector<T, A, R> collector)`: Сборка элементов потока в коллекцию или другой объект с использованием заданного коллектора.

* `reduce(T identity, BinaryOperator<T> accumulator)`: Свод (агрегация) элементов потока к одному значению с использованием указанного начального значения и бинарной операции.

* `min(Comparator<T> comparator)`: Нахождение минимального элемента с использованием заданного компаратора.

* `max(Comparator<T> comparator)`: Нахождение максимального элемента с использованием заданного компаратора.

* `count()`: Подсчет количества элементов в потоке.

* `anyMatch(Predicate<T> predicate)`: Проверка, соответствует ли хотя бы один элемент заданному условию.

* `allMatch(Predicate<T> predicate)`: Проверка, соответствуют ли все элементы заданному условию.

* `noneMatch(Predicate<T> predicate)`: Проверка, не соответствует ли ни один элемент заданному условию.

* `findFirst()`: Нахождение первого элемента в потоке (если он существует).

* `findAny()`: Нахождение любого элемента в потоке (если он существует).

* `min()`: Нахождение минимального элемента (если элементы сравниваемы).

* `max()`: Нахождение максимального элемента (если элементы сравниваемы).

* `sum()`: Вычисление суммы элементов потока (если элементы числовые).

* `average()`: Вычисление среднего значения элементов потока (если элементы числовые).

Эти операции могут быть комбинированы в цепочки для выполнения сложных операций над данными в потоке.

[наверх](#java-stream-api)

## Как различаются промежуточные и терминальные операции в `Java Stream API`

Промежуточные (`intermediate`) и терминальные (`terminal`) операции в `Java Stream API` различаются по своей функциональности и времени выполнения:

### Промежуточные операции (`Intermediate Operations`):

1. `Преобразование и фильтрация`: Промежуточные операции, такие как `map`, `filter`, `flatMap`, `distinct`, `sorted`, `peek`, выполняют преобразования и фильтрацию элементов потока. Они создают новый поток данных, который может быть передан для дальнейших операций, и они не вызывают фактической обработки элементов на этапе выполнения промежуточной операции. Промежуточные операции ленивы и выполняются только при вызове терминальной операции.

2. `Без изменения исходного потока`: Промежуточные операции не изменяют исходный поток данных. Они создают новый поток, оставляя исходный поток неизменным. Это позволяет создавать цепочки промежуточных операций, обрабатывая один и тот же исходный поток данных несколько раз с разными промежуточными операциями.

3. `Примеры`: Примерами промежуточных операций являются `filter`, `map`, `flatMap`, `distinct`, `sorted`, `peek`, `limit`, `skip` и другие. Эти операции возвращают новый поток данных и могут быть вызваны несколько раз перед вызовом терминальной операции.

### Терминальные операции (`Terminal Operations`):

1. `Завершение потока`: Терминальные операции завершают обработку потока данных. После выполнения терминальной операции нельзя продолжить операции над этим потоком. Терминальные операции начинают фактическую обработку элементов потока.

2. `Возвращение результата`: Терминальные операции могут возвращать результат (например, `значение`, `коллекцию`, `число`) или ничего не возвращать (если их целью является только обработка данных).

3. `Примеры`: Примерами терминальных операций являются `forEach`, `toArray`, `collect`, `reduce`, `min`, `max`, `count`, `anyMatch`, `allMatch`, `noneMatch`, `findFirst`, `findAny`, `sum`, `average` и другие. Эти операции начинают обработку данных и завершают поток данных.

Комбинирование `промежуточных` и `терминальных` операций позволяет создавать мощные цепочки операций для обработки и манипуляции данными в потоках. Промежуточные операции позволяют фильтровать и трансформировать данные, а терминальные операции завершают обработку и возвращают результат.

[наверх](#java-stream-api)

## Примеры промежуточных операций в `Java Stream API`

`Промежуточные` операции в `Java Stream API` выполняются над потоком данных и создают новый поток данных, который можно дальше использовать в цепочке операций. 

Вот несколько примеров промежуточных операций:

1. `filter(Predicate<T> predicate)`: Фильтрация элементов потока на основе заданного условия. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> evenNumbers = numbers.stream()
                                     .filter(n -> n % 2 == 0);               
```
В этом примере `filter` оставляет только четные числа в потоке.

2. `map(Function<T, R> mapper)`: Преобразование каждого элемента потока в другой объект с помощью заданной функции. Пример:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<Integer> nameLengths = names.stream()
                                   .map(String::length);
```
В этом примере `map` преобразует строки (имена) в их длины.

3. `flatMap(Function<T, Stream<R>> mapper)`: Преобразование элементов в потоки данных и объединение их в один поток. Пример:

```java
List<List<Integer>> nestedList = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5, 6),
    Arrays.asList(7, 8, 9)
);
Stream<Integer> flatStream = nestedList.stream()
                                       .flatMap(List::stream);
```
В этом примере `flatMap` преобразует вложенные списки в один плоский поток данных.

4. `distinct()`: Удаление дубликатов из потока данных. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4, 4);
Stream<Integer> distinctNumbers = numbers.stream()
                                          .distinct();
```
`distinct` оставляет только уникальные значения.

5. `sorted()` и `sorted(Comparator<T> comparator)`: Сортировка элементов потока. Примеры:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<String> sortedNames = names.stream()
                                  .sorted(); // сортировка по естественному порядку (лексикографически)
```
В первом примере `sorted` выполняет сортировку строк по их естественному порядку. 
```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 6, 3);
Stream<Integer> sortedNumbers = numbers.stream()
                                        .sorted((a, b) -> a.compareTo(b)); // сортировка по возрастанию
```

Во втором примере с `sorted` задан пользовательский компаратор для сортировки чисел по возрастанию.

6. `peek(Consumer<T> action)`: Выполнение заданной операции над каждым элементом потока без изменения самого потока. Пример:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<String> peekedNames = names.stream()
                                 .peek(name -> System.out.println("Processing: " + name))
                                 .map(String::toUpperCase);
```
`peek` позволяет выполнять действие для каждого элемента (например, вывод на консоль) без изменения потока.

7. `limit(long maxSize)` и `skip(long n)`: Ограничение количества элементов в потоке. Примеры:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> limitedNumbers = numbers.stream()
                                         .limit(5); // ограничение до первых 5 элементов
```
`limit` ограничивает поток указанным числом элементов
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> skippedNumbers = numbers.stream()
                                         .skip(5); // пропуск первых 5 элементов
```
`skip` пропускает указанное количество элементов в начале потока

[наверх](#java-stream-api)

## Примеры терминальных операций в `Java Stream API` 

**Терминальные операции** в `Java Stream API` завершают обработку потока данных и могут возвращать результат, коллекцию, значение или ничего не возвращать. Вот некоторые примеры терминальных операций:

1. `forEach(Consumer<T> action)`: Применение заданной операции к каждому элементу потока. Пример:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
names.stream()
     .forEach(System.out::println); // Вывод каждого имени на консоль
```

2. `toArray()`: Преобразование потока в массив. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Integer[] numberArray = numbers.stream()
                               .toArray(Integer[]::new);
```

3. `collect(Collector<T, A, R> collector)`: Сборка элементов потока в коллекцию или другой объект с использованием заданного коллектора. Пример:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> filteredNames = names.stream()
                                  .filter(name -> name.length() > 4)
                                  .collect(Collectors.toList()); // Сборка в список
```

4. `reduce(T identity, BinaryOperator<T> accumulator)`: Свод (агрегация) элементов потока к одному значению с использованием указанного начального значения и бинарной операции. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                .reduce(0, (a, b) -> a + b); // Сумма чисел
```

5. `min(Comparator<T> comparator)` и `max(Comparator<T> comparator)`: Нахождение минимального и максимального элементов с использованием заданного компаратора. Примеры:

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 6, 3);
int minNumber = numbers.stream()
                       .min(Integer::compareTo)
                       .orElse(0); // Минимальное число (или 0, если поток пуст)
```
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
String longestName = names.stream()
                          .max(Comparator.comparingInt(String::length))
                          .orElse(""); // Самое длинное имя (или пустая строка, если поток пуст)
```

6. `count()`: Подсчет количества элементов в потоке. Пример:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
long count = names.stream()
                 .filter(name -> name.length() > 4)
                 .count(); // Количество имен с длиной более 4 символов
```

7. `anyMatch(Predicate<T> predicate)`, `allMatch(Predicate<T> predicate)` и `noneMatch(Predicate<T> predicate)`: Проверка соответствия элементов заданному условию. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
boolean anyEven = numbers.stream()
                         .anyMatch(n -> n % 2 == 0); // Есть ли хотя бы одно четное число
```

8. `findFirst()` и `findAny()`: Нахождение первого или любого элемента в потоке (если они существуют). Пример:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Optional<String> first = names.stream()
                              .findFirst(); // Первое имя в потоке
```

9. `min()` и `max()`: Нахождение минимального и максимального элементов (если элементы сравниваемы). Пример:

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 6, 3);
Optional<Integer> minNumber = numbers.stream()
                                     .min(Integer::compareTo); // Минимальное число
```

10. `sum()` и `average()`: Вычисление суммы и среднего значения элементов (если элементы числовые). Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                .mapToInt(Integer::intValue)
                .sum(); // Сумма чисел
```
```java
List<Double> values = Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0);
double average = values.stream()
                       .mapToDouble(Double::doubleValue)
                       .average()
                       .orElse(0.0); // Среднее значение (или 0, если поток пуст)
```
Эти операции завершают обработку потока данных и могут быть использованы для получения результатов или завершения последовательности операций.

[наверх](#java-stream-api)

## Какие промежуточные операции могут выполнять фильтрацию данных

Промежуточные операции в `Java Stream API`, которые могут выполнять фильтрацию данных, включают в себя следующие операции:

1. `filter(Predicate<T> predicate)`: Операция `filter` применяет заданное условие (предикат) к каждому элементу потока и оставляет только те элементы, которые удовлетворяют этому условию. **Неудовлетворяющие элементы исключаются из потока**. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> evenNumbers = numbers.stream()
                                     .filter(n -> n % 2 == 0);
```
В этом примере `filter` оставляет только четные числа в потоке.

2. `distinct()`: Операция `distinct` убирает дубликаты из потока данных. Она сравнивает элементы с помощью их метода `equals` и `hashCode`. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4, 4);
Stream<Integer> distinctNumbers = numbers.stream()
                                          .distinct();
```
`distinct` оставляет только уникальные значения.

3. `takeWhile(Predicate<T> predicate)`: Операция `takeWhile` берет элементы из потока, пока они удовлетворяют заданному условию, и прекращает обработку, как только условие перестает выполняться. Эта операция добавлена в `Java 9`. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> takeWhileStream = numbers.stream()
                                         .takeWhile(n -> n < 6);
```
В этом примере `takeWhile` **берет элементы, пока они** `меньше` `6`.

4. `dropWhile(Predicate<T> predicate)`: Операция `dropWhile` пропускает элементы из потока, пока они удовлетворяют заданному условию, и начинает обработку, как только условие перестает выполняться. Эта операция добавлена в `Java 9`. Пример:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> dropWhileStream = numbers.stream()
                                         .dropWhile(n -> n < 6);
```
В этом примере `dropWhile` **пропускает элементы, пока они** `меньше 6`.

Эти промежуточные операции предоставляют способы фильтрации данных в потоке на основе заданных условий. Вы можете выбрать ту, которая лучше всего подходит для вашей конкретной задачи.

[наверх](#java-stream-api)

## Сортировка данных с использованием `Java Stream API`

Вы можете выполнить сортировку данных с использованием `Java Stream API` с помощью промежуточной операции `sorted()`. Эта операция сортирует элементы потока данных в естественном порядке (если это возможно) или использует заданный компаратор для сортировки. Вот примеры сортировки данных с использованием `Stream API`:

### 1. Сортировка элементов в естественном порядке (по умолчанию):

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 6, 3);
Stream<Integer> sortedNumbers = numbers.stream()
                                        .sorted(); // сортировка по естественному порядку (лексикографически)
```
В этом примере элементы будут отсортированы в возрастающем порядке.

### 2. Сортировка элементов с использованием компаратора:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<String> sortedNames = names.stream()
                                  .sorted(Comparator.comparing(String::length)); // сортировка по длине строки
```                         
В этом примере элементы (строки) будут отсортированы по длине строки.

### 3. Обратная сортировка:

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 6, 3);
Stream<Integer> reverseSortedNumbers = numbers.stream()
                                             .sorted(Comparator.reverseOrder()); // обратная сортировка
```
В этом примере элементы будут отсортированы в убывающем порядке.

### 4. Сложная сортировка с композицией компараторов:

```java
List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30),
    new Person("Charlie", 20)
);
Stream<Person> sortedPeople = people.stream()
                                    .sorted(Comparator.comparingInt(Person::getAge)
                                                      .thenComparing(Person::getName)); // сначала по возрасту, затем по имени
```
В этом примере элементы (объекты `Person`) сначала сортируются по возрасту, а затем по имени.

Обратите внимание, что `sorted()` не изменяет исходный поток данных, а создает новый поток с отсортированными элементами. Вы можете сохранить результат сортировки в новом потоке или в коллекции, если это необходимо.

[наверх](#java-stream-api)

## Операция маппинга в `Java Stream API`

Операция `маппинга` в `Java Stream API` относится к промежуточным операциям и используется для преобразования каждого элемента потока в другой объект или значение на основе заданной функции. 

`Маппинг` позволяет преобразовывать данные в потоке согласно определенным правилам, что полезно, например, при изменении типа элементов, извлечении определенных свойств или любых других преобразованиях.

Основная промежуточная операция маппинга в `Java Stream API` - это `map(Function<T, R> mapper)`, где `Function<T, R>` - функция, которая принимает элемент типа `T` и возвращает элемент типа `R`. Эта операция применяет заданную функцию к каждому элементу потока и создает новый поток, содержащий результаты преобразования.

Пример маппинга с использованием `map`:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<Integer> nameLengths = names.stream()
                                  .map(String::length); // Преобразование каждого имени в его длину
```
В этом примере мы преобразовываем каждую строку (имя) в длину этой строки с помощью функции `String::length`. Результат - поток, содержащий длины строк.

Другие операции маппинга могут включать в себя `flatMap`, который используется для преобразования элементов в потоки данных и объединения их в один поток. `flatMap` особенно полезен, когда вы хотите **"развернуть" вложенные коллекции или структуры данных в один плоский поток**.

Пример с использованием `flatMap`:

```java
List<List<Integer>> nestedList = Arrays.asList(
   Arrays.asList(1, 2, 3),
   Arrays.asList(4, 5, 6),
   Arrays.asList(7, 8, 9)
);
Stream<Integer> flatStream = nestedList.stream()
                                      .flatMap(List::stream); // Преобразование вложенных списков в один поток
```
В этом примере `flatMap` преобразует вложенные списки в один плоский поток данных.


[наверх](#java-stream-api)

## Как выполнить операцию маппинга с помощью метода `map`

Для выполнения операции маппинга с помощью метода `map` в `Java Stream API`, вы должны вызвать метод `map(Function<T, R> mapper)` на вашем потоке данных, где `Function<T, R>` - это функция, которая принимает элемент типа `T` и возвращает элемент типа `R`. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<String> nameStream = names.stream();
```
Вызовите метод `map` на потоке данных и передайте функцию маппинга, которая преобразует элементы:

```java
Stream<Integer> nameLengths = nameStream.map(String::length);
```
В этом примере мы используем ссылку на метод `String::length`, который принимает строку и возвращает ее длину.

Вы можете продолжить работу с полученным потоком данных или выполнить терминальную операцию:

```java
nameLengths.forEach(System.out::println); // Вывод длин имен на консоль
```
В этом примере мы используем терминальную операцию `forEach`, чтобы вывести длины имен на консоль.

Полный код примера:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class MappingExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        Stream<String> nameStream = names.stream();
        
        Stream<Integer> nameLengths = nameStream.map(String::length);
        
        nameLengths.forEach(System.out::println);
    }
}
```
Этот код преобразует каждое имя в потоке в его длину и выводит длины имен на консоль. Вы можете заменить функцию маппинга `String::length` на свою собственную функцию, если требуется другое преобразование.

[наверх](#java-stream-api)

## Как выполнить операцию фильтрации с использованием `filter`

Для выполнения операции фильтрации с использованием метода `filter` в `Java Stream API`, вы должны вызвать метод `filter(Predicate<T> predicate)` на вашем потоке данных, где `Predicate<T>` - это предикат, который определяет условие фильтрации элементов. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
Stream<Integer> numberStream = numbers.stream();
```
### 2. Вызовите метод `filter` на потоке данных и передайте предикат фильтрации:

```java
Stream<Integer> evenNumbers = numberStream.filter(n -> n % 2 == 0);
```
В этом примере мы используем предикат `n -> n % 2 == 0`, который фильтрует только четные числа.

### 3. Вы можете продолжить работу с полученным потоком данных или выполнить терминальную операцию:

```java
evenNumbers.forEach(System.out::println); // Вывод четных чисел на консоль
```
В этом примере мы используем терминальную операцию `forEach`, чтобы вывести четные числа на консоль.

### Полный код примера:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class FilteringExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        Stream<Integer> numberStream = numbers.stream();
        
        Stream<Integer> evenNumbers = numberStream.filter(n -> n % 2 == 0);
        
        evenNumbers.forEach(System.out::println);
    }
}
```
Этот код фильтрует только четные числа из списка и выводит их на консоль. Вы можете изменить предикат фильтрации на свой собственный, чтобы выбрать элементы, которые соответствуют вашим требованиям.

[наверх](#java-stream-api)

## Как выполнить операцию отображения с помощью `forEach`

Операция отображения (`map`) и операция итерации (`forEach`) выполняют разные задачи в `Java Stream API`. Операция `map` используется для преобразования элементов в потоке, создавая новый поток с преобразованными данными, в то время как операция `forEach` используется для выполнения действия над каждым элементом потока, но она не создает новый поток или не изменяет сами элементы.

Если вы хотите выполнить операцию отображения с помощью метода `forEach`, то вам нужно будет выполнить `map` сначала, а затем вызвать `forEach` для каждого элемента преобразованного потока. Вот пример:

```java
import java.util.Arrays;
import java.util.List;

public class MapAndForEachExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // Преобразование имен в верхний регистр и вывод на консоль
        names.stream()
             .map(String::toUpperCase) // Преобразование в верхний регистр
             .forEach(System.out::println); // Вывод на консоль
    }
}
```
В этом примере мы сначала преобразовываем каждое имя в верхний регистр с помощью `map`, а затем используем `forEach`, чтобы вывести преобразованные имена на консоль.

Помните, что `map` преобразует элементы и создает новый поток данных, а `forEach` просто выполняет действие над каждым элементом в потоке.

[наверх](#java-stream-api)

## Операция преобразования элементов с использованием `flatMap`

Операция преобразования элементов с использованием метода `flatMap` в `Java Stream API` позволяет преобразовать каждый элемент потока в другой поток данных и объединить эти потоки в один. Это особенно полезно, когда элементы исходного потока преобразуются в коллекции или другие потоки данных. Вот как выполнить операцию преобразования элементов с использованием метода `flatMap`:

### 1. Создайте поток данных (`Stream`):

```java
List<List<Integer>> nestedLists = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5, 6),
    Arrays.asList(7, 8, 9)
);
Stream<List<Integer>> nestedStream = nestedLists.stream();
```
### 2. Вызовите метод `flatMap` на потоке данных и передайте функцию, которая преобразует каждый элемент в другой поток данных:

```java
Stream<Integer> flatStream = nestedStream.flatMap(List::stream);
```
В этом примере мы используем `flatMap` для преобразования каждого вложенного списка в отдельный поток данных и объединения их в один плоский поток.

### 3. Вы можете продолжить работу с полученным плоским потоком данных или выполнить терминальную операцию:

```java
flatStream.forEach(System.out::println); // Вывод элементов на консоль
```
В этом примере мы используем `forEach`, чтобы вывести элементы плоского потока на консоль.

### Полный код примера:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class FlatMapExample {
    public static void main(String[] args) {
        List<List<Integer>> nestedLists = Arrays.asList(
            Arrays.asList(1, 2, 3),
            Arrays.asList(4, 5, 6),
            Arrays.asList(7, 8, 9)
        );
        Stream<List<Integer>> nestedStream = nestedLists.stream();
        
        Stream<Integer> flatStream = nestedStream.flatMap(List::stream);
        
        flatStream.forEach(System.out::println);
    }
}
```
Этот код преобразует вложенные списки в один плоский поток и выводит его элементы на консоль.

[наверх](#java-stream-api)

## Что такое операция редукции в `Java Stream API`

Операция `редукции` в `Java Stream API` представляет собой операцию `агрегации`, которая позволяет комбинировать элементы потока в одно значение или другую структуру данных. Редукция может быть использована для выполнения различных операций, таких как вычисление суммы, нахождение минимального или максимального значения, конкатенация строк и многое другое.

Операция редукции может быть выполнена с помощью метода `reduce`. Существует несколько версий этого метода, но основная сигнатура выглядит так:

```java
T reduce(T identity, BinaryOperator<T> accumulator)
```
* `identity` - начальное значение (`identity`) для аккумулятора. Это значение используется как база для редукции и как результат, если поток данных пуст.
* `accumulator` - бинарная операция, которая комбинирует два элемента и возвращает результат.
Примеры операций редукции:

### 1. Вычисление суммы чисел:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                .reduce(0, (a, b) -> a + b);
```
В этом примере `reduce` используется для вычисления суммы чисел в потоке, начиная с начального значения `0`.

### 2. Нахождение минимального значения:

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 6, 3);
int min = numbers.stream()
                .reduce(Integer.MAX_VALUE, (a, b) -> Math.min(a, b));
```
Здесь `reduce` находит минимальное значение в потоке чисел, начиная с максимально возможного значения `Integer.MAX_VALUE`.

### 3. Конкатенация строк:

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
String result = names.stream()
                     .reduce("", (a, b) -> a + " " + b);
```
Этот пример выполняет конкатенацию строк из потока, начиная с пустой строки `""`.

### 4. Нахождение максимального значения с использованием метода `max`:

```java
List<Integer> numbers = Arrays.asList(5, 2, 8, 1, 6, 3);
Optional<Integer> max = numbers.stream()
                                .reduce(Integer::max);
```
Вместо явного использования `reduce`, можно также использовать метод `max()`, который предоставляет `Optional`, содержащий максимальное значение.

Операция редукции очень мощный и гибкий инструмент для агрегации данных в потоках. Она может быть применена для различных задач агрегации в зависимости от ваших потребностей.

[наверх](#java-stream-api)

## Как выполнить операцию редукции с использованием `reduce`

Для выполнения операции редукции с использованием метода `reduce` в `Java Stream API`, вы можете вызвать этот метод на вашем потоке данных и передать начальное значение (`identity`) и бинарную операцию, которая будет применяться к элементам потока. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Stream<Integer> numberStream = numbers.stream();
```
### 2. Вызовите метод `reduce` на потоке данных и передайте начальное значение и бинарную операцию:

```java
int sum = numberStream.reduce(0, (a, b) -> a + b);
```
В этом примере мы используем `reduce` для вычисления суммы чисел в потоке, начиная с начального значения `0`. Бинарная операция `(a, b) -> a + b` складывает два числа.

### 3. Результат редукции будет возвращен в переменной `sum`:

```java
System.out.println("Сумма чисел: " + sum); // Вывод суммы чисел на консоль
```
В этом примере мы выводим результат на консоль.

### Полный код примера:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class ReduceExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        Stream<Integer> numberStream = numbers.stream();
        
        int sum = numberStream.reduce(0, (a, b) -> a + b);
        
        System.out.println("Сумма чисел: " + sum);
    }
}
```
Этот код вычисляет сумму чисел в потоке и выводит ее на консоль. Вы можете заменить бинарную операцию и начальное значение в методе `reduce` для выполнения других операций редукции в зависимости от вашей задачи.

[наверх](#java-stream-api)

## Какие методы `Java Stream API` поддерживают сборку (`collecting`) элементов в коллекции

`Java Stream API` предоставляет множество методов для сборки (`collecting`) элементов из потока в коллекции или другие структуры данных. Некоторые из наиболее часто используемых методов включают:

1. `collect(Collectors.toList())`: Этот метод собирает элементы потока в список (`List`).

```java
List<String> names = stream.collect(Collectors.toList());
```

2. `collect(Collectors.toSet())`: Этот метод собирает элементы потока в множество (Set), удаляя дубликаты.

```java
Set<Integer> numbers = stream.collect(Collectors.toSet());
```
3. `collect(Collectors.toCollection(CollectionFactory))`: Этот метод позволяет указать конкретную коллекцию, в которую нужно собрать элементы.

```java
List<String> names = stream.collect(Collectors.toCollection(ArrayList::new));
```
4. `collect(Collectors.toMap(keyMapper, valueMapper))`: Этот метод собирает элементы в карту (`Map`) с использованием функций для преобразования элементов в ключи и значения.

```java
Map<String, Integer> nameToLength = stream.collect(Collectors.toMap(name -> name, String::length));
```
5. `collect(Collectors.toMap(keyMapper, valueMapper, mergeFunction))`: Этот метод аналогичен предыдущему, но позволяет указать функцию для разрешения конфликтов, если ключи совпадают.

```java
Map<String, Integer> nameToLength = stream.collect(Collectors.toMap(name -> name, String::length, (existing, replacement) -> existing));
```
6. `collect(Collectors.joining(delimiter))`: Этот метод собирает строки из потока в одну строку, объединяя их с заданным разделителем.

```java
String result = stream.collect(Collectors.joining(", "));
```
7. `collect(Collectors.groupingBy(classifier))`: Этот метод группирует элементы потока по заданному классификатору и создает `map`, где `key` - это группы, а `value` - это списки элементов в каждой группе.

```java
Map<String, List<Integer>> groupedNumbers = stream.collect(Collectors.groupingBy(number -> number % 2 == 0 ? "Even" : "Odd"));
```

8. `collect(Collectors.partitioningBy(predicate))`: Этот метод разделяет элементы на две группы (истинные и ложные) на основе предиката и создает карту, где ключи - это `true` и `false`, а значения - списки элементов в каждой группе.

```java
Map<Boolean, List<Integer>> partitionedNumbers = stream.collect(Collectors.partitioningBy(number -> number % 2 == 0));
```
Эти методы позволяют собирать элементы из потока в различные типы коллекций и структуры данных в зависимости от ваших потребностей.

[наверх](#java-stream-api)

## Как выполнить сборку элементов в `List` с помощью `Java Stream API`

Для выполнения сборки элементов в список `List` с использованием `Java Stream API`, вы можете воспользоваться методом `collect(Collectors.toList())`. Вот пример:

### 1. Создайте поток данных (`Stream`):

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Stream<String> nameStream = names.stream();
```
### 2. Используйте метод `collect` с аргументом `Collectors.toList()` для сборки элементов в список:

```java
List<String> nameList = nameStream.collect(Collectors.toList());
```
Теперь переменная `nameList` содержит элементы из потока, собранные в список.

### Полный код примера:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class ListCollectionExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        Stream<String> nameStream = names.stream();
        
        List<String> nameList = nameStream.collect(Collectors.toList());
        
        System.out.println("Список имен: " + nameList);
    }
}
```
В этом примере элементы из потока `nameStream` собираются в список `nameList`. Вы можете использовать метод `collect(Collectors.toList())` для сборки элементов в список вместо `String`, в зависимости от типа элементов вашего потока.

[наверх](#java-stream-api)

## Как выполнить сборку элементов в `Set` с помощью `Java Stream API`

Для выполнения сборки элементов в множество (`Set`) с использованием `Java Stream API`, вы можете воспользоваться методом `collect(Collectors.toSet())`. Вот пример:

### 1. Создайте поток данных (`Stream`):

```java
List<String> names = Arrays.asList("Alice", "Bob", "Alice", "Charlie");
Stream<String> nameStream = names.stream();
```
### 2. Используйте метод `collect` с аргументом `Collectors.toSet()` для сборки элементов в множество:

```java
Set<String> nameSet = nameStream.collect(Collectors.toSet());
```
Теперь переменная `nameSet` содержит уникальные элементы из потока, собранные в множество.

### Полный код примера:

```java
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class SetCollectionExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Alice", "Charlie");
        Stream<String> nameStream = names.stream();
        
        Set<String> nameSet = nameStream.collect(Collectors.toSet());
        
        System.out.println("Множество имен: " + nameSet);
    }
}
```
В этом примере элементы из потока `nameStream` собираются в множество `nameSet`, и дубликаты удаляются, так как множество не допускает повторяющихся элементов.

[наверх](#java-stream-api)

## Как выполнить группировку элементов с использованием метода `Collectors.groupingBy`

Для выполнения группировки элементов с использованием метода `Collectors.groupingBy` в `Java Stream API`, вы можете создать группировку элементов по некоторому критерию и создать карту (`Map`), где ключами будут категории (группы), а значениями будут списки элементов, принадлежащих к каждой категории. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30),
    new Person("Charlie", 25),
    new Person("David", 30),
    new Person("Eve", 35)
);
Stream<Person> personStream = people.stream();
```
В этом примере мы имеем список объектов `Person`, и мы хотим выполнить группировку по возрасту.

### 2. Используйте метод `collect` с аргументом `Collectors.groupingBy(classifier)` для выполнения группировки. 

`classifier` - это функция, которая определяет, по какому критерию элементы будут группироваться:

```java
Map<Integer, List<Person>> ageGroupMap = personStream.collect(Collectors.groupingBy(Person::getAge));
```
В этом примере мы группируем людей по их возрасту, и в результате получаем `карту`, где `ключами` являются возрасты, а `значениями` - списки людей с соответствующим возрастом.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class GroupingByExample {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 25),
            new Person("Bob", 30),
            new Person("Charlie", 25),
            new Person("David", 30),
            new Person("Eve", 35)
        );
        Stream<Person> personStream = people.stream();
        
        Map<Integer, List<Person>> ageGroupMap = personStream.collect(Collectors.groupingBy(Person::getAge));
        
        ageGroupMap.forEach((age, group) -> {
            System.out.println("Age: " + age);
            group.forEach(person -> System.out.println("  " + person.getName()));
        });
    }
}
```
Этот код выполняет группировку людей по возрасту и выводит результат на консоль. Вы можете адаптировать этот пример для группировки по любому другому критерию, который вам необходим.

[наверх](#java-stream-api)

## Как выполнить агрегирование данных с использованием метода `Collectors.summingInt`

Для выполнения агрегирования данных с использованием метода `Collectors.summingInt` в `Java Stream API`, вы можете использовать этот метод для суммирования значений числовых полей объектов в вашем потоке. Этот метод принимает функцию, которая извлекает числовое значение из элементов потока и выполняет суммирование. Вот как это делается:

Предположим, у вас есть класс `Person` с полем `age`, и вы хотите вычислить сумму возрастов людей из вашего потока. Вот как выполнить это агрегирование:

### 1. Создайте поток данных (`Stream`):

```java
List<Person> people = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30),
    new Person("Charlie", 35)
);
Stream<Person> personStream = people.stream();
```
### 2. Используйте метод `collect` с аргументом `Collectors.summingInt` для выполнения агрегирования суммы возрастов:

```java
int totalAge = personStream.collect(Collectors.summingInt(Person::getAge));
```
Здесь `Person::getAge` - это функция, которая извлекает возраст из объекта `Person`, и `Collectors.summingInt` выполняет суммирование всех извлеченных возрастов.

### 3. Результат агрегирования будет сохранен в переменной `totalAge`:

```java
System.out.println("Сумма возрастов: " + totalAge);
```
В этом примере мы выводим результат на консоль.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

public class SummingExample {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 25),
            new Person("Bob", 30),
            new Person("Charlie", 35)
        );
        Stream<Person> personStream = people.stream();
        
        int totalAge = personStream.collect(Collectors.summingInt(Person::getAge));
        
        System.out.println("Сумма возрастов: " + totalAge);
    }
}
```

Этот код вычисляет сумму возрастов людей в потоке и выводит ее на консоль. Вы можете адаптировать этот пример для выполнения агрегирования по другим числовым полям или с использованием других методов `Collectors`, таких как `summingLong` или `summingDouble`, в зависимости от вашей задачи.

[наверх](#java-stream-api)

## Как выполнить конкатенацию строк с использованием метода `Collectors.joining`

Для выполнения конкатенации строк с использованием метода `Collectors.joining` в `Java Stream API`, вы можете использовать этот метод для объединения строк из вашего потока в одну строку с заданным разделителем. Вот как это делается:

### 1. Создайте поток данных (`Stream`) со строками:

```java
List<String> words = Arrays.asList("Hello", "World", "Java", "Stream");
Stream<String> wordStream = words.stream();
```
### 2. Используйте метод `collect` с аргументом `Collectors.joining(delimiter)` для выполнения конкатенации строк:

```java
String result = wordStream.collect(Collectors.joining(", "));
```
Здесь `", "` - это разделитель, который будет использоваться между объединяемыми строками.

### 3. Результат конкатенации будет сохранен в переменной `result`:

```java
System.out.println("Результат конкатенации: " + result);
```
В этом примере мы выводим результат на консоль.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class JoiningExample {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("Hello", "World", "Java", "Stream");
        Stream<String> wordStream = words.stream();
        
        String result = wordStream.collect(Collectors.joining(", "));
        
        System.out.println("Результат конкатенации: " + result);
    }
}
```
Этот код выполняет конкатенацию строк из потока с использованием запятой и пробела в качестве разделителя и выводит результат на консоль. Вы можете изменить разделитель на свой собственный, в зависимости от ваших потребностей.

[наверх](#java-stream-api)

## Как выполнить подсчет элементов с использованием метода `Collectors.counting`

Для выполнения подсчета элементов с использованием метода `Collectors.counting` в `Java Stream API`, вы можете использовать этот метод для подсчета количества элементов в вашем потоке данных. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
Stream<String> nameStream = names.stream();
```
### 2. Используйте метод `collect` с аргументом `Collectors.counting()` для выполнения подсчета элементов:

```java
long count = nameStream.collect(Collectors.counting());
```
Метод `Collectors.counting()` возвращает количество элементов в потоке.

### 3. Результат подсчета будет сохранен в переменной `count`:

```java
System.out.println("Количество элементов: " + count);
```
В этом примере мы выводим результат на консоль.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class CountingExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David");
        Stream<String> nameStream = names.stream();
        
        long count = nameStream.collect(Collectors.counting());
        
        System.out.println("Количество элементов: " + count);
    }
}
```
Этот код выполняет подсчет элементов в потоке данных и выводит результат на консоль. Метод `Collectors.counting()` удобен для быстрого подсчета элементов в потоке без необходимости использовать более сложные методы.

[наверх](#java-stream-api)

## Как использовать `Parallel Streams` в `Java Stream API`

`Parallel Streams` в `Java Stream API` предоставляют возможность выполнять операции на потоках параллельно, что может улучшить производительность при обработке больших объемов данных. Для создания параллельного потока можно использовать метод `parallelStream()` вместо `stream()` для коллекции или массива данных. Вот пример использования `Parallel Streams`:

```java
import java.util.Arrays;
import java.util.List;

public class ParallelStreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Создание параллельного потока
        long sum = numbers.parallelStream()
                        .filter(n -> n % 2 == 0) // Фильтрация четных чисел
                        .mapToInt(Integer::intValue) // Преобразование в примитивный int
                        .sum(); // Вычисление суммы
        
        System.out.println("Сумма четных чисел: " + sum);
    }
}
```
В этом примере мы создаем параллельный поток данных из списка чисел и выполняем операции фильтрации (выбора четных чисел), отображения (преобразования в `int`) и вычисления суммы параллельно. 

`Parallel Streams` автоматически распределяют задачи на несколько потоков, что позволяет ускорить выполнение операций на многоядерных процессорах.

### Однако стоит помнить о следующих важных аспектах при использовании `Parallel Streams`:

1. `Параллельные потоки не всегда быстрее`: В некоторых случаях использование параллельных потоков может ухудшить производительность из-за накладных расходов на управление потоками. Решение о том, следует ли использовать `Parallel Streams`, зависит от конкретной задачи и данных.

2. `Безопасность при работе с многопоточностью`: При обработке данных в параллельных потоках убедитесь, что ваш код безопасен с точки зрения многопоточности. Избегайте изменения общих ресурсов из разных потоков без синхронизации.

3. `Потоконезависимые операции`: Некоторые операции, такие как forEach, могут не подходить для параллельных потоков, так как порядок выполнения операций может быть неопределенным.

4. `Учет памяти`: Параллельные потоки могут потреблять больше памяти из-за создания дополнительных потоков.

Обратите внимание на эти аспекты при использовании `Parallel Streams` и проводите тестирование производительности, чтобы определить, действительно ли они улучшают выполнение вашей задачи.

[наверх](#java-stream-api)

## Как проверить, пуст ли поток данных с использованием метода `isEmpty`

`Java Stream API` предоставляет несколько способов проверки, пуст ли поток данных. Однако метод `isEmpty` напрямую в `Stream API` не существует. Вместо этого вы можете использовать следующие методы и операции для проверки наличия элементов в потоке:

1. `count()` и `equals(0)`: Вы можете использовать метод `count()` для подсчета элементов в потоке и сравнить результат с `0`. Если количество элементов равно `0`, это означает, что поток пустой.

```java
long count = stream.count();
boolean isEmpty = count == 0;
```
2. `findAny()` и `isPresent()`: Вы можете использовать метод `findAny()` для попытки найти любой элемент в потоке. Затем вы можете проверить, присутствует ли элемент с помощью `isPresent()`. Если элемент не найден, поток считается пустым.

```java
Optional<T> anyElement = stream.findAny();
boolean isEmpty = !anyElement.isPresent();
```
3. `toArray()` и `length`: Преобразуйте поток в массив и проверьте длину массива. Если длина равна `0`, поток считается пустым.

```java
Object[] array = stream.toArray();
boolean isEmpty = array.length == 0;
```
4. `collect(Collectors.toList())` и `isEmpty()`: Соберите элементы потока в список и используйте метод `isEmpty()` списка для проверки пустоты.

```java
List<T> list = stream.collect(Collectors.toList());
boolean isEmpty = list.isEmpty();
```
5. `anyMatch(predicate)`: Если вы хотите проверить, есть ли хотя бы один элемент, удовлетворяющий определенному условию, вы можете использовать метод `anyMatch(predicate)`:

```java
boolean anyMatch = stream.anyMatch(element -> element.someCondition());
```
Какой метод выбрать зависит от конкретной ситуации и ваших потребностей.

[наверх](#java-stream-api)

## Как проверить, содержит ли поток данных определенный элемент с использованием `anyMatch`

Для проверки, содержит ли поток данных определенный элемент с использованием метода `anyMatch` в `Java Stream API`, вы можете передать `предикат` (условие) в метод `anyMatch`, который будет проверять каждый элемент потока на соответствие этому условию. Если хотя бы один элемент удовлетворяет условию, метод вернет `true`, в противном случае - `false`. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
Stream<String> wordStream = words.stream();
```
### 2. Используйте метод `anyMatch` с предикатом для проверки наличия определенного элемента в потоке:

```java
boolean containsBanana = wordStream.anyMatch(word -> word.equals("banana"));
```
В этом примере мы проверяем, содержит ли поток слово `"banana"`.

### 3. Результат проверки будет сохранен в переменной `containsBanana`:

```java
System.out.println("Содержит 'banana': " + containsBanana);
```
В этом примере мы выводим результат на консоль.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Stream;

public class AnyMatchExample {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "cherry", "date");
        Stream<String> wordStream = words.stream();
        
        boolean containsBanana = wordStream.anyMatch(word -> word.equals("banana"));
        
        System.out.println("Содержит 'banana': " + containsBanana);
    }
}
```
Этот код проверяет, содержит ли поток слово "banana" и выводит результат на консоль. Вы можете адаптировать этот пример для проверки наличия любого другого элемента в потоке, используя соответствующий предикат.

[наверх](#java-stream-api)

## Проверить, все ли элементы потока данных соответствуют определенному условию с `allMatch`

Для проверки, соответствуют ли все элементы потока данных определенному условию с использованием метода `allMatch` в `Java Stream API`, вы можете передать `предикат` (условие) в метод `allMatch`, который будет проверять каждый элемент потока на соответствие этому условию. Если все элементы удовлетворяют условию, метод вернет `true`, в противном случае - `false`. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);
Stream<Integer> numberStream = numbers.stream();
```
### 2. Используйте метод `allMatch` с предикатом для проверки, соответствуют ли все элементы условию (например, проверим, что все числа четные):

```java
boolean allEven = numberStream.allMatch(number -> number % 2 == 0);
```
В этом примере мы проверяем, что все числа в потоке четные.

Результат проверки будет сохранен в переменной `allEven`:

```java
System.out.println("Все числа четные: " + allEven);
```
В этом примере мы выводим результат на консоль.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Stream;

public class AllMatchExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 10);
        Stream<Integer> numberStream = numbers.stream();
        
        boolean allEven = numberStream.allMatch(number -> number % 2 == 0);
        
        System.out.println("Все числа четные: " + allEven);
    }
}
```
Этот код проверяет, что все числа в потоке четные, и выводит результат на консоль. Вы можете адаптировать этот пример для проверки других условий в вашем потоке данных, используя соответствующий предикат.

[наверх](#java-stream-api)

## Проверить что ни один элемент потока данных не соответствует определенному условию с `noneMatch`

Для проверки, не соответствует ли ни один элемент потока данных определенному условию с использованием метода `noneMatch` в `Java Stream API`, вы можете передать предикат (условие) в метод noneMatch, который будет проверять каждый элемент потока на несоответствие этому условию. Если ни один элемент не удовлетворяет условию, метод вернет `true`, в противном случае - `false`. Вот как это делается:

### 1. Создайте поток данных (`Stream`):

```java
List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 9);
Stream<Integer> numberStream = numbers.stream();
```
### 2. Используйте метод `noneMatch` с `предикатом` для проверки, не соответствует ли ни один элемент условию 
Например, проверим, *что ни одно число не равно 7*:

```java
boolean noneEqualSeven = numberStream.noneMatch(number -> number == 7);
```
В этом примере мы проверяем, что `ни одно число в потоке не равно 7`.

### 3. Результат проверки будет сохранен в переменной `noneEqualSeven`:

```java
System.out.println("Ни одно число не равно 7: " + noneEqualSeven);
```
В этом примере мы выводим результат на консоль.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Stream;

public class NoneMatchExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(2, 4, 6, 8, 9);
        Stream<Integer> numberStream = numbers.stream();
        
        boolean noneEqualSeven = numberStream.noneMatch(number -> number == 7);
        
        System.out.println("Ни одно число не равно 7: " + noneEqualSeven);
    }
}
```
Этот код проверяет, что ни одно число в потоке не равно `7`, и выводит результат на консоль. Вы можете адаптировать этот пример для проверки других условий в вашем потоке данных, используя соответствующий предикат.

[наверх](#java-stream-api)

## Выполнить операцию пропуска элементов с использованием метода `skip`

Метод `skip` в `Java Stream API` используется для пропуска определенного количества элементов в начале потока данных и создания нового потока, содержащего оставшиеся элементы. Вот как выполнить операцию пропуска элементов с использованием метода `skip`:

### 1. Создайте поток данных (`Stream`):

```java
List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date", "fig");
Stream<String> fruitStream = fruits.stream();
```
### 2. Используйте метод `skip(n)` для пропуска `n` элементов в начале потока:

Новый поток будет содержать оставшиеся элементы после пропуска

```java
Stream<String> skippedFruitStream = fruitStream.skip(2);
```
В этом примере мы пропускаем первые два элемента, поэтому `skippedFruitStream` будет содержать `"cherry"`, `"date"` и `"fig"`.

### 3. Вы можете выполнить дальнейшие операции на новом потоке, например, использовать `forEach` для вывода оставшихся элементов:

```java
skippedFruitStream.forEach(System.out::println);
```
Этот код выведет на консоль оставшиеся фрукты после пропуска первых двух.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Stream;

public class SkipExample {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date", "fig");
        Stream<String> fruitStream = fruits.stream();
        
        Stream<String> skippedFruitStream = fruitStream.skip(2);
        
        skippedFruitStream.forEach(System.out::println);
    }
}
```
Этот код пропускает два элемента в начале потока и выводит оставшиеся элементы на консоль. Вы можете адаптировать операцию `skip` для пропуска нужного количества элементов в вашем потоке данных.

[наверх](#java-stream-api)

## Выполнить операцию ограничения числа элементов с использованием `limit`

Метод `limit` в `Java Stream API` используется для ограничения числа элементов в потоке данных. Он позволяет взять первые n элементов из потока и создать новый поток, содержащий только эти элементы. Вот как выполнить операцию ограничения числа элементов с использованием метода `limit`:

### 1. Создайте поток данных (`Stream`):

```java
List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date", "fig");
Stream<String> fruitStream = fruits.stream();
```
### 2. Используйте метод `limit(n)` для ограничения потока первыми `n` элементами:

```java
Stream<String> limitedFruitStream = fruitStream.limit(3);
```
В этом примере мы ограничиваем поток первыми тремя элементами, поэтому `limitedFruitStream` будет содержать только `"apple"`, `"banana"` и `"cherry"`.

### 3. Вы можете выполнить дальнейшие операции на новом потоке. 

Например, вывести ограниченные элементы на консоль:

```java
limitedFruitStream.forEach(System.out::println);
```
Этот код выведет на консоль ограниченные элементы потока.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Stream;

public class LimitExample {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("apple", "banana", "cherry", "date", "fig");
        Stream<String> fruitStream = fruits.stream();
        
        Stream<String> limitedFruitStream = fruitStream.limit(3);
        
        limitedFruitStream.forEach(System.out::println);
    }
}
```
Этот код ограничивает поток первыми тремя элементами и выводит их на консоль. Вы можете адаптировать операцию `limit` для ограничения нужного числа элементов в вашем потоке данных.

[наверх](#java-stream-api)

## Какие функции предоставляются интерфейсом `Function` и как они используются в `Java Stream API`

Интерфейс `Function` в `Java` представляет собой функциональный интерфейс, который содержит один абстрактный метод `apply`. Этот метод принимает один аргумент и возвращает результат. Интерфейс `Function` используется для представления функций, которые принимают аргумент и возвращают результат, и часто используется в `Java Stream API` для преобразования элементов потока или выполнения операций над ними.

Вот основные функции, предоставляемые интерфейсом `Function`, и как они используются в `Java Stream API`:

1. `apply(T t) -> R`: Это основной метод интерфейса `Function`. Он принимает один аргумент типа `T` и возвращает результат типа `R`. Пример использования:

```java
Function<String, Integer> stringToLength = s -> s.length();
int length = stringToLength.apply("Hello");
// Результат: length = 5
```
В этом примере мы создаем функцию `stringToLength`, которая принимает строку и возвращает ее длину.

2. `andThen(Function<? super R, ? extends V> after) -> Function<T, V>`: Этот метод позволяет **композицию** функций. Вы можете выполнить одну функцию, а затем применить другую к результату. Пример:

```java
Function<Integer, Double> squareRoot = Math::sqrt;
Function<Integer, String> intToString = Object::toString;
Function<Integer, String> sqrtToString = squareRoot.andThen(intToString);

String result = sqrtToString.apply(25);
// Результат: result = "5.0"
```
В этом примере мы `сначала вычисляем квадратный корень числа`, а затем `преобразуем результат в строку`.

3. `compose(Function<? super V, ? extends T> before) -> Function<V, R>`: Этот метод позволяет композицию функций в обратном порядке. Вы сначала применяете внешнюю функцию, а затем внутреннюю к результату. Пример:

```java
Function<Integer, Double> squareRoot = Math::sqrt;
Function<Double, String> doubleToString = Object::toString;
Function<Integer, String> sqrtToString = doubleToString.compose(squareRoot);

String result = sqrtToString.apply(25);
// Результат: result = "5.0"
```
В этом примере мы сначала `вычисляем квадратный корень числа`, а затем `преобразуем результат в строку`, но с использованием метода `compose`.

Эти функции интерфейса `Function` могут быть использованы в `Java Stream API` для выполнения различных операций, таких как отображение элементов, фильтрация, преобразование и другие манипуляции с данными в потоке.

[наверх](#java-stream-api)

## Какие функции предоставляются интерфейсом `Predicate` и как они используются в `Java Stream API`

Интерфейс `Predicate` в `Java` представляет собой функциональный интерфейс, который содержит один абстрактный метод `test`. Этот метод принимает один аргумент и возвращает булево значение `true` или `false`. Интерфейс `Predicate` используется для представления условий или предикатов, которые выполняют проверку на соответствие какому-либо критерию.

Вот основные функции, предоставляемые интерфейсом `Predicate`, и как они используются в `Java Stream API`:

1. `test(T t) -> boolean`: Это основной метод интерфейса `Predicate`. Он принимает один аргумент типа `T` и возвращает `true`, если условие выполняется для этого аргумента, и `false` в противном случае. Пример использования:

```java
Predicate<Integer> isEven = n -> n % 2 == 0;
boolean result = isEven.test(4);
// Результат: result = true
```
В этом примере мы создаем предикат `isEven`, который проверяет, является ли число четным.

2. `and(Predicate<? super T> other) -> Predicate<T>`: Этот метод позволяет объединять предикаты с помощью логической операции `AND`. Вы можете использовать его для создания более сложных условий. Пример:

```java
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEvenAndPositive = isEven.and(isPositive);

boolean result = isEvenAndPositive.test(4);
// Результат: result = true
```
В этом примере мы создаем предикаты `isEven` и `isPositive`, а затем объединяем их в `isEvenAndPositive`, который проверяет, что число является и четным, и положительным.

3. `or(Predicate<? super T> other) -> Predicate<T>`: Этот метод позволяет объединять предикаты с помощью логической операции `OR`. Вы можете использовать его для создания более сложных условий. Пример:

```java
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> isEvenOrPositive = isEven.or(isPositive);

boolean result = isEvenOrPositive.test(-3);
// Результат: result = true
```
В этом примере мы создаем предикаты `isEven` и `isPositive`, а затем объединяем их в `isEvenOrPositive`, который проверяет, что число является либо четным, либо положительным.

4. `negate() -> Predicate<T>`: Этот метод позволяет инвертировать предикат, то есть он возвращает новый предикат, который выполняет противоположную проверку. Пример:

```java
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> isNotEven = isEven.negate();

boolean result = isNotEven.test(3);
// Результат: result = true
```
В этом примере мы создаем предикат `isEven`, а затем инвертируем его в `isNotEven`, который проверяет, что число нечетное.

Эти функции интерфейса `Predicate` могут быть использованы в `Java Stream API` для выполнения различных операций, таких как фильтрация, проверка на соответствие условию и другие манипуляции с данными в потоке. Например, метод `filter` потока использует предикат для фильтрации элементов.

[наверх](#java-stream-api)

## Какие функции предоставляются интерфейсом `Comparator` и как они используются для сортировки элементов

Интерфейс `Comparator` в `Java` используется для сравнения объектов и определения их порядка сортировки. Он содержит один абстрактный метод compare, который принимает два аргумента и возвращает отрицательное число, если первый объект меньше второго, положительное число, если первый объект больше второго, и ноль, если объекты равны.

Вот основные функции, предоставляемые интерфейсом `Comparator`, и как они используются для сортировки элементов:

1. `compare(T o1, T o2) -> int`: Это основной метод интерфейса `Comparator`. Он сравнивает два объекта типа `T` и возвращает целое число. Если `o1` меньше `o2`, метод должен вернуть отрицательное число; если `o1` больше `o2`, метод должен вернуть положительное число; если объекты равны, метод должен вернуть ноль.

Пример использования для сортировки целых чисел в порядке возрастания:

```java
Comparator<Integer> ascendingOrder = (o1, o2) -> o1.compareTo(o2);
```
2. `reversed() -> Comparator<T>`: Этот метод возвращает обратный компаратор, который изменяет направление сортировки на противоположное. То есть, если исходный компаратор сортировал по возрастанию, то `reversed()` создаст компаратор для сортировки по убыванию.

Пример использования для сортировки целых чисел в порядке убывания:

```java
Comparator<Integer> descendingOrder = ascendingOrder.reversed();
```
3. `thenComparing(Comparator<? super T> other) -> Comparator<T>`: Этот метод позволяет создать компаратор, который использует дополнительный компаратор для сравнения объектов, если основной компаратор вернул равенство. Это позволяет выполнить множественную сортировку по нескольким критериям.

Пример использования для сортировки объектов по полю `age`, а затем по полю name в случае равных возрастов:

```java
Comparator<Person> byAge = Comparator.comparingInt(Person::getAge);
Comparator<Person> byName = Comparator.comparing(Person::getName);
Comparator<Person> byAgeThenByName = byAge.thenComparing(byName);
```
4. `nullsFirst()` и `nullsLast()`: Эти методы позволяют определить, как следует обрабатывать `null` значения при сортировке. `nullsFirst()` ставит `null` значения в начало сортировки, а `nullsLast()` ставит их в конец.

Пример использования для сортировки объектов по возрасту, с учетом `null` значений:

```java
Comparator<Person> ageWithNullsFirst = Comparator.comparing(Person::getAge, Comparator.nullsFirst(Integer::compareTo));
```
Эти функции интерфейса `Comparator` могут быть использованы для определения способов сортировки объектов в коллекции или потоке данных. Например, метод `sorted` потока использует компаратор для выполнения сортировки элементов в потоке.

[наверх](#java-stream-api)

## Как выполнить операцию объединения нескольких потоков данных с использованием метода `concat`

Для объединения нескольких потоков данных в `Java Stream API` можно использовать метод `Stream.concat`. Этот метод принимает два потока данных и создает новый поток, в котором элементы из первого потока следуют перед элементами из второго потока. Вот как выполнить операцию объединения нескольких потоков с использованием метода `concat`:

### 1. Создайте два или более потоков данных (`Stream`):

```java
List<String> stream1 = Arrays.asList("a", "b", "c");
List<String> stream2 = Arrays.asList("1", "2", "3");
Stream<String> firstStream = stream1.stream();
Stream<String> secondStream = stream2.stream();
```
### 2. Используйте метод `Stream.concat` для объединения потоков данных:

```java
Stream<String> combinedStream = Stream.concat(firstStream, secondStream);
```
В этом примере мы объединяем `firstStream` и `secondStream` в новом потоке данных `combinedStream`.

### 3. Вы можете выполнить дальнейшие операции на объединенном потоке:

Например, преобразовать элементы или выполнить фильтрацию:

```java
combinedStream.map(String::toUpperCase).forEach(System.out::println);
```
В этом примере мы переводим элементы в верхний регистр и выводим их на консоль.

### Полный код примера:

```java
import java.util.*;
import java.util.stream.Stream;

public class ConcatenateStreamsExample {
    public static void main(String[] args) {
        List<String> stream1 = Arrays.asList("a", "b", "c");
        List<String> stream2 = Arrays.asList("1", "2", "3");
        Stream<String> firstStream = stream1.stream();
        Stream<String> secondStream = stream2.stream();
        
        Stream<String> combinedStream = Stream.concat(firstStream, secondStream);
        
        combinedStream.map(String::toUpperCase).forEach(System.out::println);
    }
}
```
Этот код объединяет два потока данных и преобразует элементы в верхний регистр перед выводом на консоль. Вы можете адаптировать этот пример для объединения любого количества потоков данных и выполнения нужных операций над элементами.

[наверх](#java-stream-api)

## Операции поиска мин и макс элементов с использованием методов `min` и `max`

Для выполнения операции поиска минимального и максимального элементов в потоке данных с использованием методов `min` и `max` в `Java Stream API`, вы можете использовать следующие методы:

1. `min(Comparator<? super T> comparator)`: Этот метод возвращает минимальный элемент в потоке данных, согласно заданному компаратору (или естественному порядку, если компаратор не предоставлен). Если поток данных пуст, он вернет пустой `Optional`.

2. `max(Comparator<? super T> comparator)`: Этот метод возвращает максимальный элемент в потоке данных, согласно заданному компаратору (или естественному порядку, если компаратор не предоставлен). Если поток данных пуст, он вернет пустой `Optional`.

Вот примеры использования этих методов:

```java
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.Comparator;

public class MinMaxExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5);

        // Находим минимальное значение
        Optional<Integer> min = numbers.stream().min(Comparator.naturalOrder());
        if (min.isPresent()) {
            System.out.println("Минимальное значение: " + min.get());
        } else {
            System.out.println("Поток данных пуст");
        }

        // Находим максимальное значение
        Optional<Integer> max = numbers.stream().max(Comparator.naturalOrder());
        if (max.isPresent()) {
            System.out.println("Максимальное значение: " + max.get());
        } else {
            System.out.println("Поток данных пуст");
        }
    }
}
```
В этом примере мы используем метод `min` и `max` для поиска минимального и максимального значений в списке чисел. Обратите внимание, что мы передаем `Comparator.naturalOrder()` в качестве компаратора, чтобы использовать естественный порядок сравнения для чисел.

[наверх](#java-stream-api)

## Операции преобразования элементов с использованием метода `mapToInt`, `mapToDouble` и `mapToObj`

Методы `mapToInt`, `mapToDouble` и `mapToObj` в `Java Stream API` используются для выполнения операции преобразования элементов в потоке данных в определенный тип данных (`int`, `double` или `объект` другого класса). Они возвращают новый поток данных, содержащий элементы после преобразования. Вот как они используются:

1. `mapToInt`: Этот метод преобразует элементы потока в тип `int`. Вы можете указать функцию (лямбда-выражение или метод ссылки), которая будет применена к каждому элементу, чтобы выполнить преобразование в `int`.

Пример преобразования списка строк в список длин строк (количество символов):

```java
List<String> words = Arrays.asList("apple", "banana", "cherry");
IntStream lengths = words.stream().mapToInt(String::length);
```

2. `mapToDouble`: Этот метод преобразует элементы потока в тип `double`. Вы также можете указать функцию для преобразования.

Пример преобразования списка чисел в список их квадратных корней:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
DoubleStream roots = numbers.stream().mapToDouble(Math::sqrt);
```

3. `mapToObj`: Этот метод позволяет преобразовать элементы в объекты другого типа. Вы указываете функцию, которая выполняет преобразование.

Пример преобразования списка целых чисел в список строк:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Stream<String> strings = numbers.stream().mapToObj(String::valueOf);
```
Обратите внимание, что при использовании методов `mapToInt`, `mapToDouble` и `mapToObj`, вы получаете поток специфического типа (например, `IntStream`, `DoubleStream`, `Stream`), который соответствует типу, указанному в методе. Вы можете выполнять дальнейшие операции над этими потоками данных в зависимости от нужных вам результатов.

Эти методы полезны, когда вам необходимо выполнить преобразование элементов в потоке в другие типы данных, что позволяет вам легко выполнять различные вычисления и манипуляции с данными.

[наверх](#java-stream-api)

## Операция дистинкции (удаления дубликатов) с использованием метода `distinct`

В `Java Stream API`, операцию удаления дубликатов из потока данных можно выполнить с использованием метода `distinct()`. Метод `distinct()` возвращает новый поток данных, содержащий уникальные элементы из исходного потока. Вот как это работает:

Пример удаления дубликатов из списка строк:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class DistinctExample {
    public static void main(String[] args) {
        List<String> colors = Arrays.asList("red", "green", "blue", "red", "green", "yellow");

        // Используйте метод distinct() для удаления дубликатов
        List<String> distinctColors = colors.stream()
                .distinct()
                .collect(Collectors.toList());

        System.out.println("Исходный список: " + colors);
        System.out.println("Список без дубликатов: " + distinctColors);
    }
}
```
В этом примере, вызов `distinct()` после `stream()` удаляет дубликаты из исходного списка `colors`. Результат сохраняется в новом списке `distinctColors`. После этого вы можете использовать collect(Collectors.toList()) для преобразования потока обратно в список.

Результат выполнения программы:

```less
Исходный список: [red, green, blue, red, green, yellow]
Список без дубликатов: [red, green, blue, yellow]
```
Обратите внимание, что порядок элементов в исходном потоке сохраняется, и только дубликаты удаляются.

Метод `distinct()` базируется на методе `equals()` для сравнения элементов, поэтому он удаляет элементы, которые равны по сравнению с другими элементами в потоке. Если вам необходимо выполнить более сложное сравнение или определить критерии уникальности, вы можете использовать метод `distinct` с собственным компаратором.


[наверх](#java-stream-api)

## Операция объединения элементов в одну строку с использованием метода `reduce`

Операцию объединения элементов в одну строку с использованием метода `reduce` можно выполнить, например, для создания строки, содержащей все элементы из потока данных, разделенные определенным разделителем. Вот пример использования метода `reduce` для этой цели:

```java
import java.util.Arrays;
import java.util.List;

public class ReduceExample {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("Hello", "world", "Java", "Stream", "API");

        // Используем метод reduce для объединения элементов в одну строку с разделителем
        String concatenatedString = words.stream()
                .reduce((word1, word2) -> word1 + ", " + word2)
                .orElse("");

        System.out.println("Объединенная строка: " + concatenatedString);
    }
}
```
В этом примере мы используем метод reduce, который принимает лямбда-выражение `(word1, word2) -> word1 + ", " + word2` для объединения двух слов с запятой и пробелом. После этого, мы используем `orElse("")`, чтобы предоставить пустую строку в качестве значения по умолчанию, если поток данных был пуст.

Результат выполнения программы:

```less
Объединенная строка: Hello, world, Java, Stream, API
```
В этом примере мы объединили элементы из списка `words` в одну строку, разделив их запятыми и пробелами. Вы можете изменить разделитель и логику объединения в лямбда-выражении в методе reduce в зависимости от ваших потребностей.

[наверх](#java-stream-api)

## Как выполнить операцию суммирования элементов с использованием метода `sum`

В `Java Stream API`, для выполнения операции суммирования элементов в числовом потоке данных, вы можете использовать метод `sum()`, предоставляемый различными числовыми потоками, такими как `IntStream`, `LongStream` и `DoubleStream`. Вот как это работает:

Пример суммирования элементов в `IntStream`:

```java
import java.util.stream.IntStream;

public class SumExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        // Создаем IntStream из массива чисел и суммируем элементы
        int sum = IntStream.of(numbers).sum();

        System.out.println("Сумма чисел: " + sum);
    }
}
```
Пример суммирования элементов в `LongStream`:

```java
import java.util.stream.LongStream;

public class SumExample {
    public static void main(String[] args) {
        long[] numbers = {100, 200, 300, 400, 500};

        // Создаем LongStream из массива чисел и суммируем элементы
        long sum = LongStream.of(numbers).sum();

        System.out.println("Сумма чисел: " + sum);
    }
}
```
Пример суммирования элементов в `DoubleStream`:

```java
import java.util.stream.DoubleStream;

public class SumExample {
    public static void main(String[] args) {
        double[] numbers = {1.5, 2.0, 3.5, 4.0, 5.0};

        // Создаем DoubleStream из массива чисел и суммируем элементы
        double sum = DoubleStream.of(numbers).sum();

        System.out.println("Сумма чисел: " + sum);
    }
}
```
В каждом из этих примеров мы сначала создаем числовой поток данных (например, `IntStream`, `LongStream`, или `DoubleStream`) из массива чисел, а затем используем метод `sum()` для суммирования элементов в этом потоке данных. Результат суммирования сохраняется в переменной `sum`.

Обратите внимание, что метод `sum()` доступен только для числовых потоков данных и не может быть использован с общими объектными потоками данных `(Stream<T>)`.

[наверх](#java-stream-api)

## Операция нахождения среднего значения элементов с использованием метода `average`

Для выполнения операции нахождения среднего значения элементов в числовом потоке данных, вы можете использовать метод `average()`, который предоставляется числовыми потоками, такими как `IntStream`, `LongStream` и `DoubleStream`. Вот как это работает:

### Пример нахождения среднего значения элементов в `IntStream`:

```java
import java.util.stream.IntStream;
import java.util.OptionalDouble;

public class AverageExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};

        // Создаем IntStream из массива чисел и находим среднее значение
        OptionalDouble average = IntStream.of(numbers).average();

        if (average.isPresent()) {
            System.out.println("Среднее значение: " + average.getAsDouble());
        } else {
            System.out.println("Поток данных пуст");
        }
    }
}
```

### Пример нахождения среднего значения элементов в `LongStream`:

```java
import java.util.stream.LongStream;
import java.util.OptionalDouble;

public class AverageExample {
    public static void main(String[] args) {
        long[] numbers = {100, 200, 300, 400, 500};

        // Создаем LongStream из массива чисел и находим среднее значение
        OptionalDouble average = LongStream.of(numbers).average();

        if (average.isPresent()) {
            System.out.println("Среднее значение: " + average.getAsDouble());
        } else {
            System.out.println("Поток данных пуст");
        }
    }
}
```

### Пример нахождения среднего значения элементов в `DoubleStream`:

```java
import java.util.stream.DoubleStream;
import java.util.OptionalDouble;

public class AverageExample {
    public static void main(String[] args) {
        double[] numbers = {1.5, 2.0, 3.5, 4.0, 5.0};

        // Создаем DoubleStream из массива чисел и находим среднее значение
        OptionalDouble average = DoubleStream.of(numbers).average();

        if (average.isPresent()) {
            System.out.println("Среднее значение: " + average.getAsDouble());
        } else {
            System.out.println("Поток данных пуст");
        }
    }
}
```

В каждом из этих примеров мы сначала создаем числовой поток данных (например, `IntStream`, `LongStream`, или `DoubleStream`) из массива чисел, а затем используем метод `average()` для нахождения среднего значения элементов в этом потоке данных. Результат нахождения среднего значения доступен в виде объекта `OptionalDouble`, и мы можем использовать `average.isPresent()` для проверки, было ли найдено среднее значение, а затем `average.getAsDouble()` для получения среднего значения.

Обратите внимание, что метод `average()` также работает только с числовыми потоками данных и не может быть использован с общими объектными потоками данных `(Stream<T>)`.

[наверх](#java-stream-api)

## Операция поиска первого элемента с использованием метода `findFirst`

Для выполнения операции поиска первого элемента в потоке данных с использованием метода `findFirst()` в `Java Stream API`, вы можете использовать этот метод на вашем потоке данных. Метод `findFirst()` возвращает первый элемент в потоке (если он существует) в виде объекта `Optional`. Вот как это работает:

Пример поиска первого элемента в потоке данных:

```java
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class FindFirstExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");

        // Используйте метод findFirst() для поиска первого элемента в потоке
        Optional<String> first = names.stream().findFirst();

        if (first.isPresent()) {
            System.out.println("Первый элемент: " + first.get());
        } else {
            System.out.println("Поток данных пуст");
        }
    }
}
```
В этом примере мы используем метод `findFirst()` на потоке данных, созданном из списка имен. Результат сохраняется в `Optional`, и мы используем `first.isPresent()` для проверки, был ли найден первый элемент. Если элемент найден, мы получаем его с помощью `first.get()`.

Результат выполнения программы:

```
Первый элемент: Alice
```
Обратите внимание, что порядок элементов в потоке сохраняется, и `findFirst()` вернет первый элемент в исходном порядке, если порядок определен. Если поток данных пуст, `findFirst()` вернет пустой `Optional`.

[наверх](#java-stream-api)

## Операция поиска случайного элемента с использованием метода `findAny`

Для выполнения операции поиска случайного элемента в потоке данных с использованием метода `findAny()` в `Java Stream API`, вы можете использовать этот метод на вашем потоке данных. Метод `findAny()` возвращает любой доступный элемент в потоке (если он существует) в виде объекта `Optional`. Вот как это работает:

Пример поиска случайного элемента в потоке данных:

```java
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

public class FindAnyExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");

        // Используйте метод findAny() для поиска любого доступного элемента в потоке
        Optional<String> any = names.stream().findAny();

        if (any.isPresent()) {
            System.out.println("Любой доступный элемент: " + any.get());
        } else {
            System.out.println("Поток данных пуст");
        }
    }
}
```
В этом примере мы используем метод `findAny()` на потоке данных, созданном из списка имен. Результат сохраняется в `Optional`, и мы используем `any.isPresent()` для проверки, был ли найден какой-либо доступный элемент. Если элемент найден, мы получаем его с помощью `any.get()`.

Результат выполнения программы:

```
Любой доступный элемент: Alice
```
Метод `findAny()` полезен, когда вам не важно, какой элемент будет найден, и вы просто хотите получить доступный элемент из потока данных. Если поток данных пуст, `findAny()` также вернет пустой `Optional`.

[наверх](#java-stream-api)

## Какие промежуточные операции поддерживают `lazy evaluation`

Ленивые вычисления (`lazy evaluation`) - это концепция, при которой операции выполняются только по мере необходимости, когда результаты запрашиваются. В `Java Stream API` большинство промежуточных операций поддерживают ленивые вычисления, что означает, что они не начинают выполнение, пока не вызвана терминальная операция. Это позволяет оптимизировать использование ресурсов и улучшить производительность, так как только необходимые элементы обрабатываются.

Промежуточные операции, поддерживающие ленивые вычисления, включают в себя:

1. `filter(Predicate<T> predicate)`: Фильтрация элементов, которые удовлетворяют заданному условию. Операция фильтрации выполняется лениво, и только элементы, прошедшие фильтрацию, будут переданы далее.

2. `map(Function<T, R> mapper)`: Преобразование элементов в другой тип данных. Применение функции mapper к элементам выполняется лениво.

3. `flatMap(Function<T, Stream<R>> mapper)`: Позволяет преобразовывать каждый элемент в поток данных и объединять их в один поток. Эта операция также выполняется лениво.

4. `distinct()`: Удаление дубликатов из потока данных. Эта операция также выполняется лениво.

5. `sorted()` и `sorted(Comparator<T> comparator)`: Сортировка элементов. Обратите внимание, что сортировка выполняется лениво, и только при вызове терминальной операции (например, `collect` или `forEach`) элементы будут отсортированы.

6. `peek(Consumer<T> action)`: Позволяет выполнять заданное действие над каждым элементом, оставляя поток без изменений. Это полезно для отладки и наблюдения за элементами потока. Операция peek также выполняется лениво.

7. `limit(long maxSize)` и `skip(long n)`: Ограничение числа элементов в потоке или пропуск первых `n` элементов. Эти операции выполняются лениво.

Промежуточные операции лениво вычисляются до тех пор, пока не вызвана терминальная операция, такая как `collect`, `forEach`, `reduce`, `count` и другие. Поэтому при использовании `Java Stream API` можно создавать эффективные и оптимизированные потоки данных, выполняя только необходимые вычисления.

[наверх](#java-stream-api)

## Какие промежуточные операции поддерживают `short-circuiting`

Короткое замыкание (`short-circuiting`) - это концепция, при которой выполнение операции завершается при достижении определенного условия, и дополнительные элементы не обрабатываются. В `Java Stream API`, некоторые промежуточные операции поддерживают короткое замыкание, что означает, что они могут остановиться и вернуть результат, когда достигнуто определенное условие, без обработки всех элементов потока. Ниже приведены промежуточные операции, которые поддерживают короткое замыкание:

1. `filter(Predicate<T> predicate)`: Эта операция позволяет фильтровать элементы потока на основе заданного условия. Когда операция `filter` находит элемент, который не удовлетворяет условию (`predicate`), она прекращает обработку и переходит к следующему элементу. Это позволяет сэкономить вычислительные ресурсы.

2. `findFirst()` и `findAny()`: Эти операции находят первый (или любой) элемент в потоке, удовлетворяющий заданному условию, и завершают выполнение, когда такой элемент найден. Если ни один элемент не удовлетворяет условию, операции возвращают пустой `Optional`.

3. `allMatch(Predicate<T> predicate)`: Эта операция проверяет, удовлетворяют ли все элементы потока заданному условию (`predicate`). Если найден элемент, не удовлетворяющий условию, выполнение прекращается, и результат false возвращается без проверки остальных элементов.

4. `anyMatch(Predicate<T> predicate)`: Эта операция проверяет, удовлетворяет ли хотя бы один элемент потока заданному условию (`predicate`). Как только найден удовлетворяющий элемент, выполнение прекращается, и результат `true` возвращается.

5. `noneMatch(Predicate<T> predicate)`: Эта операция проверяет, не удовлетворяет ли ни один элемент потока заданному условию (`predicate`). Как только найден элемент, удовлетворяющий условию, выполнение прекращается, и результат `false` возвращается.

6. `limit(long maxSize)`: Ограничивает поток так, чтобы он возвращал не более `maxSize` элементов. Это позволяет остановить обработку потока после получения заданного количества элементов.

7. `skip(long n)`: Пропускает первые `n` элементов потока и начинает обработку с элемента номер `n+1`. Это может быть полезно для пропуска части данных, без обработки всех элементов.

Использование этих операций с коротким замыканием может улучшить производительность и уменьшить издержки при обработке данных в потоках, так как необязательные элементы могут быть пропущены или вычисления могут быть завершены, когда это необходимо.

[наверх](#java-stream-api)

## Операцию пересечения (`intersection`) двух потоков данных с использованием метода `filter` и `collect`

Для выполнения операции пересечения (`intersection`) двух потоков данных с использованием метода `filter` и `collect` в `Java Stream API`, вы можете использовать следующий подход. Предположим, у вас есть два потока данных (например, `stream1` и `stream2`), и вы хотите найти элементы, которые присутствуют в обоих потоках. Вот как это можно сделать:

```java
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

public class IntersectionExample {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 3, 4, 5);
        List<Integer> list2 = Arrays.asList(3, 4, 5, 6, 7);

        // Создаем два потока данных из списков
        Stream<Integer> stream1 = list1.stream();
        Stream<Integer> stream2 = list2.stream();

        // Используем метод filter и collect для нахождения пересечения
        Set<Integer> intersection = stream1
            .filter(stream2.collect(Collectors.toSet())::contains)
            .collect(Collectors.toSet());

        System.out.println("Пересечение: " + intersection);
    }
}
```
В этом примере мы создаем два потока данных (`stream1` и `stream2`) из двух списков `list1` и `list2`. Затем мы используем метод `filter`, чтобы оставить только элементы из `stream1`, которые содержатся в `stream2`. Мы преобразуем `stream2` в множество с помощью `Collectors.toSet()`, чтобы обеспечить более эффективный поиск.

Результатом будет множество `intersection`, которое содержит элементы, присутствующие в обоих потоках данных.

Обратите внимание, что в этом примере элементы множества `intersection` будут в упорядоченном порядке, как в `list1`. Если вам нужно сохранить порядок элементов из `list1` или `list2`, вы можете использовать другие коллекции, такие как `ArrayList` или Linked`List, для сохранения результатов.

[наверх](#java-stream-api)

## Операция объединения (`union`) двух потоков данных с использованием метода `concat` и `distinct`

Для выполнения операции объединения (`union`) двух потоков данных с использованием метода `concat` и удаления дубликатов с использованием метода `distinct` в `Java Stream API`, вы можете использовать следующий подход. Предположим, у вас есть два потока данных (например, `stream1` и `stream2`), и вы хотите объединить их, удалив дубликаты. Вот как это можно сделать:

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

public class UnionExample {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 3, 4, 5);
        List<Integer> list2 = Arrays.asList(3, 4, 5, 6, 7);

        // Создаем два потока данных из списков
        Stream<Integer> stream1 = list1.stream();
        Stream<Integer> stream2 = list2.stream();

        // Используем метод concat для объединения потоков, затем distinct для удаления дубликатов
        Stream<Integer> union = Stream.concat(stream1, stream2)
                .distinct();

        // Выводим результат
        union.forEach(System.out::println);
    }
}
```
В этом примере мы создаем два потока данных (`stream1` и `stream2`) из двух списков `list1` и `list2`. Затем мы используем метод `concat` для объединения потоков и метод `distinct` для удаления дубликатов. В результате получается поток данных `union`, который содержит уникальные элементы из обоих исходных потоков.

Вы можете использовать другие терминальные операции для обработки или вывода элементов из потока `union` в зависимости от ваших потребностей.

[наверх](#java-stream-api)

## Операция разности (`difference`) двух потоков данных с использованием метода `filter` и `collect`

Для выполнения операции разности (`difference`) двух потоков данных с использованием метода `filter` и `collect` в `Java Stream API`, вы можете использовать следующий подход. Предположим, у вас есть два потока данных (например, `stream1` и `stream2`), и вы хотите найти элементы, которые присутствуют только в `stream1`, но не в `stream2`. Вот как это можно сделать:

```java
import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class DifferenceExample {
    public static void main(String[] args) {
        List<Integer> list1 = Arrays.asList(1, 2, 3, 4, 5);
        List<Integer> list2 = Arrays.asList(3, 4, 5, 6, 7);

        // Создаем два потока данных из списков
        Stream<Integer> stream1 = list1.stream();
        Stream<Integer> stream2 = list2.stream();

        // Используем метод filter и collect для нахождения разности
        Set<Integer> difference = stream1
            .filter(item -> !stream2.collect(Collectors.toSet()).contains(item))
            .collect(Collectors.toSet());

        System.out.println("Разность: " + difference);
    }
}
```

В этом примере мы создаем два потока данных (`stream1` и `stream2`) из двух списков `list1` и `list2`. Затем мы используем метод `filter`, чтобы оставить только элементы из `stream1`, которые не содержатся в `stream2`. Для проверки наличия элементов из `stream1` в `stream2` мы преобразуем `stream2` в множество с помощью `Collectors.toSet()` и используем метод `contains()`.

Результатом будет множество `difference`, которое содержит элементы, присутствующие только в `stream1`, но не в `stream2`.

Обратите внимание, что порядок элементов в множестве `difference` может отличаться от порядка элементов в stream1. Если вам важен определенный порядок элементов, вы можете использовать другие коллекции, такие как `ArrayList`, для сохранения результатов.

[наверх](#java-stream-api)

## Как использовать `Stream API` с пользовательскими классами и объектами

Для использования `Stream API` с пользовательскими классами и объектами в `Java`, вам необходимо выполнить следующие шаги:

1. `Создайте класс и объекты`: Создайте пользовательский класс и создайте объекты этого класса. Эти объекты будут входить в поток данных.

2. `Преобразуйте коллекцию в поток`: Преобразуйте коллекцию (например, список или массив) объектов вашего пользовательского класса в поток данных с помощью метода `stream()`.

3. `Используйте методы Stream API`: Вы можете использовать различные методы `Stream API` для обработки и манипуляции данными вашего пользовательского класса. Эти методы могут включать в себя фильтрацию, отображение, сортировку и другие операции.

4. `Завершите операцию потока`: В завершение, вызовите терминальную операцию на вашем потоке данных, такую как `collect`, `forEach`, `reduce`, `count` и так далее, чтобы получить результат или выполнить конечное действие.

Пример:

Предположим, у вас есть класс `Person`:

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```
Теперь вы можете создать список объектов `Person` и выполнить над ними операции с использованием `Stream API`:

```java
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class StreamWithCustomObjects {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 30));
        people.add(new Person("Bob", 25));
        people.add(new Person("Charlie", 35));
        people.add(new Person("David", 28));

        // Преобразование в поток и фильтрация
        List<Person> filteredPeople = people.stream()
                .filter(person -> person.getAge() >= 30)
                .collect(Collectors.toList());

        // Вывод результатов
        filteredPeople.forEach(System.out::println);
    }
}
```
В этом примере мы создаем список объектов `Person`, преобразуем его в поток данных, фильтруем по возрасту и затем собираем результаты в новый список. Вы можете использовать другие операции `Stream API` для выполнения различных манипуляций с объектами вашего пользовательского класса в потоке данных.

[наверх](#java-stream-api)

## `Исключения` при использовании `Java Stream API` и как их обрабатывать

При использовании `Java Stream API` могут возникать различные исключения. Вот некоторые из наиболее распространенных исключений, которые могут возникнуть, и способы их обработки:

1. `NullPointerException`: Это исключение может возникнуть, если какой-либо элемент в потоке данных является `null`. Например, при вызове метода `map` или `filter`, если функция, переданная в качестве аргумента, возвращает `null`, это может привести к `NullPointerException`.

2. `Обработка`: Убедитесь, что ваша функция или условие корректно обрабатывают `null` значения, или используйте методы, такие как `filterNotNull` (доступно с `Kotlin`) или `Objects.requireNonNull` для предотвращения `null` значений.

3. `IllegalStateException`: Это исключение может возникнуть, если вы попытаетесь использовать поток данных, который уже был закрыт (когда на нем вызывалась терминальная операция). Например, если попытаться выполнить `forEach` на одном и том же потоке дважды.

    **Обработка**: Убедитесь, что вы используете каждый поток данных только один раз и вызываете терминальную операцию только один раз.

4. `ArithmeticException`: Это исключение может возникнуть, например, при выполнении операции деления на ноль в методе `average` или других числовых операциях.

    **Обработка**: Предотвращайте деление на ноль и другие арифметические ошибки путем проверки значений и использования подходящих условий.

5. `ConcurrentModificationException`: Если вы пытаетесь модифицировать исходную коллекцию, из которой был создан поток данных, во время итерации по этому потоку, это может привести к `ConcurrentModificationException`.

    **Обработка**: Если вам нужно модифицировать коллекцию, сделайте это после завершения операций на потоке данных или скопируйте коллекцию перед созданием потока данных.

6. `Other Custom Exceptions`: Вы также можете столкнуться с другими исключениями, зависящими от вашей конкретной логики и операций, выполняемых в потоке данных. В этом случае важно обрабатывать их согласно вашим потребностям.

Обработка исключений в `Java Stream API` обычно выполняется с использованием конструкции `try-catch` или методов обработки исключений, таких как `try`, `catch` и `throws`. Помните, что при работе с потоками данных важно учитывать потенциальные исключения и обрабатывать их соответствующим образом, чтобы ваше приложение оставалось надежным и стабильным.

[наверх](#java-stream-api)

## Какие альтернативные подходы существуют для манипуляции данными в `Java`, помимо `Stream API`

В `Java` существует несколько альтернативных подходов для манипуляции данными, помимо `Stream API`. Каждый из них имеет свои особенности и преимущества, и выбор зависит от конкретных требований и контекста вашего проекта. Вот несколько альтернативных подходов:

### 1. Использование циклов:

* `for` и `while` циклы: Традиционные циклы позволяют более явно управлять итерацией и манипулировать данными.

### 2. Использование коллекций и итераторов:

* `ArrayList`, `LinkedList`, и другие коллекции:
Вы можете использовать стандартные коллекции и итераторы для хранения и обработки данных.

* `Iterator` и `ListIterator`: Эти интерфейсы предоставляют более гибкий способ итерации по коллекциям.

### 3. Использование массивов:

* Массивы предоставляют простой и эффективный способ хранения и обработки данных.

### 4. Использование реактивных библиотек:

* Реактивное программирование (`Reactive Programming`) позволяет работать с асинхронными и потоковыми данными. В `Java` существуют библиотеки, такие как `Reactor` и `RxJava`, которые предоставляют инструменты для работы с реактивными последовательностями данных.

### 5. Использование JDBC для работы с базами данных:

* Если вам нужно работать с данными в базах данных, `JDBC` (Java Database Connectivity) предоставляет `API` для выполнения `SQL`-запросов и манипуляции данными.

### 6. Использование библиотеки `Apache Commons Collections`:

* Эта библиотека предоставляет множество утилитарных классов и методов для работы с коллекциями и данными.

### 7. Использование `JavaFX Observable Collections`:

* Если вы работаете с графическими интерфейсами, `JavaFX` предоставляет `Observable Collections`, которые автоматически обновляются при изменении данных.

### 8. Использование `Paralellism` и `Concurrency API`:

* `Java` также предоставляет `API` для параллельных и конкурентных вычислений, такие как `Executor Framework`, `Fork/Join Framework` и `CompletableFuture`.

Выбор подхода зависит от вашей конкретной задачи, требований к производительности и уровня опыта в программировании на `Java`. 

`Stream API` является мощным и удобным инструментом для манипуляции данными в функциональном стиле, но иногда другие подходы могут быть более подходящими, особенно если вам нужно более тесное управление над процессом обработки данных.

[наверх](#java-stream-api)

## Что такое `stream`

Понятие `"stream"` (поток) в программировании, в частности, в `Java`, означает последовательность элементов данных, которая может быть обработана поочередно или параллельно. 

Потоки (`streams`) представляют собой абстракцию, которая позволяет программистам удобно работать с данными без явных циклов.

В `Java`, особенно с введением `Java 8`, `"stream"` часто ассоциируется с `Java Stream API`, который предоставляет удобные и мощные средства для манипуляции данными в коллекциях, массивах и других источниках данных. `Java Stream API` позволяет выполнять разнообразные операции, такие как фильтрация, отображение, сортировка, агрегация и другие, на потоках данных с использованием функциональных операций.

### Преимущества использования `Java Stream API` включают
* более высокий уровень абстракции
* упрощенный и лаконичный синтаксис
* возможность выполнения операций в параллельном режиме для увеличения производительности в многоядерных системах.

Пример использования `Java Stream API`:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
int sum = numbers.stream()
               .filter(n -> n % 2 == 0)
               .mapToInt(Integer::intValue)
               .sum();
System.out.println("Сумма четных чисел: " + sum);
```
В этом примере, мы создаем поток данных из списка чисел, фильтруем только четные числа, затем суммируем их. Это основная идея работы с `Java Stream API` и потоками данных в `Java`.

[наверх](#java-stream-api) | [назад](../README.md)

