# Java Generics

[назад](../README.md)

* [Что такое `Generics` в `Java` и зачем они нужны](#что-такое-generics-в-java-и-зачем-они-нужны)
* [Что такое стирание типов `Type Erasure` и как оно работает](#что-такое-стирание-типов-type-erasure-и-как-оно-работает)
* [Можно ли использовать примитивные типы с `Generics`](#можно-ли-использовать-примитивные-типы-с-generics)
* [Чем отличается `List<Object>` от `List<?>`](#чем-отличается-list<object>-от-list<>)
* [Что такое `bounded wildcard` в `Generics` и как это использовать](#что-такое-bounded-wildcard-в-generics-и-как-это-использовать)
* [Как работают обобщённые методы](#как-работают-обобщённые-методы)
* [Могут ли обобщённые классы использовать несколько типов параметров](#могут-ли-обобщённые-классы-использовать-несколько-типов-параметров)
* [Почему нельзя создавать массивы обобщённых типов](#почему-нельзя-создавать-массивы-обобщённых-типов)
* [Что такое `invariance` в `Generics` и как она влияет на совместимость `List<Object>` и `List<String>`](#что-такое-invariance-в-generics-и-как-она-влияет-на-совместимость-list<object>-и-list<string>)
* [Можете ли вы перегружать методы с разными обобщёнными параметрами](#можете-ли-вы-перегружать-методы-с-разными-обобщёнными-параметрами)
* [Что такое `wildcard` (?) в `Generics` и зачем он нужен](#что-такое-wildcard--в-generics-и-зачем-он-нужен)
* [Когда следует использовать `? extends T`, а когда `? super T`](#когда-следует-использовать--extends-t-а-когда--super-t)
* [Почему статические поля и методы не могут использовать обобщённые параметры](#почему-статические-поля-и-методы-не-могут-использовать-обобщённые-параметры)
* [Как обобщённые типы могут быть ограничены](#как-обобщённые-типы-могут-быть-ограничены)
* [Как происходит вывод типа (`type inference`) в `Generics`](#как-происходит-вывод-типа-type-inference-в-generics)

## Что такое `Generics` в `Java` и зачем они нужны

`Generics` позволяют параметризовать классы, интерфейсы и методы типами данных, что помогает повысить безопасность типов на этапе компиляции.

[наверх](#java-generics)

## Что такое стирание типов `Type Erasure` и как оно работает

Стирание типов — это механизм, при котором информация о типах удаляется на этапе компиляции, и обобщённые типы заменяются на их ограничения или `Object`.

[наверх](#java-generics)

## Можно ли использовать примитивные типы с `Generics`

Нет, `Generics` работают только с объектными типами, но вы можете использовать их оболочки (например, `Integer` вместо `int`).

[наверх](#java-generics)

## Чем отличается `List<Object>` от `List<?>`

`List<Object>` ожидает только объекты типа `Object` или его подтипов, а `List<?>` может принимать объекты любого типа, но без конкретного ограничения.

[наверх](#java-generics)

## Что такое `bounded wildcard` в `Generics` и как это использовать

`? extends T` и `? super T` — это `bounded wildcards`. `? extends T` используется, когда вам нужно работать с типом, который является подтипом `T`, а `? super T` — с типом, который является суперклассом `T`.

[наверх](#java-generics)

## Как работают обобщённые методы

Обобщённые методы могут работать с любыми типами данных, определёнными при вызове метода:
```java
public <T> void printArray(T[] array) {
    for (T element : array) {
        System.out.println(element);
    }
}
```

[наверх](#java-generics)

## Могут ли обобщённые классы использовать несколько типов параметров

Да, класс может иметь несколько параметризованных типов:
```java
public class Pair<K, V> {
    private K key;
    private V value;
    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }
}
```

[наверх](#java-generics)

## Почему нельзя создавать массивы обобщённых типов

Это запрещено из-за стирания типов. Во время выполнения информация о типах теряется, а массивы в `Java` проверяются на этапе выполнения, что может привести к проблемам с безопасностью типов.

[наверх](#java-generics)

## Что такое `invariance` в `Generics` и как она влияет на совместимость `List<Object>` и `List<String>`

`Invariance` означает, что `List<Object>` и `List<String>` — это разные типы, и они не могут быть совместимы между собой. Даже если `String` является подтипом `Object`, `List<String>` не является подтипом `List<Object>`.

[наверх](#java-generics)

## Можете ли вы перегружать методы с разными обобщёнными параметрами

Нет, перегрузка методов с разными параметризованными типами не работает из-за стирания типов:
```java
public void method(List<String> list) {}
public void method(List<Integer> list) {} // Ошибка компиляции из-за стирания типов
```

[наверх](#java-generics)


## Что такое `wildcard` (?) в `Generics` и зачем он нужен
`Wildcard (?)` представляет неизвестный тип. Он полезен, когда вам неважен конкретный тип, но нужно работать с любым типом в пределах указанных ограничений.

[наверх](#java-generics)

## Когда следует использовать `? extends T`, а когда `? super T`
`? extends T` следует использовать, когда вы хотите только читать данные из коллекции, а `? super T` — когда нужно записывать данные в коллекцию.

[наверх](#java-generics)

## Почему статические поля и методы не могут использовать обобщённые параметры
Статические элементы принадлежат классу, а не объекту, и информация о типе стирается во время компиляции, что делает невозможным использование обобщённых типов для статических элементов.

[наверх](#java-generics)

## Как обобщённые типы могут быть ограничены
Вы можете ограничить типы с помощью ключевого слова extends:
```java
public <T extends Number> void method(T value) {
    System.out.println(value);
}
```

[наверх](#java-generics)

## Как происходит вывод типа (`type inference`) в `Generics`
Компилятор может автоматически выводить типы параметров, основываясь на контексте вызова метода, например:
```java
public <T> T getFirst(T[] array) {
    return array[0];
}
// Вызов:
String first = getFirst(new String[]{"Hello", "World"});
```

[наверх](#java-generics) 

[назад](../README.md)