# Шаблоны проектирования

[назад](../README.md)

* [Что такое шаблон проектирования (`Design Pattern`)](#что-такое-шаблон-проектирования-design-pattern)
* [Какие категории шаблонов проектирования существуют](#какие-категории-шаблонов-проектирования-существуют)
* [Что такое `Singleton`, плюсы и минусы данного шаблона](#что-такое-singleton-плюсы-и-минусы-данного-шаблона)
* [Потокобезопасный `Singleton`, реализация с использованием `synchronized`, статических классов или `enum`](#потокобезопасный-singleton-реализация-с-использованием-synchronized-статических-классов-или-enum)
* [`Factory Method`, пример реализации фабричного метода, когда использовать](#factory-method-пример-реализации-фабричного-метода-когда-использовать)
* [`Factory Method` и `Abstract Factory`, примеры и различия между шаблонами](#factory-method-и-abstract-factory-примеры-и-различия-между-шаблонами)
* [Шаблон проектирования `Builder`, как он помагает при создании сложных объектов](#шаблон-проектирования-builder-как-он-помагает-при-создании-сложных-объектов)
* [Шаблон проектирования `Prototype`, как клонировать объекты в `Java` с помощью интерфейса `Cloneable`](#шаблон-проектирования-prototype-как-клонировать-объекты-в-java-с-помощью-интерфейса-cloneable)
* [Шаблон проектирования `Adapter`, как он помогает интегрировать несовместимые интерфейсы](#шаблон-проектирования-adapter-как-он-помогает-интегрировать-несовместимые-интерфейсы)
* [Шаблон проектирования `Decorator`, добавление новой функциональности объекту](#шаблон-проектирования-decorator-добавление-новой-функциональности-объекту)
* [Разница между `Adapter` и `Decorator`](#разница-между-adapter-и-decorator)

12. Что такое шаблон проектирования Composite?
Пример использования для организации древовидной структуры.
13. Что такое шаблон проектирования Proxy?
Как Proxy может контролировать доступ к объекту? Различные типы прокси.
14. Как работает шаблон проектирования Facade?
Пример использования для упрощения взаимодействия с комплексными системами.
15. Что такое шаблон проектирования Bridge?
Как Bridge помогает отделить абстракцию от её реализации?
16. Что такое шаблон проектирования Flyweight?
Как он помогает уменьшить количество объектов в приложении? Пример использования.
17. Объясните шаблон проектирования Chain of Responsibility.
Пример использования для передачи запроса по цепочке объектов.
18. Что такое шаблон проектирования Command?
Как Command помогает инкапсулировать команды в объекте?
19. Что такое шаблон проектирования Observer?
Как реализовать паттерн наблюдателя в Java? Пример с использованием java.util.Observable.
20. В чем разница между шаблоном Observer и шаблоном Pub/Sub?
Какова их архитектурная разница и примеры использования?
21. Что такое шаблон проектирования Strategy?
Как Strategy помогает выбирать алгоритмы на этапе выполнения?
22. Что такое шаблон проектирования State?
Как реализовать переключение состояний объекта в зависимости от его состояния?
23. Что такое шаблон проектирования Template Method?
Пример использования для определения скелета алгоритма с возможностью изменения шагов.
24. Что такое шаблон проектирования Memento?
Как реализовать сохранение и восстановление состояния объекта?
25. Объясните шаблон проектирования Mediator.
Как Mediator помогает управлять взаимодействием между объектами?


## Что такое шаблон проектирования (`Design Pattern`)

**Шаблон проектирования** (`Design Pattern`) — это типовое решение для повторяющихся проблем проектирования программного обеспечения. Это описанный способ организации и взаимодействия между объектами или классами для решения общей задачи, возникающей в ходе разработки.

### Цель использования:
Цель шаблонов проектирования заключается в том, чтобы предоставить стандартный и проверенный подход к решению распространенных проблем разработки. Они помогают упростить процесс проектирования сложных систем, повышая гибкость и надежность архитектуры, и обеспечивают возможность адаптации и масштабирования решений.

### Преимущества использования шаблонов проектирования:
1. **Повторное использование решений**: Шаблоны предоставляют готовые и проверенные решения, что позволяет не изобретать велосипед, а использовать проверенные подходы.

2. **Улучшение читаемости и поддержки кода**: Использование шаблонов проектирования делает код более понятным для других разработчиков, поскольку большинство из них знакомы с общими паттернами.

3. **Обеспечение гибкости системы**: Шаблоны проектирования помогают создавать системы, которые легче изменять и масштабировать за счет гибкой архитектуры, позволяющей легко вносить новые изменения.

4. **Снижение сложности разработки**: Шаблоны упрощают процесс разработки, разбивая сложные задачи на более управляемые части и предоставляя готовые структуры для их реализации.

5. **Унификация разработки**: Использование шаблонов помогает стандартизировать подходы к решению типичных задач в проекте, что облегчает взаимодействие между разработчиками и способствует более эффективной командной работе.

6. **Повышение надежности и устойчивости кода**: Шаблоны представляют собой решения, проверенные на практике, что снижает вероятность возникновения ошибок и багов в разработке.

### Заключение:
**Шаблоны проектирования** — это мощный инструмент для решения задач проектирования программного обеспечения, который помогает создавать гибкие, надежные и легко поддерживаемые системы, снижая при этом сложность разработки.

[наверх](#шаблоны-проектирования)


## Какие категории шаблонов проектирования существуют

Шаблоны проектирования классифицируются на три основные категории: 
* порождающие
* структурные
* поведенческие 

Каждая из этих категорий решает свои задачи в процессе проектирования и разработки систем.

### 1. Порождающие (`Creational`) шаблоны проектирования
Порождающие шаблоны сосредоточены на создании объектов. Они абстрагируют или скрывают процесс создания объектов, что позволяет сделать его более гибким и универсальным.

Примеры:

* `Singleton` (Одиночка): Гарантирует, что у класса будет только один экземпляр, и предоставляет к нему глобальную точку доступа.

    * **Пример**: класс конфигурации приложения, доступный во всем проекте в единственном экземпляре.

* `Factory Method` (Фабричный метод): Определяет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять тип создаваемых объектов.

    * **Пример**: создание объектов различных типов документов (PDF, DOCX) через общий интерфейс.

* `Abstract Factory` (Абстрактная фабрика): Предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.

    * **Пример**: создание различных GUI элементов (кнопки, окна) для разных платформ (Windows, MacOS).

* `Builder` (Строитель): Разделяет процесс конструирования сложного объекта на отдельные шаги, что позволяет создавать его пошагово.

    * **Пример**: поэтапное создание сложных объектов, таких как конфигурации автомобилей.

* `Prototype` (Прототип): Позволяет создавать новые объекты путем копирования существующего объекта-прототипа.

    * **Пример**: клонирование объектов, которые дорого создавать заново (например, сложные графические элементы).

### 2. Структурные (`Structural`) шаблоны проектирования
Структурные шаблоны касаются построения отношений между объектами и классами. Они упрощают проектирование системы, делая ее более гибкой и модульной за счет объединения объектов или классов.

Примеры:

* `Adapter` (Адаптер): Позволяет объектам с несовместимыми интерфейсами работать вместе путем обертки одного интерфейса в другой.

    * **Пример**: адаптация одного интерфейса к другому, например, приведение старого `API` к новому.

* `Decorator` (Декоратор): Динамически добавляет новой функциональности объектам без изменения их классов.

    * **Пример**: добавление функций к объекту (например, добавление фильтров к потоку данных).

* `Facade` (Фасад): Предоставляет простой интерфейс к сложной подсистеме, облегчая ее использование.

    * **Пример**: создание интерфейса для взаимодействия с библиотеками или `API` с множеством сложных классов.

* `Composite` (Компоновщик): Позволяет создавать древовидные структуры, где отдельные объекты и группы объектов обрабатываются одинаково.

    * **Пример**: система файлов, где файл и папка имеют одно и то же поведение (открытие, удаление и т.д.).

* `Proxy` (Заместитель): Позволяет контролировать доступ к объекту путем его замены другим объектом (заместителем).

    * **Пример**: прокси-класс для управления доступом к ресурсу или для ленивой инициализации.

* `Bridge` (Мост): Разделяет абстракцию и реализацию, позволяя им изменяться независимо друг от друга.

    * **Пример**: разделение классов интерфейсов с методами рисования и реализаций для различных платформ.

* `Flyweight` (Приспособленец): Оптимизирует работу с большим количеством мелких объектов путем совместного использования общего состояния.

    * **Пример**: использование одного объекта для хранения данных символов в текстовом редакторе.

### 3. Поведенческие (`Behavioral`) шаблоны проектирования
Поведенческие шаблоны проектирования определяют способы взаимодействия объектов и классов. Они помогают организовать алгоритмы и потоки данных между объектами в системе.

Примеры:

* `Observer` (Наблюдатель): Определяет зависимость «один ко многим», при которой изменения состояния одного объекта автоматически уведомляют все связанные объекты.

    * **Пример**: паттерн наблюдателя в интерфейсах пользователя, где изменения в модели данных обновляют отображение.

* `Strategy` (Стратегия): Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

    * **Пример**: выбор различных способов сортировки данных (быстрая сортировка, сортировка пузырьком).

* `Command` (Команда): Инкапсулирует запрос в виде объекта, позволяя передавать его как параметр.

    * **Пример**: реализация системы отмены/повтора действий в текстовых редакторах.

* `State` (Состояние): Позволяет объекту изменять свое поведение в зависимости от состояния, при этом внешне объект выглядит как один и тот же.

    * **Пример**: автомат с напитками, который изменяет свое поведение в зависимости от наличия монет.

* `Chain of Responsibility` (Цепочка обязанностей): Позволяет передавать запрос по цепочке объектов, пока один из них не обработает его.

    * **Пример**: система обработки заявок на кредит, где каждое звено цепи решает, одобрить или отклонить заявку.

* `Mediator` (Посредник): Обеспечивает взаимодействие между объектами, избегая их прямого взаимодействия.

    * **Пример**: чат-комната, в которой посредник (сервер) управляет отправкой сообщений между пользователями.

* `Template Method` (Шаблонный метод): Определяет скелет алгоритма, делегируя реализацию отдельных шагов подклассам.

    * **Пример**: класс с абстрактным методом и реализацией общей логики для его подклассов.

* `Visitor` (Посетитель): Позволяет добавить новые операции к существующим классам без изменения их структуры.

    * **Пример**: добавление новой операции по обработке элементов структуры данных, таких как дерево или список.

### Заключение:
Шаблоны проектирования помогают решать повторяющиеся проблемы проектирования в различных контекстах разработки программного обеспечения. Порождающие шаблоны фокусируются на создании объектов, структурные — на упрощении организации и взаимодействия между классами, а поведенческие — на алгоритмах и управлении взаимодействием объектов.

[наверх](#шаблоны-проектирования)


## Что такое `Singleton`, плюсы и минусы данного шаблона

`Singleton` — это порождающий шаблон проектирования, который гарантирует, что у класса будет только один экземпляр на протяжении всего времени работы программы, и предоставляет глобальную точку доступа к этому экземпляру. `Singleton` используется в тех случаях, когда необходимо контролировать создание объекта и обеспечить его уникальность.

### Реализация `Singleton` в `Java`
Самая простая реализация в однопоточной среде выглядит следующим образом:

```java
public class Singleton {
    // Статическая переменная, хранящая единственный экземпляр класса
    private static Singleton instance;

    // Закрытый конструктор, чтобы предотвратить создание объекта извне
    private Singleton() {
    }

    // Метод для получения экземпляра класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Создание экземпляра при первом вызове
        }
        return instance;
    }
}
```

### Объяснение:
1. Статическая переменная `instance` хранит единственный экземпляр класса.

2. Приватный конструктор не позволяет создавать новые экземпляры класса извне.

3. Метод getInstance возвращает экземпляр класса. Если объект еще не создан (то есть `instance` == `null`), то он создается, а затем возвращается при последующих вызовах метода.

### Плюсы использования `Singleton`:
1. Контроль над количеством экземпляров: Гарантируется, что существует только один экземпляр класса, что полезно для управления ресурсами, такими как подключение к базе данных, логирование и т.д.

2. Глобальная точка доступа: Обеспечивается единый доступ к экземпляру класса из любой части программы.

3. Экономия ресурсов: Экземпляр создается только один раз, что снижает накладные расходы на создание объектов.

### Минусы использования `Singleton`:
1. Нарушение принципа единственной ответственности (`SRP`): Класс занимается как своим поведением, так и контролем за количеством своих экземпляров, что делает его менее гибким.

2. Затруднение тестирования: Тестирование класса с использованием `Singleton` может быть сложным, так как подмена экземпляра для тестов не всегда легко реализуема.

3. Глобальное состояние: `Singleton` создает глобальное состояние, что может привести к трудноотслеживаемым ошибкам и непредсказуемому поведению приложения.

4. Трудности с расширением: Из-за жестко заданного механизма создания одного экземпляра может быть трудно изменить поведение или расширить функционал класса.

В целом, `Singleton` полезен, когда нужно обеспечить наличие только одного экземпляра объекта, но его использование нужно тщательно обдумывать, чтобы избежать проблем с тестированием и глобальными зависимостями.

[наверх](#шаблоны-проектирования)


## Потокобезопасный `Singleton`, реализация с использованием `synchronized`, статических классов или `enum`

Для создания потокобезопасного `Singleton` в `Java` существует несколько подходов. Рассмотрим три распространённые реализации: с использованием ключевого слова `synchronized`, статического внутреннего класса и enum.

### 1. Реализация с использованием `synchronized`
Этот подход защищает доступ к `Singleton` при помощи синхронизации, гарантируя, что два потока не смогут одновременно создать два экземпляра `Singleton`.

```java
public class Singleton {
    private static Singleton instance;

    // Приватный конструктор
    private Singleton() {}

    // Потокобезопасный метод для получения экземпляра Singleton
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
**Объяснение**:

* synchronized гарантирует, что только один поток может войти в метод getInstance() одновременно. Это предотвращает создание нескольких экземпляров Singleton в многопоточной среде.

* Недостаток этого подхода заключается в том, что синхронизация на каждом вызове метода может снижать производительность.

### 2. Реализация с использованием статического внутреннего класса
Этот подход, называемый `Bill Pugh Singleton`, считается одним из лучших, так как он лениво создает экземпляр Singleton и при этом не требует синхронизации.

```java
public class Singleton {
    private Singleton() {}

    // Внутренний статический класс, содержащий единственный экземпляр Singleton
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // Метод для получения экземпляра Singleton
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**Объяснение**:

* Экземпляр `INSTANCE` создается при первом вызове метода `getInstance()`, но не раньше.

* В этом подходе используется механизм инициализации классов в `Java`: класс `SingletonHolder` не будет загружен до тех пор, пока не вызван метод `getInstance()`, что делает реализацию ленивой.

* Этот подход не требует использования синхронизации, поскольку инициализация классов в `Java` автоматически потокобезопасна.

### 3. Реализация с использованием `enum`
Этот метод создания `Singleton` появился в `Java` с версии 1.5, когда был введён `enum`. Он является наиболее простым и надёжным способом создания `Singleton`.

```java
public enum Singleton {
    INSTANCE;

    // Можно добавить методы
    public void doSomething() {
        // Реализация
    }
}
```

**Объяснение**:

* Использование `enum` автоматически гарантирует, что создается только один экземпляр. Это связано с особенностями работы `enum` в `Java`, где каждый элемент перечисления создается только один раз.

* Этот подход защищён от проблем, связанных с сериализацией и рефлексией, которые могут возникать в других реализациях `Singleton`.

* Недостатком может быть то, что это менее гибкий подход, так как enum не может наследовать другие классы, хотя это редко требуется для `Singleton`.

### Плюсы и минусы различных подходов

### === Реализация с `synchronized` ===



**Плюсы**:

* Простая реализация.
* Легко читается и понимается.

**Минусы**:

* Каждый вызов метода синхронизирован, что может ухудшать производительность, особенно при частом вызове метода.

### === Реализация состатическим внутренним классом ===

**Плюсы**:

* Высокая производительность, так как нет необходимости в синхронизации.
* Ленивая инициализация: экземпляр создается только при первом вызове.

**Минусы**:

* Более сложная для понимания реализация, чем с использованием synchronized.

### === Реализация с использованием `enum` ===

**Плюсы**:

* Простая и краткая реализация.
* Потокобезопасная.
* Защищена от сериализации и рефлексии.

**Минусы**:

* Ограниченная гибкость, так как enum не может наследовать другие классы.
* Каждый подход имеет свои плюсы и минусы, и выбор между ними зависит от специфических требований вашего проекта.

[наверх](#шаблоны-проектирования)


## `Factory Method`, пример реализации фабричного метода, когда использовать

`Factory Method` — это порождающий шаблон проектирования, который предоставляет интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. Этот шаблон позволяет делегировать создание объектов подклассам, вместо того чтобы полагаться на конкретные классы, тем самым снижая зависимость от конкретных реализаций.

### Когда использовать `Factory Method`
* Когда код не должен зависеть от конкретных классов создаваемых объектов.
* Когда в процессе разработки требуется подменять или изменять классы, которые создают объекты.
* Когда нужно предоставить возможность расширения для добавления новых типов объектов без изменения существующего кода (принцип открытости/закрытости).
* Когда создание объекта требует сложной логики, и её необходимо вынести в отдельный метод или класс.

### Пример реализации `Factory Method` в `Java`
Представим, что у нас есть интерфейс для различных видов сообщений, и мы хотим использовать фабричный метод для создания различных типов сообщений (например, `TextMessage`, `EmailMessage`).

### 1. Определяем интерфейс или абстрактный класс, который будет содержать фабричный метод
```java
abstract class Message {
    public abstract String getContent();

    // Общие методы для всех типов сообщений
    public void addDefaultHeaders() {
        System.out.println("Добавлены заголовки сообщения");
    }

    public void encrypt() {
        System.out.println("Сообщение зашифровано");
    }
}

abstract class MessageCreator {
    // Фабричный метод
    public abstract Message createMessage();

    // Шаблонный метод, который использует фабричный метод
    public Message getMessage() {
        Message msg = createMessage();
        msg.addDefaultHeaders();
        msg.encrypt();
        return msg;
    }
}
```

### 2. Создаем конкретные классы сообщений
```java
class TextMessage extends Message {
    @Override
    public String getContent() {
        return "Это текстовое сообщение";
    }
}

class EmailMessage extends Message {
    @Override
    public String getContent() {
        return "Это электронное сообщение";
    }
}
```

### 3. Создаем конкретные фабрики для различных типов сообщений
```java
class TextMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new TextMessage();
    }
}

class EmailMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new EmailMessage();
    }
}
```
### 4. Использование `Factory Method`
```java
public class FactoryMethodDemo {
    public static void main(String[] args) {
        // Создаем текстовое сообщение
        MessageCreator creator = new TextMessageCreator();
        Message message = creator.getMessage();
        System.out.println(message.getContent());

        // Создаем электронное сообщение
        creator = new EmailMessageCreator();
        message = creator.getMessage();
        System.out.println(message.getContent());
    }
}
```

### Объяснение
* Абстрактный класс MessageCreator определяет фабричный метод createMessage, который должны реализовать подклассы. Этот метод отвечает за создание объектов типа Message.

* Конкретные подклассы (TextMessageCreator, EmailMessageCreator) реализуют этот метод, создавая конкретные типы сообщений (TextMessage, EmailMessage).

* Клиентский код вызывает метод getMessage(), который использует фабричный метод для создания сообщения, а затем выполняет с ним общие действия (например, добавляет заголовки, шифрует).

### Когда использовать `Factory Method`
1. Когда создание объекта может варьироваться в зависимости от ситуации: Если вы хотите делегировать создание объекта подклассам, которые решат, какой тип объекта будет создан.

2. Для улучшения расширяемости кода: Можно легко добавлять новые типы объектов, не меняя существующий код, тем самым соблюдая принцип открытости/закрытости (Open/Closed Principle).

3. Когда нужно скрыть детали создания объекта: Клиентский код работает с интерфейсом или абстрактным классом и не заботится о том, как именно создается объект.

`Factory Method` удобен для ситуаций, когда вам нужно подменять реализацию классов без изменения клиентского кода, или когда вы хотите, чтобы классы, создающие объекты, имели возможность влиять на процесс создания объектов.

[наверх](#шаблоны-проектирования)


## `Factory Method` и `Abstract Factory`, примеры и различия между шаблонами

`Factory Method` и `Abstract Factory` — это порождающие шаблоны проектирования, используемые для создания объектов. Оба они помогают абстрагировать процесс создания объектов, но различаются по своей структуре и применению.

### Разница между `Factory Method` и `Abstract Factory`:
1. Factory Method (Фабричный метод):

    * Определение: Это шаблон, который предоставляет интерфейс для создания объектов, но позволяет подклассам изменить тип создаваемого объекта.

    * Фокус: Создание одного объекта.

    * Применение: Используется, когда нужно делегировать создание объектов подклассам.

    * Реализация: Каждый подкласс реализует собственный метод фабрики, который возвращает объект.

2. Abstract Factory (Абстрактная фабрика):

    * Определение: Это шаблон, который предоставляет интерфейс для создания семейств взаимосвязанных или зависимых объектов, не указывая их конкретные классы.

    * Фокус: Создание целого семейства объектов.

    * Применение: Используется, когда нужно создавать несколько взаимосвязанных объектов, и важно, чтобы они использовали одни и те же семейства объектов.
    
    * Реализация: Определяется набор фабрик для создания объектов различных типов (например, интерфейсы для создания объектов разных видов), а конкретные фабрики реализуют интерфейс для создания семейств объектов.

### Пример реализации `Factory Method` в `Java`
В этом примере мы создаем разные виды сообщений (текстовое и электронное) с использованием фабричного метода.

```java
abstract class Message {
    public abstract String getContent();
}

class TextMessage extends Message {
    @Override
    public String getContent() {
        return "Это текстовое сообщение";
    }
}

class EmailMessage extends Message {
    @Override
    public String getContent() {
        return "Это электронное сообщение";
    }
}

abstract class MessageCreator {
    // Фабричный метод
    public abstract Message createMessage();
}

class TextMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new TextMessage();
    }
}

class EmailMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new EmailMessage();
    }
}

public class FactoryMethodExample {
    public static void main(String[] args) {
        MessageCreator creator = new TextMessageCreator();
        Message message = creator.createMessage();
        System.out.println(message.getContent());

        creator = new EmailMessageCreator();
        message = creator.createMessage();
        System.out.println(message.getContent());
    }
}
```

### Пример реализации `Abstract Factory` в `Java`
Теперь рассмотрим пример `Abstract Factory`, где создаются различные типы кнопок и чекбоксов в зависимости от операционной системы.

```java
// Продукты
interface Button {
    void paint();
}

class WindowsButton implements Button {
    public void paint() {
        System.out.println("Рисуем кнопку Windows");
    }
}

class MacOSButton implements Button {
    public void paint() {
        System.out.println("Рисуем кнопку MacOS");
    }
}

interface Checkbox {
    void paint();
}

class WindowsCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Рисуем чекбокс Windows");
    }
}

class MacOSCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Рисуем чекбокс MacOS");
    }
}

// Абстрактная фабрика
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Конкретные фабрики
class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

class MacOSFactory implements GUIFactory {
    public Button createButton() {
        return new MacOSButton();
    }

    public Checkbox createCheckbox() {
        return new MacOSCheckbox();
    }
}

// Клиент
public class AbstractFactoryExample {
    private static Application configureApplication() {
        Application app;
        GUIFactory factory;
        String osName = System.getProperty("os.name").toLowerCase();

        if (osName.contains("mac")) {
            factory = new MacOSFactory();
        } else {
            factory = new WindowsFactory();
        }

        app = new Application(factory);
        return app;
    }

    public static void main(String[] args) {
        Application app = configureApplication();
        app.paint();
    }
}

class Application {
    private Button button;
    private Checkbox checkbox;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }

    public void paint() {
        button.paint();
        checkbox.paint();
    }
}
```

### Основные различия между `Factory Method` и `Abstract Factory`

<table border="1" cellpadding="10" cellspacing="0">
    <thead>
        <tr>
            <th>Характеристика</th>
            <th>Factory Method</th>
            <th>Abstract Factory</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Цель</td>
            <td>Определяет интерфейс для создания одного объекта.</td>
            <td>Определяет интерфейс для создания семейств объектов.</td>
        </tr>
        <tr>
            <td>Создание объектов</td>
            <td>Создаёт один объект.</td>
            <td>Создаёт семейства взаимосвязанных объектов.</td>
        </tr>
        <tr>
            <td>Использование подклассов</td>
            <td>Подклассы определяют, какой объект будет создан.</td>
            <td>Подклассы создают конкретные продукты из семейства.</td>
        </tr>
        <tr>
            <td>Пример использования</td>
            <td>Создание конкретных сообщений, таких как текстовое или электронное сообщение.</td>
            <td>Создание кнопок и чекбоксов для разных платформ (Windows, MacOS).</td>
        </tr>
    </tbody>
</table>

### Когда использовать какой шаблон?
* `Factory Method` полезен, когда требуется создать один объект, но его конкретный тип может меняться в зависимости от контекста или условий, например создание сообщений, где разные классы сообщений реализуют общий интерфейс.

* `Abstract Factory` используется, когда нужно создавать целые семейства взаимосвязанных объектов, например, интерфейсы для разных платформ (кнопки, окна, чекбоксы для Windows и MacOS).

В целом, `Factory Method` — это более простой шаблон, который решает задачу создания одного объекта, тогда как `Abstract Factory` — более сложный и предназначен для создания семейства объектов, которые должны работать вместе.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Builder`, как он помагает при создании сложных объектов

`Builder` — это порождающий шаблон проектирования, который используется для поэтапного создания сложных объектов. Вместо того чтобы создавать объект с помощью одного конструктора с множеством параметров, `Builder` позволяет создавать объект по шагам, последовательно настраивая его свойства.

### Задачи, которые решает шаблон `Builder`

1. Упрощает создание сложных объектов: Когда объект имеет много параметров, обычный подход с использованием конструктора может стать неудобным и трудно читаемым. Особенно, если объект имеет необязательные параметры.

2. Избегает "телескопических конструкторов": Проблема возникает, когда объект имеет множество параметров, и для каждого их набора нужно создавать разные конструкторы (например, от 2 до 10 параметров). Builder помогает избежать создания множества перегруженных конструкторов.

3. Удобное создание объектов с необязательными параметрами: Builder позволяет задавать только те параметры, которые действительно нужны, и избегать использования конструктора с множеством необязательных аргументов.

4. Повышает читаемость кода: Создание объекта с помощью Builder'а делает код более читабельным и понятным за счет явного указания свойств объекта.

### Пример использования шаблона `Builder` в `Java`
Предположим, у нас есть класс `Car`, который может иметь множество различных параметров, таких как модель, цвет, двигатель, год выпуска и так далее.

### 1. Без использования `Builder` (с "телескопическим" конструктором):
```java
class Car {
    private String model;
    private String color;
    private String engine;
    private int year;
    
    public Car(String model, String color, String engine, int year) {
        this.model = model;
        this.color = color;
        this.engine = engine;
        this.year = year;
    }

    // Методы доступа и другие методы...
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car("Toyota", "Red", "V8", 2023);
        // Если у машины 10 параметров, то этот подход становится неудобным
    }
}
```
### 2. Использование шаблона `Builder`:
```java
class Car {
    private String model;
    private String color;
    private String engine;
    private int year;

    // Приватный конструктор, чтобы нельзя было напрямую создавать объекты Car
    private Car(CarBuilder builder) {
        this.model = builder.model;
        this.color = builder.color;
        this.engine = builder.engine;
        this.year = builder.year;
    }

    // Статический класс Builder
    public static class CarBuilder {
        private String model;
        private String color;
        private String engine;
        private int year;

        // Параметры, которые могут быть обязательными
        public CarBuilder(String model) {
            this.model = model;
        }

        // Необязательные параметры задаются методами Builder
        public CarBuilder setColor(String color) {
            this.color = color;
            return this;
        }

        public CarBuilder setEngine(String engine) {
            this.engine = engine;
            return this;
        }

        public CarBuilder setYear(int year) {
            this.year = year;
            return this;
        }

        // Метод для создания объекта Car
        public Car build() {
            return new Car(this);
        }
    }

    @Override
    public String toString() {
        return "Car [model=" + model + ", color=" + color + ", engine=" + engine + ", year=" + year + "]";
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car.CarBuilder("Toyota")
                        .setColor("Red")
                        .setEngine("V8")
                        .setYear(2023)
                        .build();

        System.out.println(car);
    }
}
```

### Объяснение:
1. Конструктор Car — это приватный конструктор, который принимает объект CarBuilder. Это необходимо для того, чтобы объект Car нельзя было создать напрямую.

2. CarBuilder — это статический класс, который предоставляет методы для задания параметров объекта. Каждый метод setColor, setEngine и т.д. возвращает сам объект Builder, что позволяет вызывать методы цепочкой (chaining).

3. Метод build — это метод, который завершает процесс построения и возвращает готовый объект Car.

4. Преимущество — мы можем задать только те параметры, которые действительно необходимы, без необходимости указывать все параметры при создании объекта.

### Преимущества использования `Builder`:
1. Гибкость в создании объектов: Позволяет легко создавать объекты с разными комбинациями параметров, в том числе с необязательными параметрами.

2. Читаемость: Код, использующий Builder, легко читается и понятен за счёт именованных методов (например, setColor), а не из-за длинных списков аргументов в конструкторе.

3. Поддержка неизменяемых объектов: После создания объекта с помощью Builder его параметры могут быть сделаны неизменяемыми, что повышает безопасность данных.

4. Избежание перегрузки конструкторов: В отличие от использования нескольких конструкторов, Builder позволяет иметь один метод для создания объектов с любыми комбинациями параметров.

### Когда использовать `Builder`?
* Когда объект имеет много параметров, особенно если некоторые из них необязательны.

* Когда нужно создать объект поэтапно или с возможностью дальнейшего конфигурирования.

* Когда создание объекта требует много шагов или сложной логики (например, построение графических интерфейсов или конфигурация подключения).

* Когда конструктор с большим количеством параметров делает код трудно поддерживаемым и читаемым.

`Builder` особенно полезен в ситуациях, когда объект содержит много параметров и некоторые из них необязательны.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Prototype`, как клонировать объекты в `Java` с помощью интерфейса `Cloneable`

Шаблон проектирования `Prototype` — это порождающий шаблон, который используется, когда необходимо создать копии объектов, избегая затрат на создание новых экземпляров с использованием конструктора. Вместо того чтобы создавать объект с нуля, можно клонировать существующий объект и затем изменить его, если нужно. Этот подход особенно полезен, когда создание объектов является дорогостоящим или сложным процессом, или когда необходимо создать множество объектов, которые похожи, но с небольшими различиями.

### Когда следует использовать шаблон `Prototype`:
1. Когда создание объекта дорого: Если создание нового объекта требует значительных затрат ресурсов (например, требует много времени или сложных вычислений), клонирование существующего объекта может быть гораздо более эффективным.

2. Когда объекты имеют много возможных конфигураций: Вместо того чтобы создавать объекты с различными конфигурациями через конструкторы, можно создать базовый объект и клонировать его, изменяя только необходимые параметры.

3. Когда необходимо избежать создания иерархии классов для создания объектов: С помощью `Prototype` можно избежать создания множества подклассов для различных конфигураций объектов, что позволяет поддерживать код более простым и гибким.

4. Когда нужно дублировать объекты с минимальными изменениями: `Prototype` позволяет быстро создавать новые экземпляры объекта, сохраняя его текущее состояние.

### Как клонировать объекты в `Java` с помощью интерфейса `Cloneable`?
В `Java` для реализации шаблона `Prototype` часто используется интерфейс `Cloneable`. Этот интерфейс указывает, что класс поддерживает клонирование, но не предоставляет методов. Клонирование реализуется путем переопределения метода `clone()` из класса `Object`.

### Пример использования `Cloneable` в `Java`:
1. Определяем класс с поддержкой клонирования:
```java
class Car implements Cloneable {
    private String model;
    private String color;

    public Car(String model, String color) {
        this.model = model;
        this.color = color;
    }

    // Геттеры
    public String getModel() {
        return model;
    }

    public String getColor() {
        return color;
    }

    // Переопределение метода clone для поддержки клонирования
    @Override
    public Car clone() {
        try {
            return (Car) super.clone();  // Вызов метода clone() суперкласса Object
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Клонирование не поддерживается", e);
        }
    }

    @Override
    public String toString() {
        return "Car [model=" + model + ", color=" + color + "]";
    }
}
```
2. Клонирование объекта:
```java
public class Main {
    public static void main(String[] args) {
        // Создаем оригинальный объект Car
        Car car1 = new Car("Toyota", "Red");

        // Клонируем объект car1 в car2
        Car car2 = car1.clone();

        // Выводим оба объекта
        System.out.println("Оригинал: " + car1);
        System.out.println("Клон: " + car2);

        // Модификация клонированного объекта
        System.out.println("Изменение цвета клона...");
        car2 = new Car(car2.getModel(), "Blue");

        System.out.println("Оригинал после изменения клона: " + car1);
        System.out.println("Измененный клон: " + car2);
    }
}
```

### Объяснение:
1. Интерфейс Cloneable: Указывает, что класс поддерживает клонирование. Если класс реализует этот интерфейс, и вы вызываете метод clone() на его объекте, то метод должен вернуть копию этого объекта. Если Cloneable не реализован, вызов метода clone() выбросит исключение CloneNotSupportedException.

2. Переопределение метода clone(): Метод clone() должен быть явно переопределён в классе, так как его реализация в классе Object не подходит для всех случаев. В нашем примере Car переопределяет метод clone() и вызывает super.clone(), чтобы создать поверхностную копию объекта.

3. Клонирование объекта: После клонирования объекта car1, мы получаем новый объект car2, который является копией car1. Мы можем модифицировать клонированный объект, не влияя на оригинал.

### Поверхностное и глубокое клонирование:
* Поверхностное клонирование (shallow copy): Это копирование только самого объекта, но не его вложенных объектов. Если объект содержит ссылки на другие объекты, то ссылки будут скопированы, а не сами объекты. В Java, вызов super.clone() из класса Object по умолчанию делает поверхностную копию.

* Глубокое клонирование (deep copy): Это копирование не только самого объекта, но и всех объектов, на которые он ссылается. Для глубокого клонирования требуется самостоятельно клонировать все вложенные объекты.

### Пример поверхностного клонирования:
Если `Car` содержит ссылку на другой объект, например, на объект `Engine`, поверхностное клонирование не создаст новый объект `Engine`, а просто скопирует ссылку на него.

```java
class Engine {
    private String type;

    public Engine(String type) {
        this.type = type;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return "Engine[type=" + type + "]";
    }
}

class Car implements Cloneable {
    private String model;
    private String color;
    private Engine engine;

    public Car(String model, String color, Engine engine) {
        this.model = model;
        this.color = color;
        this.engine = engine;
    }

    @Override
    public Car clone() {
        try {
            return (Car) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Клонирование не поддерживается", e);
        }
    }

    @Override
    public String toString() {
        return "Car[model=" + model + ", color=" + color + ", engine=" + engine + "]";
    }
}
```

### Итог:
* Когда использовать `Prototype`:

    * Когда необходимо создать множество похожих объектов.
    * Когда создание объектов через конструктор является дорогостоящим или сложным.
    * Когда нужно создавать объекты с возможностью их легкой модификации после клонирования.

* `Cloneable` помогает легко реализовать клонирование объектов в `Java`, что делает процесс создания копий более простым и эффективным, особенно для шаблона проектирования `Prototype`.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Adapter`, как он помогает интегрировать несовместимые интерфейсы

`Adapter` — это структурный шаблон проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Этот шаблон выступает в роли посредника, преобразующего интерфейс одного класса в интерфейс, ожидаемый клиентом. Таким образом, `Adapter` решает проблему интеграции и совместимости различных классов, которые изначально не могут взаимодействовать напрямую.

### Задачи, решаемые шаблоном `Adapter`:
1. Интеграция старого и нового кода: Когда вам нужно использовать существующий класс с новым интерфейсом, но изменить код класса невозможно (например, класс находится в сторонней библиотеке или код слишком сложен для изменения).

2. Унификация интерфейсов: Когда разные классы выполняют похожие функции, но имеют разные интерфейсы, Adapter может предоставить единый интерфейс для использования их функциональности.

3. Повторное использование кода: Adapter позволяет использовать уже существующие классы и их методы в новых контекстах, без необходимости изменять их внутреннюю реализацию.

### Как `Adapter` помогает интегрировать несовместимые интерфейсы?
`Adapter` создает прослойку между клиентом (который ожидает один интерфейс) и сервисом (который реализует другой интерфейс). Он преобразует вызовы методов клиента в формат, понятный сервису, что позволяет обоим компонентам работать вместе.

#### Пример сценария:
Предположим, у вас есть интерфейс Target, который ваш клиент использует для работы с объектами, но у вас есть существующий класс Adaptee, который имеет несовместимый интерфейс. Вы не можете изменить Adaptee, но вам нужно, чтобы клиент мог его использовать. В этом случае Adapter преобразует вызовы методов клиента к интерфейсу Adaptee.

### Пример реализации `Adapter` в `Java`
Предположим, у нас есть система для работы с круглыми отверстиями и круглыми штырями. Однако, вы хотите вставить квадратный штырь в круглое отверстие. В таком случае можно использовать `Adapter`, чтобы адаптировать квадратный штырь к интерфейсу круглого отверстия.

#### 1. Интерфейс `Target` (ожидаемый клиентом):
```java
class RoundHole {
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    public boolean fits(RoundPeg peg) {
        return this.getRadius() >= peg.getRadius();
    }
}
```
#### 2. Класс `Adaptee` с несовместимым интерфейсом:
```java
class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }
}
```
#### 3. Адаптер для преобразования интерфейсов:
```java
class SquarePegAdapter extends RoundPeg {
    private SquarePeg squarePeg;

    public SquarePegAdapter(SquarePeg peg) {
        this.squarePeg = peg;
    }

    @Override
    public double getRadius() {
        // Преобразуем размер квадрата в радиус круга, который может его окружить
        return (squarePeg.getWidth() * Math.sqrt(2)) / 2;
    }
}
```
#### 4. Использование `Adapter`:
```java
public class AdapterPatternDemo {
    public static void main(String[] args) {
        // Круглое отверстие и круглый штырь совместимы
        RoundHole hole = new RoundHole(5);
        RoundPeg roundPeg = new RoundPeg(5);
        System.out.println(hole.fits(roundPeg)); // true

        // Квадратный штырь не совместим с круглым отверстием
        SquarePeg smallSquarePeg = new SquarePeg(5);
        SquarePeg largeSquarePeg = new SquarePeg(10);
        
        // Используем адаптер для квадратного штыря
        SquarePegAdapter smallSquarePegAdapter = new SquarePegAdapter(smallSquarePeg);
        SquarePegAdapter largeSquarePegAdapter = new SquarePegAdapter(largeSquarePeg);

        // Проверяем, подходят ли квадратные штыри для круглого отверстия через адаптер
        System.out.println(hole.fits(smallSquarePegAdapter)); // true
        System.out.println(hole.fits(largeSquarePegAdapter)); // false
    }
}
```
### Объяснение:
1. Клиент (RoundHole) работает с круглыми штырями через метод fits(), ожидая объект, который реализует интерфейс RoundPeg.

2. Adaptee (SquarePeg) представляет класс с несовместимым интерфейсом — квадратный штырь, который не может напрямую взаимодействовать с RoundHole.

3. Adapter (SquarePegAdapter) адаптирует интерфейс SquarePeg под ожидаемый интерфейс RoundPeg. Он "оборачивает" объект SquarePeg и переопределяет метод getRadius() так, чтобы вычислить подходящий радиус для квадратного штыря.

### Преимущества использования `Adapter`:
1. Инкапсуляция различий: Адаптер изолирует клиентский код от изменений в сторонних библиотеках или классах с несовместимыми интерфейсами.

2. Повторное использование: Вместо того чтобы переписывать или дублировать код, можно использовать уже существующие классы, просто адаптировав их интерфейсы.

3. Гибкость: Можно легко адаптировать различные классы для работы с нужным интерфейсом, не меняя существующую логику клиентского кода.

### Когда использовать `Adapter`:
1. Когда необходимо интегрировать класс с интерфейсом, несовместимым с используемым в проекте.

2. Когда нужно использовать стороннюю библиотеку или класс без изменения его исходного кода.

3. Когда разные классы выполняют похожие задачи, но имеют различные интерфейсы, и нужно унифицировать их работу в рамках одного клиентского кода.

Шаблон `Adapter` помогает решить проблему несовместимости интерфейсов и делает возможным повторное использование существующего кода без его изменения.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Decorator`, добавление новой функциональности объекту

`Decorator` (Декоратор) — это структурный шаблон проектирования, который позволяет динамически добавлять новые функциональности объекту, не изменяя его исходный код и не прибегая к наследованию. Это достигается путем "обёртывания" исходного объекта в новые классы, которые добавляют функциональность.

`Decorator` предоставляет гибкий способ расширения возможностей объекта на этапе выполнения программы, не создавая подклассы для каждой возможной комбинации новых функций.

### Когда использовать `Decorator`?
1. Когда нужно добавлять функциональность объектам динамически, во время выполнения программы.
2. Когда нельзя или нецелесообразно изменять исходный класс объекта, например, если это сторонняя библиотека или класс закрыт для модификации.
3. Когда нужно избежать создания большого числа подклассов для каждого сочетания дополнительных функций (заменяя их динамическим добавлением через декораторы).

### Пример использования `Decorator` в `Java`
Предположим, у нас есть интерфейс `DataSource`, который предоставляет методы для чтения и записи данных, и мы хотим добавлять дополнительную функциональность, такую как шифрование данных перед записью или сжатие данных перед сохранением.

#### 1. Базовый интерфейс `DataSource`:
```java
interface DataSource {
    void writeData(String data);
    String readData();
}
```
#### 2. Базовый класс `FileDataSource`, который реализует интерфейс:
```java
class FileDataSource implements DataSource {
    private String filename;

    public FileDataSource(String filename) {
        this.filename = filename;
    }

    @Override
    public void writeData(String data) {
        System.out.println("Запись данных в файл: " + filename);
        // Логика записи данных в файл
    }

    @Override
    public String readData() {
        System.out.println("Чтение данных из файла: " + filename);
        // Логика чтения данных из файла
        return "Данные из файла";
    }
}
```
#### 3. Абстрактный класс `DataSourceDecorator`:
Этот класс реализует интерфейс `DataSource` и содержит ссылку на объект `DataSource`, который будет декорирован.

```java
class DataSourceDecorator implements DataSource {
    protected DataSource wrappee;

    public DataSourceDecorator(DataSource source) {
        this.wrappee = source;
    }

    @Override
    public void writeData(String data) {
        wrappee.writeData(data);
    }

    @Override
    public String readData() {
        return wrappee.readData();
    }
}
```

#### 4. Декоратор `EncryptionDecorator`, который добавляет шифрование данных:
```java
class EncryptionDecorator extends DataSourceDecorator {

    public EncryptionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void writeData(String data) {
        String encryptedData = encrypt(data);
        super.writeData(encryptedData);
    }

    @Override
    public String readData() {
        String data = super.readData();
        return decrypt(data);
    }

    private String encrypt(String data) {
        // Простая логика шифрования (для примера)
        return "encrypted_" + data;
    }

    private String decrypt(String data) {
        // Простая логика дешифрования (для примера)
        return data.replace("encrypted_", "");
    }
}
```

#### 5. Декоратор `CompressionDecorator`, который добавляет сжатие данных:
```java
class CompressionDecorator extends DataSourceDecorator {

    public CompressionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void writeData(String data) {
        String compressedData = compress(data);
        super.writeData(compressedData);
    }

    @Override
    public String readData() {
        String data = super.readData();
        return decompress(data);
    }

    private String compress(String data) {
        // Простая логика сжатия (для примера)
        return "compressed_" + data;
    }

    private String decompress(String data) {
        // Простая логика декомпрессии (для примера)
        return data.replace("compressed_", "");
    }
}
```

#### 6. Использование декораторов:
```java
public class DecoratorDemo {
    public static void main(String[] args) {
        DataSource fileDataSource = new FileDataSource("data.txt");

        // Оборачиваем FileDataSource в декораторы
        DataSource encryptedDataSource = new EncryptionDecorator(fileDataSource);
        DataSource compressedAndEncryptedDataSource = new CompressionDecorator(encryptedDataSource);

        // Запись данных с сжатием и шифрованием
        compressedAndEncryptedDataSource.writeData("Некоторые данные");

        // Чтение данных с дешифрованием и декомпрессией
        String result = compressedAndEncryptedDataSource.readData();
        System.out.println("Чтение данных: " + result);
    }
}
```
### Объяснение:
1. FileDataSource — это базовый объект, который выполняет стандартные операции чтения и записи в файл.

2. DataSourceDecorator — это абстрактный класс, который содержит ссылку на объект DataSource и передает вызовы базового метода.

3. EncryptionDecorator добавляет шифрование перед записью и расшифровку при чтении.

4. CompressionDecorator добавляет сжатие перед записью и разжатие при чтении.

5. Использование декораторов позволяет динамически добавлять шифрование, сжатие или другие функции к объектам, не изменяя исходные классы.

### Преимущества использования `Decorator`:
1. Гибкость: Позволяет добавлять функциональность объекту на этапе выполнения программы.

2. Простота в поддержке: Легко добавлять новые декораторы для расширения функциональности без изменения исходных классов.

3. Комбинирование поведения: Декораторы можно комбинировать, добавляя несколько уровней функциональности.

### Когда использовать `Decorator`:
* Когда нужно динамически расширить функциональность объекта, не создавая подклассов.

* Когда нужно добавлять разные функциональности объекту без изменения его исходного кода.

* Когда требуется возможность комбинирования нескольких функций.

`Decorator` — это удобный способ динамически изменять поведение объектов, избегая жесткого наследования и улучшая гибкость системы.

[наверх](#шаблоны-проектирования)


## Разница между `Adapter` и `Decorator`

`Adapter` и `Decorator` — это структурные шаблоны проектирования, но они служат разным целям и решают разные задачи. Рассмотрим основные отличия и цели каждого из них.

### Основные различия между `Adapter` и `Decorator`:
<table border="1" cellpadding="10" cellspacing="0">
    <thead>
        <tr>
            <th>Характеристика</th>
            <th>Adapter</th>
            <th>Decorator</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Цель</td>
            <td>Преобразование интерфейса одного класса в другой, чтобы классы с несовместимыми интерфейсами могли работать вместе.</td>
            <td>Добавление новой функциональности объекту без изменения его интерфейса.</td>
        </tr>
        <tr>
            <td>Когда использовать</td>
            <td>Когда необходимо интегрировать класс с несовместимым интерфейсом, чтобы он мог работать с существующим кодом.</td>
            <td>Когда необходимо расширить или модифицировать поведение объекта, не изменяя его исходный класс.</td>
        </tr>
        <tr>
            <td>Фокус</td>
            <td>Изменение интерфейса объекта.</td>
            <td>Расширение поведения объекта.</td>
        </tr>
        <tr>
            <td>Применение</td>
            <td>Используется, когда необходимо интегрировать сторонние библиотеки или объекты с несовместимыми интерфейсами.</td>
            <td>Используется, когда нужно добавить динамическую функциональность объектам.</td>
        </tr>
        <tr>
            <td>Влияние на структуру</td>
            <td>Adapter изменяет интерфейс объекта, чтобы клиент мог его использовать.</td>
            <td>Decorator сохраняет интерфейс объекта, добавляя дополнительные функции.</td>
        </tr>
        <tr>
            <td>Пример</td>
            <td>Адаптация квадратного штыря для круглого отверстия.</td>
            <td>Добавление сжатия или шифрования данных для объекта.</td>
        </tr>
    </tbody>
</table>

### Детализированное сравнение:
1. Цели шаблонов:
    * Adapter преобразует интерфейс существующего объекта таким образом, чтобы он стал совместим с другим кодом, который ожидает другой интерфейс. Adapter действует как посредник, скрывающий несовместимости интерфейсов.

    * Decorator расширяет поведение существующего объекта, добавляя новые функции, не изменяя его интерфейс. Он позволяет динамически "оборачивать" объекты дополнительными функциями.

2. Когда использовать:

    * Adapter полезен, когда необходимо сделать два несовместимых интерфейса совместимыми. Например, вам может потребоваться адаптировать сторонний класс к интерфейсу вашей системы, не меняя исходный класс.

    * Decorator полезен, когда вам нужно динамически расширить функциональность объектов, не изменяя их исходную структуру или код. Например, когда необходимо добавлять функции шифрования или сжатия к объекту данных, не меняя сам объект.

3. Фокус:

    * Adapter фокусируется на изменении интерфейса объекта. Он не добавляет функциональность объекту, а лишь делает его совместимым с другим интерфейсом.

    * Decorator фокусируется на расширении или изменении поведения объекта. Он не изменяет интерфейс, а добавляет новые функции, при этом интерфейс остается прежним.

4. Влияние на интерфейс:

    * Adapter изменяет интерфейс объекта, чтобы его можно было использовать в другом контексте.

    * Decorator не изменяет интерфейс объекта, а лишь добавляет новое поведение или функциональность, сохраняя существующий интерфейс.

5. Пример:

    * Adapter: Если у вас есть круглая дыра (класс RoundHole) и квадратный штырь (класс SquarePeg), которые несовместимы из-за разных интерфейсов, Adapter (например, SquarePegAdapter) преобразует квадратный штырь в подходящий для круглого отверстия.

    * Decorator: Если у вас есть объект DataSource, который сохраняет данные, и вы хотите добавить к нему возможность шифрования или сжатия данных, вы можете использовать EncryptionDecorator или CompressionDecorator для расширения функциональности объекта, сохраняя тот же интерфейс DataSource.

### Итог:
* Adapter предназначен для преобразования интерфейса, чтобы сделать несовместимые классы совместимыми. Он действует как "мост" между двумя несовместимыми интерфейсами.

* Decorator предназначен для динамического добавления новых функций объектам без изменения их интерфейса. Он расширяет поведение объекта, сохраняя его существующий интерфейс.

Оба шаблона используются для повышения гибкости и повторного использования кода, но их применение зависит от того, нужно ли вам адаптировать интерфейсы или расширять функциональность объектов.

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


##

[наверх](#шаблоны-проектирования)


[назад](../README.md)