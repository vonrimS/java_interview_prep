# Шаблоны проектирования

[назад](../README.md)

* [Что такое шаблон проектирования (`Design Pattern`)](#что-такое-шаблон-проектирования-design-pattern)
* [Какие категории шаблонов проектирования существуют](#какие-категории-шаблонов-проектирования-существуют)
* [Что такое `Singleton`, плюсы и минусы данного шаблона](#что-такое-singleton-плюсы-и-минусы-данного-шаблона)
* [Потокобезопасный `Singleton`, реализация с использованием `synchronized`, статических классов или `enum`](#потокобезопасный-singleton-реализация-с-использованием-synchronized-статических-классов-или-enum)
* [`Factory Method`, пример реализации фабричного метода, когда использовать](#factory-method-пример-реализации-фабричного-метода-когда-использовать)
* [`Factory Method` и `Abstract Factory`, примеры и различия между шаблонами](#factory-method-и-abstract-factory-примеры-и-различия-между-шаблонами)
* [Шаблон проектирования `Builder`, как он помагает при создании сложных объектов](#шаблон-проектирования-builder-как-он-помагает-при-создании-сложных-объектов)
* [Шаблон проектирования `Prototype`, как клонировать объекты в `Java` с помощью интерфейса `Cloneable`](#шаблон-проектирования-prototype-как-клонировать-объекты-в-java-с-помощью-интерфейса-cloneable)
* [Шаблон проектирования `Adapter`, как он помогает интегрировать несовместимые интерфейсы](#шаблон-проектирования-adapter-как-он-помогает-интегрировать-несовместимые-интерфейсы)
* [Шаблон проектирования `Decorator`, добавление новой функциональности объекту](#шаблон-проектирования-decorator-добавление-новой-функциональности-объекту)
* [Разница между `Adapter` и `Decorator`](#разница-между-adapter-и-decorator)
* [Шаблон проектирования `Composite`, использование для организации древовидной структуры](#шаблон-проектирования-composite-использование-для-организации-древовидной-структуры)
* [Шаблон проектирования `Proxy`, контроль доступа к объекту](#шаблон-проектирования-proxy-контроль-доступа-к-объекту)
* [Шаблон проектирования `Facade`, использование для упрощения взаимодействия с комплексными системами](#шаблон-проектирования-facade-использование-для-упрощения-взаимодействия-с-комплексными-системами)
* [Шаблон проектирования `Bridge`, как он помогает отделить абстракцию от её реализации](#шаблон-проектирования-bridge-как-он-помогает-отделить-абстракцию-от-её-реализации)
* [Шаблон проектирования `Flyweight`, уменьшение количества объектов в приложении](#шаблон-проектирования-flyweight-уменьшение-количества-объектов-в-приложении)
* [Шаблон проектирования `Chain of Responsibility`, передача запроса по цепочке объектов](#шаблон-проектирования-chain-of-responsibility-передача-запроса-по-цепочке-объектов)
* [Шаблон проектирования `Command`, инкапсулирование команд в объекте](#шаблон-проектирования-command-инкапсулирование-команд-в-объекте)
* [Шаблон проектирования `Observer`, как реализовать паттерн наблюдателя](#шаблон-проектирования-observer-как-реализовать-паттерн-наблюдателя)
* [Шаблон `Observer` и шаблон `Pub/Sub`, их архитектурная разница и примеры использования](#шаблон-observer-и-шаблон-pubsub-их-архитектурная-разница-и-примеры-использования)
* [Шаблон проектирования `Strategy`, как `Strategy` помогает выбирать алгоритмы на этапе выполнения](#шаблон-проектирования-strategy-как-strategy-помогает-выбирать-алгоритмы-на-этапе-выполнения)
* [Шаблон проектирования `State`, переключение состояний объекта в зависимости от его состояния](#шаблон-проектирования-state-переключение-состояний-объекта-в-зависимости-от-его-состояния)
* [Шаблон проектирования `Template Method`, использование для определения скелета алгоритма с возможностью изменения шагов](#шаблон-проектирования-template-method-использование-для-определения-скелета-алгоритма-с-возможностью-изменения-шагов)
* [Шаблон проектирования `Memento`, сохранение и восстановление состояния объекта](#шаблон-проектирования-memento-сохранение-и-восстановление-состояния-объекта)
* [Шаблон проектирования `Mediator`, управление взаимодействием между объектами](#шаблон-проектирования-mediator-управление-взаимодействием-между-объектами)


## Что такое шаблон проектирования (`Design Pattern`)

**Шаблон проектирования** (`Design Pattern`) — это типовое решение для повторяющихся проблем проектирования программного обеспечения. Это описанный способ организации и взаимодействия между объектами или классами для решения общей задачи, возникающей в ходе разработки.

### Цель использования:
Цель шаблонов проектирования заключается в том, чтобы предоставить стандартный и проверенный подход к решению распространенных проблем разработки. Они помогают упростить процесс проектирования сложных систем, повышая гибкость и надежность архитектуры, и обеспечивают возможность адаптации и масштабирования решений.

### Преимущества использования шаблонов проектирования:
1. **Повторное использование решений**: Шаблоны предоставляют готовые и проверенные решения, что позволяет не изобретать велосипед, а использовать проверенные подходы.

2. **Улучшение читаемости и поддержки кода**: Использование шаблонов проектирования делает код более понятным для других разработчиков, поскольку большинство из них знакомы с общими паттернами.

3. **Обеспечение гибкости системы**: Шаблоны проектирования помогают создавать системы, которые легче изменять и масштабировать за счет гибкой архитектуры, позволяющей легко вносить новые изменения.

4. **Снижение сложности разработки**: Шаблоны упрощают процесс разработки, разбивая сложные задачи на более управляемые части и предоставляя готовые структуры для их реализации.

5. **Унификация разработки**: Использование шаблонов помогает стандартизировать подходы к решению типичных задач в проекте, что облегчает взаимодействие между разработчиками и способствует более эффективной командной работе.

6. **Повышение надежности и устойчивости кода**: Шаблоны представляют собой решения, проверенные на практике, что снижает вероятность возникновения ошибок и багов в разработке.

### Заключение:
**Шаблоны проектирования** — это мощный инструмент для решения задач проектирования программного обеспечения, который помогает создавать гибкие, надежные и легко поддерживаемые системы, снижая при этом сложность разработки.

[наверх](#шаблоны-проектирования)


## Какие категории шаблонов проектирования существуют

Шаблоны проектирования классифицируются на три основные категории: 
* порождающие
* структурные
* поведенческие 

Каждая из этих категорий решает свои задачи в процессе проектирования и разработки систем.

### 1. Порождающие (`Creational`) шаблоны проектирования
Порождающие шаблоны сосредоточены на создании объектов. Они абстрагируют или скрывают процесс создания объектов, что позволяет сделать его более гибким и универсальным.

Примеры:

* `Singleton` (Одиночка): Гарантирует, что у класса будет только один экземпляр, и предоставляет к нему глобальную точку доступа.

    * **Пример**: класс конфигурации приложения, доступный во всем проекте в единственном экземпляре.

* `Factory Method` (Фабричный метод): Определяет интерфейс для создания объектов в суперклассе, но позволяет подклассам изменять тип создаваемых объектов.

    * **Пример**: создание объектов различных типов документов (PDF, DOCX) через общий интерфейс.

* `Abstract Factory` (Абстрактная фабрика): Предоставляет интерфейс для создания семейств взаимосвязанных объектов без указания их конкретных классов.

    * **Пример**: создание различных GUI элементов (кнопки, окна) для разных платформ (Windows, MacOS).

* `Builder` (Строитель): Разделяет процесс конструирования сложного объекта на отдельные шаги, что позволяет создавать его пошагово.

    * **Пример**: поэтапное создание сложных объектов, таких как конфигурации автомобилей.

* `Prototype` (Прототип): Позволяет создавать новые объекты путем копирования существующего объекта-прототипа.

    * **Пример**: клонирование объектов, которые дорого создавать заново (например, сложные графические элементы).

### 2. Структурные (`Structural`) шаблоны проектирования
Структурные шаблоны касаются построения отношений между объектами и классами. Они упрощают проектирование системы, делая ее более гибкой и модульной за счет объединения объектов или классов.

Примеры:

* `Adapter` (Адаптер): Позволяет объектам с несовместимыми интерфейсами работать вместе путем обертки одного интерфейса в другой.

    * **Пример**: адаптация одного интерфейса к другому, например, приведение старого `API` к новому.

* `Decorator` (Декоратор): Динамически добавляет новой функциональности объектам без изменения их классов.

    * **Пример**: добавление функций к объекту (например, добавление фильтров к потоку данных).

* `Facade` (Фасад): Предоставляет простой интерфейс к сложной подсистеме, облегчая ее использование.

    * **Пример**: создание интерфейса для взаимодействия с библиотеками или `API` с множеством сложных классов.

* `Composite` (Компоновщик): Позволяет создавать древовидные структуры, где отдельные объекты и группы объектов обрабатываются одинаково.

    * **Пример**: система файлов, где файл и папка имеют одно и то же поведение (открытие, удаление и т.д.).

* `Proxy` (Заместитель): Позволяет контролировать доступ к объекту путем его замены другим объектом (заместителем).

    * **Пример**: прокси-класс для управления доступом к ресурсу или для ленивой инициализации.

* `Bridge` (Мост): Разделяет абстракцию и реализацию, позволяя им изменяться независимо друг от друга.

    * **Пример**: разделение классов интерфейсов с методами рисования и реализаций для различных платформ.

* `Flyweight` (Приспособленец): Оптимизирует работу с большим количеством мелких объектов путем совместного использования общего состояния.

    * **Пример**: использование одного объекта для хранения данных символов в текстовом редакторе.

### 3. Поведенческие (`Behavioral`) шаблоны проектирования
Поведенческие шаблоны проектирования определяют способы взаимодействия объектов и классов. Они помогают организовать алгоритмы и потоки данных между объектами в системе.

Примеры:

* `Observer` (Наблюдатель): Определяет зависимость «один ко многим», при которой изменения состояния одного объекта автоматически уведомляют все связанные объекты.

    * **Пример**: паттерн наблюдателя в интерфейсах пользователя, где изменения в модели данных обновляют отображение.

* `Strategy` (Стратегия): Определяет семейство алгоритмов, инкапсулирует каждый из них и делает их взаимозаменяемыми.

    * **Пример**: выбор различных способов сортировки данных (быстрая сортировка, сортировка пузырьком).

* `Command` (Команда): Инкапсулирует запрос в виде объекта, позволяя передавать его как параметр.

    * **Пример**: реализация системы отмены/повтора действий в текстовых редакторах.

* `State` (Состояние): Позволяет объекту изменять свое поведение в зависимости от состояния, при этом внешне объект выглядит как один и тот же.

    * **Пример**: автомат с напитками, который изменяет свое поведение в зависимости от наличия монет.

* `Chain of Responsibility` (Цепочка обязанностей): Позволяет передавать запрос по цепочке объектов, пока один из них не обработает его.

    * **Пример**: система обработки заявок на кредит, где каждое звено цепи решает, одобрить или отклонить заявку.

* `Mediator` (Посредник): Обеспечивает взаимодействие между объектами, избегая их прямого взаимодействия.

    * **Пример**: чат-комната, в которой посредник (сервер) управляет отправкой сообщений между пользователями.

* `Template Method` (Шаблонный метод): Определяет скелет алгоритма, делегируя реализацию отдельных шагов подклассам.

    * **Пример**: класс с абстрактным методом и реализацией общей логики для его подклассов.

* `Visitor` (Посетитель): Позволяет добавить новые операции к существующим классам без изменения их структуры.

    * **Пример**: добавление новой операции по обработке элементов структуры данных, таких как дерево или список.

### Заключение:
Шаблоны проектирования помогают решать повторяющиеся проблемы проектирования в различных контекстах разработки программного обеспечения. Порождающие шаблоны фокусируются на создании объектов, структурные — на упрощении организации и взаимодействия между классами, а поведенческие — на алгоритмах и управлении взаимодействием объектов.

[наверх](#шаблоны-проектирования)


## Что такое `Singleton`, плюсы и минусы данного шаблона

`Singleton` — это порождающий шаблон проектирования, который гарантирует, что у класса будет только один экземпляр на протяжении всего времени работы программы, и предоставляет глобальную точку доступа к этому экземпляру. `Singleton` используется в тех случаях, когда необходимо контролировать создание объекта и обеспечить его уникальность.

### Реализация `Singleton` в `Java`
Самая простая реализация в однопоточной среде выглядит следующим образом:

```java
public class Singleton {
    // Статическая переменная, хранящая единственный экземпляр класса
    private static Singleton instance;

    // Закрытый конструктор, чтобы предотвратить создание объекта извне
    private Singleton() {
    }

    // Метод для получения экземпляра класса
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // Создание экземпляра при первом вызове
        }
        return instance;
    }
}
```

### Объяснение:
1. Статическая переменная `instance` хранит единственный экземпляр класса.

2. Приватный конструктор не позволяет создавать новые экземпляры класса извне.

3. Метод getInstance возвращает экземпляр класса. Если объект еще не создан (то есть `instance` == `null`), то он создается, а затем возвращается при последующих вызовах метода.

### Плюсы использования `Singleton`:
1. Контроль над количеством экземпляров: Гарантируется, что существует только один экземпляр класса, что полезно для управления ресурсами, такими как подключение к базе данных, логирование и т.д.

2. Глобальная точка доступа: Обеспечивается единый доступ к экземпляру класса из любой части программы.

3. Экономия ресурсов: Экземпляр создается только один раз, что снижает накладные расходы на создание объектов.

### Минусы использования `Singleton`:
1. Нарушение принципа единственной ответственности (`SRP`): Класс занимается как своим поведением, так и контролем за количеством своих экземпляров, что делает его менее гибким.

2. Затруднение тестирования: Тестирование класса с использованием `Singleton` может быть сложным, так как подмена экземпляра для тестов не всегда легко реализуема.

3. Глобальное состояние: `Singleton` создает глобальное состояние, что может привести к трудноотслеживаемым ошибкам и непредсказуемому поведению приложения.

4. Трудности с расширением: Из-за жестко заданного механизма создания одного экземпляра может быть трудно изменить поведение или расширить функционал класса.

В целом, `Singleton` полезен, когда нужно обеспечить наличие только одного экземпляра объекта, но его использование нужно тщательно обдумывать, чтобы избежать проблем с тестированием и глобальными зависимостями.

[наверх](#шаблоны-проектирования)


## Потокобезопасный `Singleton`, реализация с использованием `synchronized`, статических классов или `enum`

Для создания потокобезопасного `Singleton` в `Java` существует несколько подходов. Рассмотрим три распространённые реализации: с использованием ключевого слова `synchronized`, статического внутреннего класса и enum.

### 1. Реализация с использованием `synchronized`
Этот подход защищает доступ к `Singleton` при помощи синхронизации, гарантируя, что два потока не смогут одновременно создать два экземпляра `Singleton`.

```java
public class Singleton {
    private static Singleton instance;

    // Приватный конструктор
    private Singleton() {}

    // Потокобезопасный метод для получения экземпляра Singleton
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
**Объяснение**:

* synchronized гарантирует, что только один поток может войти в метод getInstance() одновременно. Это предотвращает создание нескольких экземпляров Singleton в многопоточной среде.

* Недостаток этого подхода заключается в том, что синхронизация на каждом вызове метода может снижать производительность.

### 2. Реализация с использованием статического внутреннего класса
Этот подход, называемый `Bill Pugh Singleton`, считается одним из лучших, так как он лениво создает экземпляр Singleton и при этом не требует синхронизации.

```java
public class Singleton {
    private Singleton() {}

    // Внутренний статический класс, содержащий единственный экземпляр Singleton
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    // Метод для получения экземпляра Singleton
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**Объяснение**:

* Экземпляр `INSTANCE` создается при первом вызове метода `getInstance()`, но не раньше.

* В этом подходе используется механизм инициализации классов в `Java`: класс `SingletonHolder` не будет загружен до тех пор, пока не вызван метод `getInstance()`, что делает реализацию ленивой.

* Этот подход не требует использования синхронизации, поскольку инициализация классов в `Java` автоматически потокобезопасна.

### 3. Реализация с использованием `enum`
Этот метод создания `Singleton` появился в `Java` с версии 1.5, когда был введён `enum`. Он является наиболее простым и надёжным способом создания `Singleton`.

```java
public enum Singleton {
    INSTANCE;

    // Можно добавить методы
    public void doSomething() {
        // Реализация
    }
}
```

**Объяснение**:

* Использование `enum` автоматически гарантирует, что создается только один экземпляр. Это связано с особенностями работы `enum` в `Java`, где каждый элемент перечисления создается только один раз.

* Этот подход защищён от проблем, связанных с сериализацией и рефлексией, которые могут возникать в других реализациях `Singleton`.

* Недостатком может быть то, что это менее гибкий подход, так как enum не может наследовать другие классы, хотя это редко требуется для `Singleton`.

### Плюсы и минусы различных подходов

### === Реализация с `synchronized` ===



**Плюсы**:

* Простая реализация.
* Легко читается и понимается.

**Минусы**:

* Каждый вызов метода синхронизирован, что может ухудшать производительность, особенно при частом вызове метода.

### === Реализация состатическим внутренним классом ===

**Плюсы**:

* Высокая производительность, так как нет необходимости в синхронизации.
* Ленивая инициализация: экземпляр создается только при первом вызове.

**Минусы**:

* Более сложная для понимания реализация, чем с использованием synchronized.

### === Реализация с использованием `enum` ===

**Плюсы**:

* Простая и краткая реализация.
* Потокобезопасная.
* Защищена от сериализации и рефлексии.

**Минусы**:

* Ограниченная гибкость, так как enum не может наследовать другие классы.
* Каждый подход имеет свои плюсы и минусы, и выбор между ними зависит от специфических требований вашего проекта.

[наверх](#шаблоны-проектирования)


## `Factory Method`, пример реализации фабричного метода, когда использовать

`Factory Method` — это порождающий шаблон проектирования, который предоставляет интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов. Этот шаблон позволяет делегировать создание объектов подклассам, вместо того чтобы полагаться на конкретные классы, тем самым снижая зависимость от конкретных реализаций.

### Когда использовать `Factory Method`
* Когда код не должен зависеть от конкретных классов создаваемых объектов.
* Когда в процессе разработки требуется подменять или изменять классы, которые создают объекты.
* Когда нужно предоставить возможность расширения для добавления новых типов объектов без изменения существующего кода (принцип открытости/закрытости).
* Когда создание объекта требует сложной логики, и её необходимо вынести в отдельный метод или класс.

### Пример реализации `Factory Method` в `Java`
Представим, что у нас есть интерфейс для различных видов сообщений, и мы хотим использовать фабричный метод для создания различных типов сообщений (например, `TextMessage`, `EmailMessage`).

### 1. Определяем интерфейс или абстрактный класс, который будет содержать фабричный метод
```java
abstract class Message {
    public abstract String getContent();

    // Общие методы для всех типов сообщений
    public void addDefaultHeaders() {
        System.out.println("Добавлены заголовки сообщения");
    }

    public void encrypt() {
        System.out.println("Сообщение зашифровано");
    }
}

abstract class MessageCreator {
    // Фабричный метод
    public abstract Message createMessage();

    // Шаблонный метод, который использует фабричный метод
    public Message getMessage() {
        Message msg = createMessage();
        msg.addDefaultHeaders();
        msg.encrypt();
        return msg;
    }
}
```

### 2. Создаем конкретные классы сообщений
```java
class TextMessage extends Message {
    @Override
    public String getContent() {
        return "Это текстовое сообщение";
    }
}

class EmailMessage extends Message {
    @Override
    public String getContent() {
        return "Это электронное сообщение";
    }
}
```

### 3. Создаем конкретные фабрики для различных типов сообщений
```java
class TextMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new TextMessage();
    }
}

class EmailMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new EmailMessage();
    }
}
```
### 4. Использование `Factory Method`
```java
public class FactoryMethodDemo {
    public static void main(String[] args) {
        // Создаем текстовое сообщение
        MessageCreator creator = new TextMessageCreator();
        Message message = creator.getMessage();
        System.out.println(message.getContent());

        // Создаем электронное сообщение
        creator = new EmailMessageCreator();
        message = creator.getMessage();
        System.out.println(message.getContent());
    }
}
```

### Объяснение
* Абстрактный класс MessageCreator определяет фабричный метод createMessage, который должны реализовать подклассы. Этот метод отвечает за создание объектов типа Message.

* Конкретные подклассы (TextMessageCreator, EmailMessageCreator) реализуют этот метод, создавая конкретные типы сообщений (TextMessage, EmailMessage).

* Клиентский код вызывает метод getMessage(), который использует фабричный метод для создания сообщения, а затем выполняет с ним общие действия (например, добавляет заголовки, шифрует).

### Когда использовать `Factory Method`
1. Когда создание объекта может варьироваться в зависимости от ситуации: Если вы хотите делегировать создание объекта подклассам, которые решат, какой тип объекта будет создан.

2. Для улучшения расширяемости кода: Можно легко добавлять новые типы объектов, не меняя существующий код, тем самым соблюдая принцип открытости/закрытости (Open/Closed Principle).

3. Когда нужно скрыть детали создания объекта: Клиентский код работает с интерфейсом или абстрактным классом и не заботится о том, как именно создается объект.

`Factory Method` удобен для ситуаций, когда вам нужно подменять реализацию классов без изменения клиентского кода, или когда вы хотите, чтобы классы, создающие объекты, имели возможность влиять на процесс создания объектов.

[наверх](#шаблоны-проектирования)


## `Factory Method` и `Abstract Factory`, примеры и различия между шаблонами

`Factory Method` и `Abstract Factory` — это порождающие шаблоны проектирования, используемые для создания объектов. Оба они помогают абстрагировать процесс создания объектов, но различаются по своей структуре и применению.

### Разница между `Factory Method` и `Abstract Factory`:
1. Factory Method (Фабричный метод):

    * Определение: Это шаблон, который предоставляет интерфейс для создания объектов, но позволяет подклассам изменить тип создаваемого объекта.

    * Фокус: Создание одного объекта.

    * Применение: Используется, когда нужно делегировать создание объектов подклассам.

    * Реализация: Каждый подкласс реализует собственный метод фабрики, который возвращает объект.

2. Abstract Factory (Абстрактная фабрика):

    * Определение: Это шаблон, который предоставляет интерфейс для создания семейств взаимосвязанных или зависимых объектов, не указывая их конкретные классы.

    * Фокус: Создание целого семейства объектов.

    * Применение: Используется, когда нужно создавать несколько взаимосвязанных объектов, и важно, чтобы они использовали одни и те же семейства объектов.
    
    * Реализация: Определяется набор фабрик для создания объектов различных типов (например, интерфейсы для создания объектов разных видов), а конкретные фабрики реализуют интерфейс для создания семейств объектов.

### Пример реализации `Factory Method` в `Java`
В этом примере мы создаем разные виды сообщений (текстовое и электронное) с использованием фабричного метода.

```java
abstract class Message {
    public abstract String getContent();
}

class TextMessage extends Message {
    @Override
    public String getContent() {
        return "Это текстовое сообщение";
    }
}

class EmailMessage extends Message {
    @Override
    public String getContent() {
        return "Это электронное сообщение";
    }
}

abstract class MessageCreator {
    // Фабричный метод
    public abstract Message createMessage();
}

class TextMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new TextMessage();
    }
}

class EmailMessageCreator extends MessageCreator {
    @Override
    public Message createMessage() {
        return new EmailMessage();
    }
}

public class FactoryMethodExample {
    public static void main(String[] args) {
        MessageCreator creator = new TextMessageCreator();
        Message message = creator.createMessage();
        System.out.println(message.getContent());

        creator = new EmailMessageCreator();
        message = creator.createMessage();
        System.out.println(message.getContent());
    }
}
```

### Пример реализации `Abstract Factory` в `Java`
Теперь рассмотрим пример `Abstract Factory`, где создаются различные типы кнопок и чекбоксов в зависимости от операционной системы.

```java
// Продукты
interface Button {
    void paint();
}

class WindowsButton implements Button {
    public void paint() {
        System.out.println("Рисуем кнопку Windows");
    }
}

class MacOSButton implements Button {
    public void paint() {
        System.out.println("Рисуем кнопку MacOS");
    }
}

interface Checkbox {
    void paint();
}

class WindowsCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Рисуем чекбокс Windows");
    }
}

class MacOSCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Рисуем чекбокс MacOS");
    }
}

// Абстрактная фабрика
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Конкретные фабрики
class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }

    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

class MacOSFactory implements GUIFactory {
    public Button createButton() {
        return new MacOSButton();
    }

    public Checkbox createCheckbox() {
        return new MacOSCheckbox();
    }
}

// Клиент
public class AbstractFactoryExample {
    private static Application configureApplication() {
        Application app;
        GUIFactory factory;
        String osName = System.getProperty("os.name").toLowerCase();

        if (osName.contains("mac")) {
            factory = new MacOSFactory();
        } else {
            factory = new WindowsFactory();
        }

        app = new Application(factory);
        return app;
    }

    public static void main(String[] args) {
        Application app = configureApplication();
        app.paint();
    }
}

class Application {
    private Button button;
    private Checkbox checkbox;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }

    public void paint() {
        button.paint();
        checkbox.paint();
    }
}
```

### Основные различия между `Factory Method` и `Abstract Factory`

<table border="1" cellpadding="10" cellspacing="0">
    <thead>
        <tr>
            <th>Характеристика</th>
            <th>Factory Method</th>
            <th>Abstract Factory</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Цель</td>
            <td>Определяет интерфейс для создания одного объекта.</td>
            <td>Определяет интерфейс для создания семейств объектов.</td>
        </tr>
        <tr>
            <td>Создание объектов</td>
            <td>Создаёт один объект.</td>
            <td>Создаёт семейства взаимосвязанных объектов.</td>
        </tr>
        <tr>
            <td>Использование подклассов</td>
            <td>Подклассы определяют, какой объект будет создан.</td>
            <td>Подклассы создают конкретные продукты из семейства.</td>
        </tr>
        <tr>
            <td>Пример использования</td>
            <td>Создание конкретных сообщений, таких как текстовое или электронное сообщение.</td>
            <td>Создание кнопок и чекбоксов для разных платформ (Windows, MacOS).</td>
        </tr>
    </tbody>
</table>

### Когда использовать какой шаблон?
* `Factory Method` полезен, когда требуется создать один объект, но его конкретный тип может меняться в зависимости от контекста или условий, например создание сообщений, где разные классы сообщений реализуют общий интерфейс.

* `Abstract Factory` используется, когда нужно создавать целые семейства взаимосвязанных объектов, например, интерфейсы для разных платформ (кнопки, окна, чекбоксы для Windows и MacOS).

В целом, `Factory Method` — это более простой шаблон, который решает задачу создания одного объекта, тогда как `Abstract Factory` — более сложный и предназначен для создания семейства объектов, которые должны работать вместе.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Builder`, как он помагает при создании сложных объектов

`Builder` — это порождающий шаблон проектирования, который используется для поэтапного создания сложных объектов. Вместо того чтобы создавать объект с помощью одного конструктора с множеством параметров, `Builder` позволяет создавать объект по шагам, последовательно настраивая его свойства.

### Задачи, которые решает шаблон `Builder`

1. Упрощает создание сложных объектов: Когда объект имеет много параметров, обычный подход с использованием конструктора может стать неудобным и трудно читаемым. Особенно, если объект имеет необязательные параметры.

2. Избегает "телескопических конструкторов": Проблема возникает, когда объект имеет множество параметров, и для каждого их набора нужно создавать разные конструкторы (например, от 2 до 10 параметров). Builder помогает избежать создания множества перегруженных конструкторов.

3. Удобное создание объектов с необязательными параметрами: Builder позволяет задавать только те параметры, которые действительно нужны, и избегать использования конструктора с множеством необязательных аргументов.

4. Повышает читаемость кода: Создание объекта с помощью Builder'а делает код более читабельным и понятным за счет явного указания свойств объекта.

### Пример использования шаблона `Builder` в `Java`
Предположим, у нас есть класс `Car`, который может иметь множество различных параметров, таких как модель, цвет, двигатель, год выпуска и так далее.

### 1. Без использования `Builder` (с "телескопическим" конструктором):
```java
class Car {
    private String model;
    private String color;
    private String engine;
    private int year;
    
    public Car(String model, String color, String engine, int year) {
        this.model = model;
        this.color = color;
        this.engine = engine;
        this.year = year;
    }

    // Методы доступа и другие методы...
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car("Toyota", "Red", "V8", 2023);
        // Если у машины 10 параметров, то этот подход становится неудобным
    }
}
```
### 2. Использование шаблона `Builder`:
```java
class Car {
    private String model;
    private String color;
    private String engine;
    private int year;

    // Приватный конструктор, чтобы нельзя было напрямую создавать объекты Car
    private Car(CarBuilder builder) {
        this.model = builder.model;
        this.color = builder.color;
        this.engine = builder.engine;
        this.year = builder.year;
    }

    // Статический класс Builder
    public static class CarBuilder {
        private String model;
        private String color;
        private String engine;
        private int year;

        // Параметры, которые могут быть обязательными
        public CarBuilder(String model) {
            this.model = model;
        }

        // Необязательные параметры задаются методами Builder
        public CarBuilder setColor(String color) {
            this.color = color;
            return this;
        }

        public CarBuilder setEngine(String engine) {
            this.engine = engine;
            return this;
        }

        public CarBuilder setYear(int year) {
            this.year = year;
            return this;
        }

        // Метод для создания объекта Car
        public Car build() {
            return new Car(this);
        }
    }

    @Override
    public String toString() {
        return "Car [model=" + model + ", color=" + color + ", engine=" + engine + ", year=" + year + "]";
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car.CarBuilder("Toyota")
                        .setColor("Red")
                        .setEngine("V8")
                        .setYear(2023)
                        .build();

        System.out.println(car);
    }
}
```

### Объяснение:
1. Конструктор Car — это приватный конструктор, который принимает объект CarBuilder. Это необходимо для того, чтобы объект Car нельзя было создать напрямую.

2. CarBuilder — это статический класс, который предоставляет методы для задания параметров объекта. Каждый метод setColor, setEngine и т.д. возвращает сам объект Builder, что позволяет вызывать методы цепочкой (chaining).

3. Метод build — это метод, который завершает процесс построения и возвращает готовый объект Car.

4. Преимущество — мы можем задать только те параметры, которые действительно необходимы, без необходимости указывать все параметры при создании объекта.

### Преимущества использования `Builder`:
1. Гибкость в создании объектов: Позволяет легко создавать объекты с разными комбинациями параметров, в том числе с необязательными параметрами.

2. Читаемость: Код, использующий Builder, легко читается и понятен за счёт именованных методов (например, setColor), а не из-за длинных списков аргументов в конструкторе.

3. Поддержка неизменяемых объектов: После создания объекта с помощью Builder его параметры могут быть сделаны неизменяемыми, что повышает безопасность данных.

4. Избежание перегрузки конструкторов: В отличие от использования нескольких конструкторов, Builder позволяет иметь один метод для создания объектов с любыми комбинациями параметров.

### Когда использовать `Builder`?
* Когда объект имеет много параметров, особенно если некоторые из них необязательны.

* Когда нужно создать объект поэтапно или с возможностью дальнейшего конфигурирования.

* Когда создание объекта требует много шагов или сложной логики (например, построение графических интерфейсов или конфигурация подключения).

* Когда конструктор с большим количеством параметров делает код трудно поддерживаемым и читаемым.

`Builder` особенно полезен в ситуациях, когда объект содержит много параметров и некоторые из них необязательны.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Prototype`, как клонировать объекты в `Java` с помощью интерфейса `Cloneable`

Шаблон проектирования `Prototype` — это порождающий шаблон, который используется, когда необходимо создать копии объектов, избегая затрат на создание новых экземпляров с использованием конструктора. Вместо того чтобы создавать объект с нуля, можно клонировать существующий объект и затем изменить его, если нужно. Этот подход особенно полезен, когда создание объектов является дорогостоящим или сложным процессом, или когда необходимо создать множество объектов, которые похожи, но с небольшими различиями.

### Когда следует использовать шаблон `Prototype`:
1. Когда создание объекта дорого: Если создание нового объекта требует значительных затрат ресурсов (например, требует много времени или сложных вычислений), клонирование существующего объекта может быть гораздо более эффективным.

2. Когда объекты имеют много возможных конфигураций: Вместо того чтобы создавать объекты с различными конфигурациями через конструкторы, можно создать базовый объект и клонировать его, изменяя только необходимые параметры.

3. Когда необходимо избежать создания иерархии классов для создания объектов: С помощью `Prototype` можно избежать создания множества подклассов для различных конфигураций объектов, что позволяет поддерживать код более простым и гибким.

4. Когда нужно дублировать объекты с минимальными изменениями: `Prototype` позволяет быстро создавать новые экземпляры объекта, сохраняя его текущее состояние.

### Как клонировать объекты в `Java` с помощью интерфейса `Cloneable`?
В `Java` для реализации шаблона `Prototype` часто используется интерфейс `Cloneable`. Этот интерфейс указывает, что класс поддерживает клонирование, но не предоставляет методов. Клонирование реализуется путем переопределения метода `clone()` из класса `Object`.

### Пример использования `Cloneable` в `Java`:
1. Определяем класс с поддержкой клонирования:
```java
class Car implements Cloneable {
    private String model;
    private String color;

    public Car(String model, String color) {
        this.model = model;
        this.color = color;
    }

    // Геттеры
    public String getModel() {
        return model;
    }

    public String getColor() {
        return color;
    }

    // Переопределение метода clone для поддержки клонирования
    @Override
    public Car clone() {
        try {
            return (Car) super.clone();  // Вызов метода clone() суперкласса Object
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Клонирование не поддерживается", e);
        }
    }

    @Override
    public String toString() {
        return "Car [model=" + model + ", color=" + color + "]";
    }
}
```
2. Клонирование объекта:
```java
public class Main {
    public static void main(String[] args) {
        // Создаем оригинальный объект Car
        Car car1 = new Car("Toyota", "Red");

        // Клонируем объект car1 в car2
        Car car2 = car1.clone();

        // Выводим оба объекта
        System.out.println("Оригинал: " + car1);
        System.out.println("Клон: " + car2);

        // Модификация клонированного объекта
        System.out.println("Изменение цвета клона...");
        car2 = new Car(car2.getModel(), "Blue");

        System.out.println("Оригинал после изменения клона: " + car1);
        System.out.println("Измененный клон: " + car2);
    }
}
```

### Объяснение:
1. Интерфейс Cloneable: Указывает, что класс поддерживает клонирование. Если класс реализует этот интерфейс, и вы вызываете метод clone() на его объекте, то метод должен вернуть копию этого объекта. Если Cloneable не реализован, вызов метода clone() выбросит исключение CloneNotSupportedException.

2. Переопределение метода clone(): Метод clone() должен быть явно переопределён в классе, так как его реализация в классе Object не подходит для всех случаев. В нашем примере Car переопределяет метод clone() и вызывает super.clone(), чтобы создать поверхностную копию объекта.

3. Клонирование объекта: После клонирования объекта car1, мы получаем новый объект car2, который является копией car1. Мы можем модифицировать клонированный объект, не влияя на оригинал.

### Поверхностное и глубокое клонирование:
* Поверхностное клонирование (shallow copy): Это копирование только самого объекта, но не его вложенных объектов. Если объект содержит ссылки на другие объекты, то ссылки будут скопированы, а не сами объекты. В Java, вызов super.clone() из класса Object по умолчанию делает поверхностную копию.

* Глубокое клонирование (deep copy): Это копирование не только самого объекта, но и всех объектов, на которые он ссылается. Для глубокого клонирования требуется самостоятельно клонировать все вложенные объекты.

### Пример поверхностного клонирования:
Если `Car` содержит ссылку на другой объект, например, на объект `Engine`, поверхностное клонирование не создаст новый объект `Engine`, а просто скопирует ссылку на него.

```java
class Engine {
    private String type;

    public Engine(String type) {
        this.type = type;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return "Engine[type=" + type + "]";
    }
}

class Car implements Cloneable {
    private String model;
    private String color;
    private Engine engine;

    public Car(String model, String color, Engine engine) {
        this.model = model;
        this.color = color;
        this.engine = engine;
    }

    @Override
    public Car clone() {
        try {
            return (Car) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Клонирование не поддерживается", e);
        }
    }

    @Override
    public String toString() {
        return "Car[model=" + model + ", color=" + color + ", engine=" + engine + "]";
    }
}
```

### Итог:
* Когда использовать `Prototype`:

    * Когда необходимо создать множество похожих объектов.
    * Когда создание объектов через конструктор является дорогостоящим или сложным.
    * Когда нужно создавать объекты с возможностью их легкой модификации после клонирования.

* `Cloneable` помогает легко реализовать клонирование объектов в `Java`, что делает процесс создания копий более простым и эффективным, особенно для шаблона проектирования `Prototype`.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Adapter`, как он помогает интегрировать несовместимые интерфейсы

`Adapter` — это структурный шаблон проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе. Этот шаблон выступает в роли посредника, преобразующего интерфейс одного класса в интерфейс, ожидаемый клиентом. Таким образом, `Adapter` решает проблему интеграции и совместимости различных классов, которые изначально не могут взаимодействовать напрямую.

### Задачи, решаемые шаблоном `Adapter`:
1. Интеграция старого и нового кода: Когда вам нужно использовать существующий класс с новым интерфейсом, но изменить код класса невозможно (например, класс находится в сторонней библиотеке или код слишком сложен для изменения).

2. Унификация интерфейсов: Когда разные классы выполняют похожие функции, но имеют разные интерфейсы, Adapter может предоставить единый интерфейс для использования их функциональности.

3. Повторное использование кода: Adapter позволяет использовать уже существующие классы и их методы в новых контекстах, без необходимости изменять их внутреннюю реализацию.

### Как `Adapter` помогает интегрировать несовместимые интерфейсы?
`Adapter` создает прослойку между клиентом (который ожидает один интерфейс) и сервисом (который реализует другой интерфейс). Он преобразует вызовы методов клиента в формат, понятный сервису, что позволяет обоим компонентам работать вместе.

#### Пример сценария:
Предположим, у вас есть интерфейс Target, который ваш клиент использует для работы с объектами, но у вас есть существующий класс Adaptee, который имеет несовместимый интерфейс. Вы не можете изменить Adaptee, но вам нужно, чтобы клиент мог его использовать. В этом случае Adapter преобразует вызовы методов клиента к интерфейсу Adaptee.

### Пример реализации `Adapter` в `Java`
Предположим, у нас есть система для работы с круглыми отверстиями и круглыми штырями. Однако, вы хотите вставить квадратный штырь в круглое отверстие. В таком случае можно использовать `Adapter`, чтобы адаптировать квадратный штырь к интерфейсу круглого отверстия.

#### 1. Интерфейс `Target` (ожидаемый клиентом):
```java
class RoundHole {
    private double radius;

    public RoundHole(double radius) {
        this.radius = radius;
    }

    public double getRadius() {
        return radius;
    }

    public boolean fits(RoundPeg peg) {
        return this.getRadius() >= peg.getRadius();
    }
}
```
#### 2. Класс `Adaptee` с несовместимым интерфейсом:
```java
class SquarePeg {
    private double width;

    public SquarePeg(double width) {
        this.width = width;
    }

    public double getWidth() {
        return width;
    }
}
```
#### 3. Адаптер для преобразования интерфейсов:
```java
class SquarePegAdapter extends RoundPeg {
    private SquarePeg squarePeg;

    public SquarePegAdapter(SquarePeg peg) {
        this.squarePeg = peg;
    }

    @Override
    public double getRadius() {
        // Преобразуем размер квадрата в радиус круга, который может его окружить
        return (squarePeg.getWidth() * Math.sqrt(2)) / 2;
    }
}
```
#### 4. Использование `Adapter`:
```java
public class AdapterPatternDemo {
    public static void main(String[] args) {
        // Круглое отверстие и круглый штырь совместимы
        RoundHole hole = new RoundHole(5);
        RoundPeg roundPeg = new RoundPeg(5);
        System.out.println(hole.fits(roundPeg)); // true

        // Квадратный штырь не совместим с круглым отверстием
        SquarePeg smallSquarePeg = new SquarePeg(5);
        SquarePeg largeSquarePeg = new SquarePeg(10);
        
        // Используем адаптер для квадратного штыря
        SquarePegAdapter smallSquarePegAdapter = new SquarePegAdapter(smallSquarePeg);
        SquarePegAdapter largeSquarePegAdapter = new SquarePegAdapter(largeSquarePeg);

        // Проверяем, подходят ли квадратные штыри для круглого отверстия через адаптер
        System.out.println(hole.fits(smallSquarePegAdapter)); // true
        System.out.println(hole.fits(largeSquarePegAdapter)); // false
    }
}
```
### Объяснение:
1. Клиент (RoundHole) работает с круглыми штырями через метод fits(), ожидая объект, который реализует интерфейс RoundPeg.

2. Adaptee (SquarePeg) представляет класс с несовместимым интерфейсом — квадратный штырь, который не может напрямую взаимодействовать с RoundHole.

3. Adapter (SquarePegAdapter) адаптирует интерфейс SquarePeg под ожидаемый интерфейс RoundPeg. Он "оборачивает" объект SquarePeg и переопределяет метод getRadius() так, чтобы вычислить подходящий радиус для квадратного штыря.

### Преимущества использования `Adapter`:
1. Инкапсуляция различий: Адаптер изолирует клиентский код от изменений в сторонних библиотеках или классах с несовместимыми интерфейсами.

2. Повторное использование: Вместо того чтобы переписывать или дублировать код, можно использовать уже существующие классы, просто адаптировав их интерфейсы.

3. Гибкость: Можно легко адаптировать различные классы для работы с нужным интерфейсом, не меняя существующую логику клиентского кода.

### Когда использовать `Adapter`:
1. Когда необходимо интегрировать класс с интерфейсом, несовместимым с используемым в проекте.

2. Когда нужно использовать стороннюю библиотеку или класс без изменения его исходного кода.

3. Когда разные классы выполняют похожие задачи, но имеют различные интерфейсы, и нужно унифицировать их работу в рамках одного клиентского кода.

Шаблон `Adapter` помогает решить проблему несовместимости интерфейсов и делает возможным повторное использование существующего кода без его изменения.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Decorator`, добавление новой функциональности объекту

`Decorator` (Декоратор) — это структурный шаблон проектирования, который позволяет динамически добавлять новые функциональности объекту, не изменяя его исходный код и не прибегая к наследованию. Это достигается путем "обёртывания" исходного объекта в новые классы, которые добавляют функциональность.

`Decorator` предоставляет гибкий способ расширения возможностей объекта на этапе выполнения программы, не создавая подклассы для каждой возможной комбинации новых функций.

### Когда использовать `Decorator`?
1. Когда нужно добавлять функциональность объектам динамически, во время выполнения программы.
2. Когда нельзя или нецелесообразно изменять исходный класс объекта, например, если это сторонняя библиотека или класс закрыт для модификации.
3. Когда нужно избежать создания большого числа подклассов для каждого сочетания дополнительных функций (заменяя их динамическим добавлением через декораторы).

### Пример использования `Decorator` в `Java`
Предположим, у нас есть интерфейс `DataSource`, который предоставляет методы для чтения и записи данных, и мы хотим добавлять дополнительную функциональность, такую как шифрование данных перед записью или сжатие данных перед сохранением.

#### 1. Базовый интерфейс `DataSource`:
```java
interface DataSource {
    void writeData(String data);
    String readData();
}
```
#### 2. Базовый класс `FileDataSource`, который реализует интерфейс:
```java
class FileDataSource implements DataSource {
    private String filename;

    public FileDataSource(String filename) {
        this.filename = filename;
    }

    @Override
    public void writeData(String data) {
        System.out.println("Запись данных в файл: " + filename);
        // Логика записи данных в файл
    }

    @Override
    public String readData() {
        System.out.println("Чтение данных из файла: " + filename);
        // Логика чтения данных из файла
        return "Данные из файла";
    }
}
```
#### 3. Абстрактный класс `DataSourceDecorator`:
Этот класс реализует интерфейс `DataSource` и содержит ссылку на объект `DataSource`, который будет декорирован.

```java
class DataSourceDecorator implements DataSource {
    protected DataSource wrappee;

    public DataSourceDecorator(DataSource source) {
        this.wrappee = source;
    }

    @Override
    public void writeData(String data) {
        wrappee.writeData(data);
    }

    @Override
    public String readData() {
        return wrappee.readData();
    }
}
```

#### 4. Декоратор `EncryptionDecorator`, который добавляет шифрование данных:
```java
class EncryptionDecorator extends DataSourceDecorator {

    public EncryptionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void writeData(String data) {
        String encryptedData = encrypt(data);
        super.writeData(encryptedData);
    }

    @Override
    public String readData() {
        String data = super.readData();
        return decrypt(data);
    }

    private String encrypt(String data) {
        // Простая логика шифрования (для примера)
        return "encrypted_" + data;
    }

    private String decrypt(String data) {
        // Простая логика дешифрования (для примера)
        return data.replace("encrypted_", "");
    }
}
```

#### 5. Декоратор `CompressionDecorator`, который добавляет сжатие данных:
```java
class CompressionDecorator extends DataSourceDecorator {

    public CompressionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void writeData(String data) {
        String compressedData = compress(data);
        super.writeData(compressedData);
    }

    @Override
    public String readData() {
        String data = super.readData();
        return decompress(data);
    }

    private String compress(String data) {
        // Простая логика сжатия (для примера)
        return "compressed_" + data;
    }

    private String decompress(String data) {
        // Простая логика декомпрессии (для примера)
        return data.replace("compressed_", "");
    }
}
```

#### 6. Использование декораторов:
```java
public class DecoratorDemo {
    public static void main(String[] args) {
        DataSource fileDataSource = new FileDataSource("data.txt");

        // Оборачиваем FileDataSource в декораторы
        DataSource encryptedDataSource = new EncryptionDecorator(fileDataSource);
        DataSource compressedAndEncryptedDataSource = new CompressionDecorator(encryptedDataSource);

        // Запись данных с сжатием и шифрованием
        compressedAndEncryptedDataSource.writeData("Некоторые данные");

        // Чтение данных с дешифрованием и декомпрессией
        String result = compressedAndEncryptedDataSource.readData();
        System.out.println("Чтение данных: " + result);
    }
}
```
### Объяснение:
1. FileDataSource — это базовый объект, который выполняет стандартные операции чтения и записи в файл.

2. DataSourceDecorator — это абстрактный класс, который содержит ссылку на объект DataSource и передает вызовы базового метода.

3. EncryptionDecorator добавляет шифрование перед записью и расшифровку при чтении.

4. CompressionDecorator добавляет сжатие перед записью и разжатие при чтении.

5. Использование декораторов позволяет динамически добавлять шифрование, сжатие или другие функции к объектам, не изменяя исходные классы.

### Преимущества использования `Decorator`:
1. Гибкость: Позволяет добавлять функциональность объекту на этапе выполнения программы.

2. Простота в поддержке: Легко добавлять новые декораторы для расширения функциональности без изменения исходных классов.

3. Комбинирование поведения: Декораторы можно комбинировать, добавляя несколько уровней функциональности.

### Когда использовать `Decorator`:
* Когда нужно динамически расширить функциональность объекта, не создавая подклассов.

* Когда нужно добавлять разные функциональности объекту без изменения его исходного кода.

* Когда требуется возможность комбинирования нескольких функций.

`Decorator` — это удобный способ динамически изменять поведение объектов, избегая жесткого наследования и улучшая гибкость системы.

[наверх](#шаблоны-проектирования)


## Разница между `Adapter` и `Decorator`

`Adapter` и `Decorator` — это структурные шаблоны проектирования, но они служат разным целям и решают разные задачи. Рассмотрим основные отличия и цели каждого из них.

### Основные различия между `Adapter` и `Decorator`:
<table border="1" cellpadding="10" cellspacing="0">
    <thead>
        <tr>
            <th>Характеристика</th>
            <th>Adapter</th>
            <th>Decorator</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Цель</td>
            <td>Преобразование интерфейса одного класса в другой, чтобы классы с несовместимыми интерфейсами могли работать вместе.</td>
            <td>Добавление новой функциональности объекту без изменения его интерфейса.</td>
        </tr>
        <tr>
            <td>Когда использовать</td>
            <td>Когда необходимо интегрировать класс с несовместимым интерфейсом, чтобы он мог работать с существующим кодом.</td>
            <td>Когда необходимо расширить или модифицировать поведение объекта, не изменяя его исходный класс.</td>
        </tr>
        <tr>
            <td>Фокус</td>
            <td>Изменение интерфейса объекта.</td>
            <td>Расширение поведения объекта.</td>
        </tr>
        <tr>
            <td>Применение</td>
            <td>Используется, когда необходимо интегрировать сторонние библиотеки или объекты с несовместимыми интерфейсами.</td>
            <td>Используется, когда нужно добавить динамическую функциональность объектам.</td>
        </tr>
        <tr>
            <td>Влияние на структуру</td>
            <td>Adapter изменяет интерфейс объекта, чтобы клиент мог его использовать.</td>
            <td>Decorator сохраняет интерфейс объекта, добавляя дополнительные функции.</td>
        </tr>
        <tr>
            <td>Пример</td>
            <td>Адаптация квадратного штыря для круглого отверстия.</td>
            <td>Добавление сжатия или шифрования данных для объекта.</td>
        </tr>
    </tbody>
</table>

### Детализированное сравнение:
1. Цели шаблонов:
    * Adapter преобразует интерфейс существующего объекта таким образом, чтобы он стал совместим с другим кодом, который ожидает другой интерфейс. Adapter действует как посредник, скрывающий несовместимости интерфейсов.

    * Decorator расширяет поведение существующего объекта, добавляя новые функции, не изменяя его интерфейс. Он позволяет динамически "оборачивать" объекты дополнительными функциями.

2. Когда использовать:

    * Adapter полезен, когда необходимо сделать два несовместимых интерфейса совместимыми. Например, вам может потребоваться адаптировать сторонний класс к интерфейсу вашей системы, не меняя исходный класс.

    * Decorator полезен, когда вам нужно динамически расширить функциональность объектов, не изменяя их исходную структуру или код. Например, когда необходимо добавлять функции шифрования или сжатия к объекту данных, не меняя сам объект.

3. Фокус:

    * Adapter фокусируется на изменении интерфейса объекта. Он не добавляет функциональность объекту, а лишь делает его совместимым с другим интерфейсом.

    * Decorator фокусируется на расширении или изменении поведения объекта. Он не изменяет интерфейс, а добавляет новые функции, при этом интерфейс остается прежним.

4. Влияние на интерфейс:

    * Adapter изменяет интерфейс объекта, чтобы его можно было использовать в другом контексте.

    * Decorator не изменяет интерфейс объекта, а лишь добавляет новое поведение или функциональность, сохраняя существующий интерфейс.

5. Пример:

    * Adapter: Если у вас есть круглая дыра (класс RoundHole) и квадратный штырь (класс SquarePeg), которые несовместимы из-за разных интерфейсов, Adapter (например, SquarePegAdapter) преобразует квадратный штырь в подходящий для круглого отверстия.

    * Decorator: Если у вас есть объект DataSource, который сохраняет данные, и вы хотите добавить к нему возможность шифрования или сжатия данных, вы можете использовать EncryptionDecorator или CompressionDecorator для расширения функциональности объекта, сохраняя тот же интерфейс DataSource.

### Итог:
* Adapter предназначен для преобразования интерфейса, чтобы сделать несовместимые классы совместимыми. Он действует как "мост" между двумя несовместимыми интерфейсами.

* Decorator предназначен для динамического добавления новых функций объектам без изменения их интерфейса. Он расширяет поведение объекта, сохраняя его существующий интерфейс.

Оба шаблона используются для повышения гибкости и повторного использования кода, но их применение зависит от того, нужно ли вам адаптировать интерфейсы или расширять функциональность объектов.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Composite`, использование для организации древовидной структуры

`Composite` (Компоновщик) — это структурный шаблон проектирования, который позволяет вам сгруппировать объекты в древовидную структуру и работать с этими объектами единообразно. Этот шаблон помогает вам структурировать сложные объекты, состоящие из составных частей, таким образом, чтобы и отдельные объекты, и их группы обрабатывались одинаково.

`Composite` полезен, когда нужно работать с иерархическими структурами, такими как дерево, где узлы могут быть как конечными элементами (листьями), так и контейнерами для других элементов.

### Примеры, где может использоваться `Composite`:
* Файловые системы, где и файлы, и папки могут быть обработаны одинаково.
* Структура графических объектов, таких как группы и отдельные элементы на холсте.
* Организация меню и подменю в пользовательских интерфейсах.

### Ключевые компоненты:
1. `Component` — интерфейс или абстрактный класс, который определяет операции для как листьев, так и контейнеров.
2. `Leaf` — класс, представляющий конечные объекты (листья) в древовидной структуре, не имеющие дочерних элементов.
3. `Composite` — класс, представляющий контейнеры для других объектов, которые могут содержать как листья, так и другие контейнеры (подобно узлам дерева).

### Пример использования `Composite` в `Java` для организации файловой системы
Предположим, у нас есть структура файловой системы, где папки могут содержать как файлы, так и другие папки. И файлы, и папки должны поддерживать метод `showDetails()`, который выводит информацию о них.

### 1. Определение интерфейса `Component`:
```java
interface FileSystemComponent {
    void showDetails();
}
```

### 2. Класс `Leaf`, представляющий файл:
```java
class File implements FileSystemComponent {
    private String name;

    public File(String name) {
        this.name = name;
    }

    @Override
    public void showDetails() {
        System.out.println("File: " + name);
    }
}
```

### 3. Класс `Composite`, представляющий папку:
```java
import java.util.ArrayList;
import java.util.List;

class Directory implements FileSystemComponent {
    private String name;
    private List<FileSystemComponent> components = new ArrayList<>();

    public Directory(String name) {
        this.name = name;
    }

    // Добавляем компонент (файл или папку)
    public void addComponent(FileSystemComponent component) {
        components.add(component);
    }

    // Удаляем компонент
    public void removeComponent(FileSystemComponent component) {
        components.remove(component);
    }

    @Override
    public void showDetails() {
        System.out.println("Directory: " + name);
        for (FileSystemComponent component : components) {
            component.showDetails();
        }
    }
}
```

### 4. Пример использования:
```java
public class CompositePatternDemo {
    public static void main(String[] args) {
        // Создаем файлы
        FileSystemComponent file1 = new File("File1.txt");
        FileSystemComponent file2 = new File("File2.doc");
        FileSystemComponent file3 = new File("File3.jpg");

        // Создаем директории
        Directory dir1 = new Directory("Documents");
        Directory dir2 = new Directory("Pictures");
        Directory root = new Directory("Root");

        // Добавляем файлы в директории
        dir1.addComponent(file1);
        dir1.addComponent(file2);
        dir2.addComponent(file3);

        // Добавляем директории в корневую директорию
        root.addComponent(dir1);
        root.addComponent(dir2);

        // Показываем структуру файловой системы
        root.showDetails();
    }
}
```
### Вывод программы:
```mathematica
Directory: Root
Directory: Documents
File: File1.txt
File: File2.doc
Directory: Pictures
File: File3.jpg
```
### Объяснение:
1. FileSystemComponent — это интерфейс (или абстрактный класс), который определяет общий метод showDetails(), который должны реализовать как файлы, так и папки.
2. File — это конечный элемент структуры (лист), который представляет файл в файловой системе. Он реализует метод showDetails(), чтобы вывести название файла.
3. Directory — это контейнер (композит), который может содержать как файлы, так и другие директории. Он реализует метод showDetails(), чтобы вывести информацию о себе и о каждом компоненте внутри себя.
4. addComponent() и removeComponent() в классе Directory позволяют динамически добавлять и удалять компоненты, такие как файлы или другие папки.

### Преимущества использования `Composite`:
1. Унификация операций: Обрабатываете отдельные объекты (листья) и их композиции (узлы) одинаково, благодаря общему интерфейсу `Component`.

2. Простота работы с иерархическими структурами: Легко работать с объектами, организованными в деревья, например, файловые системы, графические структуры, организационные диаграммы и т.д.

3. Расширяемость: Легко добавлять новые типы компонентов (листьев или контейнеров), не изменяя существующую структуру.

### Недостатки:
1. Усложнение кода: Если структура иерархии сложна, это может привести к усложнению реализации иерархии классов.

2. Не всегда подходит: Composite эффективен в случае древовидных структур, но может быть избыточен, если структура проста или требует других подходов.

Шаблон `Composite` очень удобен для представления и работы с иерархическими структурами и часто используется в таких областях, как файловые системы, графические интерфейсы, организационные структуры и другие подобные сценарии.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Proxy`, контроль доступа к объекту

`Proxy` (Прокси) — это структурный шаблон проектирования, который предоставляет суррогат или заместителя для другого объекта, чтобы контролировать доступ к нему. `Proxy` создаёт объект-заместитель, который содержит ссылку на реальный объект и управляет доступом к нему, добавляя дополнительную функциональность, такую как контроль доступа, кэширование, отложенную загрузку, логирование и т.д.

Прокси обычно используется, когда прямой доступ к объекту может быть небезопасным, ресурсоёмким или нежелательным.

### Как `Proxy` контролирует доступ к объекту?
`Proxy` может контролировать доступ к объекту следующим образом:

1. Управление доступом: Ограничение доступа к объекту в зависимости от условий, таких как права пользователя или состояние объекта.
2. Отложенная инициализация (Lazy Initialization): Реальный объект создаётся только при необходимости, что позволяет экономить ресурсы, если объект не всегда нужен.
3. Кэширование: Прокси может кэшировать результаты обращения к объекту, чтобы повторные вызовы были быстрее.
4. Логирование: Прокси может вести журнал вызовов методов объекта или их параметров для мониторинга или отладки.
5. Защита: Прокси может выполнять проверки безопасности перед тем, как позволить доступ к объекту.

### Различные типы `Proxy`:
1. Virtual Proxy (Виртуальный прокси): Используется для отложенной загрузки ресурсоёмких объектов. Объект создаётся только тогда, когда он действительно нужен.

    * Пример: Ленивая инициализация больших изображений в приложении, когда они загружаются только по запросу пользователя.

2. Protection Proxy (Защитный прокси): Контролирует доступ к объекту на основании прав доступа пользователя. Прокси может проверять, имеет ли пользователь достаточные права для выполнения операций с объектом.

    * Пример: Ограничение доступа к админским функциям системы на основе ролей пользователя.

3. Remote Proxy (Удалённый прокси): Используется для обращения к удалённым объектам, которые находятся в другой среде выполнения, возможно, на другом сервере. Прокси берёт на себя коммуникацию с удалённым объектом.

    * Пример: Вызов методов удалённого сервиса через сетевое соединение.

4. Cache Proxy (Кэш-прокси): Кэширует результаты вызовов методов объекта и возвращает кэшированные результаты при последующих вызовах.

    * Пример: Прокси для доступа к базе данных, который кэширует результаты запросов для повышения производительности.

5. Logging Proxy (Логирующий прокси): Добавляет функциональность логирования при каждом вызове методов реального объекта. Это может быть полезно для отладки или аудита.

    * Пример: Прокси, который записывает в журнал все вызовы методов и их параметры.

6. Smart Proxy (Умный прокси): Выполняет дополнительные действия при доступе к объекту, такие как отслеживание числа ссылок, синхронизация или освобождение ресурсов.

### Пример использования `Proxy` в `Java` (`Virtual Proxy`)

Предположим, у нас есть класс `Image`, который представляет изображение. Загрузка изображения может быть ресурсоёмкой операцией, поэтому мы можем использовать `Virtual Proxy`, чтобы загружать изображение только тогда, когда оно действительно требуется.

1. Интерфейс `Image`:
```java
interface Image {
    void display();
}
```

2. Реальный класс `RealImage`, который загружает изображение:
```java
class RealImage implements Image {
    private String filename;

    public RealImage(String filename) {
        this.filename = filename;
        loadImageFromDisk();
    }

    private void loadImageFromDisk() {
        System.out.println("Загрузка изображения: " + filename);
    }

    @Override
    public void display() {
        System.out.println("Отображение изображения: " + filename);
    }
}
```

3. Прокси-класс `ProxyImage`, который контролирует доступ к реальному объекту:
```java
class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;

    public ProxyImage(String filename) {
        this.filename = filename;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(filename);  // Отложенная загрузка
        }
        realImage.display();
    }
}
```

4. Пример использования:
```java
public class ProxyPatternDemo {
    public static void main(String[] args) {
        Image image1 = new ProxyImage("image1.jpg");
        Image image2 = new ProxyImage("image2.png");

        // Изображение загружается только при первом вызове display()
        System.out.println("Первый вызов display для image1:");
        image1.display();  // Загружается и отображается image1.jpg

        System.out.println("\nВторой вызов display для image1:");
        image1.display();  // Только отображается, загрузка не выполняется

        System.out.println("\nПервый вызов display для image2:");
        image2.display();  // Загружается и отображается image2.png
    }
}
```

Вывод программы:
```bash
Первый вызов display для image1:
Загрузка изображения: image1.jpg
Отображение изображения: image1.jpg

Второй вызов display для image1:
Отображение изображения: image1.jpg

Первый вызов display для image2:
Загрузка изображения: image2.png
Отображение изображения: image2.png
```

### Объяснение:
1. `ProxyImage` — это класс-прокси, который содержит ссылку на реальный объект `RealImage`. Он контролирует доступ к нему и загружает изображение только тогда, когда это необходимо (при первом вызове метода `display()`).

2. `RealImage` — это класс, представляющий реальный объект, который загружает изображение с диска.

3. `Lazy Initialization` (Отложенная загрузка) — в момент создания прокси изображение не загружается. Загрузка происходит только при первом вызове метода `display()`.

### Преимущества использования `Proxy`:
1. Контроль доступа: Прокси может ограничить доступ к объекту в зависимости от условий или прав доступа.
2. Отложенная инициализация: Ресурсоёмкие операции, такие как загрузка данных или создание объектов, могут выполняться только при необходимости.
3. Кэширование: Прокси может кэшировать результаты работы объекта, повышая производительность.
4. Мониторинг: Прокси может вести логирование или отслеживание вызовов методов реального объекта.
5. Защита от нежелательных действий: Прокси может предотвратить нежелательные действия или защитить объект от неправильного использования.

### Недостатки:
1. `Сложность`: Прокси добавляет уровень абстракции и может усложнить код, особенно если прокси-классы становятся слишком сложными.
2. `Задержки`: Использование прокси может вызвать дополнительные задержки, если выполнение операций через прокси становится медленнее, чем при прямом доступе к объекту.

### Итог:
Шаблон `Proxy` предоставляет гибкий механизм для управления доступом к объектам, выполнения отложенных операций, кэширования и других действий. Прокси может быть полезен в системах с удалённым доступом, защите данных или при работе с ресурсоёмкими операциями.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Facade`, использование для упрощения взаимодействия с комплексными системами

`Facade` — это структурный шаблон проектирования, который предоставляет унифицированный интерфейс для работы с подсистемами, упрощая взаимодействие с ними. Шаблон скрывает сложную логику взаимодействия с несколькими классами, предоставляя простой и единый интерфейс для работы с этими классами. Это позволяет клиентскому коду работать с комплексными системами, не погружаясь в детали их реализации.

### Основные идеи шаблона `Facade`:
* Упрощение интерфейса: Клиенту предоставляется простой интерфейс для работы с системой, скрывая все сложные детали её внутреннего устройства.

* Отделение клиента от сложностей системы: Клиент взаимодействует только с фасадом, не зная о деталях реализации внутренних компонентов.

* Инкапсуляция взаимодействия между компонентами: Фасад выступает в роли посредника, который управляет и координирует взаимодействие между классами подсистемы.

### Когда использовать `Facade`:
1. Когда система состоит из множества взаимосвязанных классов и их использование становится сложным.

2. Когда нужно отделить клиентский код от сложных деталей внутренней системы.

3. Когда требуется упростить процесс взаимодействия с различными компонентами системы, предоставив единый интерфейс.

4. Когда необходимо уменьшить зависимость между клиентом и подсистемой, делая систему более гибкой и удобной для расширения.

### Пример использования `Facade` в `Java`
Представим, что мы разрабатываем систему для управления мультимедиа (видео, аудио, субтитры и т.д.). Каждая из этих подсистем (видео, аудио, субтитры) имеет свои классы и методы для управления воспроизведением. Использование всех этих классов может быть сложным, поэтому мы создадим `Facade`, который будет предоставлять упрощённый интерфейс для работы с мультимедийной системой.

### 1. Подсистемы: Классы для работы с видео, аудио и субтитрами
Класс для работы с видео:
```java
class VideoPlayer {
    public void loadVideo(String videoFile) {
        System.out.println("Загрузка видео: " + videoFile);
    }

    public void playVideo() {
        System.out.println("Воспроизведение видео");
    }

    public void stopVideo() {
        System.out.println("Остановка видео");
    }
}
```

Класс для работы с аудио:
```java
class AudioPlayer {
    public void loadAudio(String audioFile) {
        System.out.println("Загрузка аудио: " + audioFile);
    }

    public void playAudio() {
        System.out.println("Воспроизведение аудио");
    }

    public void stopAudio() {
        System.out.println("Остановка аудио");
    }
}
```

Класс для работы с субтитрами:
```java
class SubtitlesManager {
    public void loadSubtitles(String subtitlesFile) {
        System.out.println("Загрузка субтитров: " + subtitlesFile);
    }

    public void showSubtitles() {
        System.out.println("Показ субтитров");
    }

    public void hideSubtitles() {
        System.out.println("Скрытие субтитров");
    }
}
```
### 2. Класс `Facade` — мультимедийный плеер

Теперь создадим класс `Facade`, который предоставит простой интерфейс для работы с видео, аудио и субтитрами.

```java
class MediaFacade {
    private VideoPlayer videoPlayer;
    private AudioPlayer audioPlayer;
    private SubtitlesManager subtitlesManager;

    public MediaFacade() {
        this.videoPlayer = new VideoPlayer();
        this.audioPlayer = new AudioPlayer();
        this.subtitlesManager = new SubtitlesManager();
    }

    public void playMedia(String videoFile, String audioFile, String subtitlesFile) {
        videoPlayer.loadVideo(videoFile);
        audioPlayer.loadAudio(audioFile);
        subtitlesManager.loadSubtitles(subtitlesFile);

        videoPlayer.playVideo();
        audioPlayer.playAudio();
        subtitlesManager.showSubtitles();
    }

    public void stopMedia() {
        videoPlayer.stopVideo();
        audioPlayer.stopAudio();
        subtitlesManager.hideSubtitles();
    }
}
```
### 3. Использование Facade в клиентском коде
Теперь клиентский код будет взаимодействовать с системой мультимедиа через `Facade`, который скрывает всю сложность взаимодействия с подсистемами.

```java
public class FacadePatternDemo {
    public static void main(String[] args) {
        MediaFacade mediaFacade = new MediaFacade();

        // Запускаем мультимедиа (видео, аудио, субтитры) через фасад
        mediaFacade.playMedia("video.mp4", "audio.mp3", "subtitles.srt");

        // Останавливаем мультимедиа
        mediaFacade.stopMedia();
    }
}
```
Вывод программы:
```less
Загрузка видео: video.mp4
Загрузка аудио: audio.mp3
Загрузка субтитров: subtitles.srt
Воспроизведение видео
Воспроизведение аудио
Показ субтитров
Остановка видео
Остановка аудио
Скрытие субтитров
```

### Объяснение:
1. Подсистемы: Это классы `VideoPlayer`, `AudioPlayer` и `SubtitlesManager`, которые представляют разные компоненты мультимедийной системы.

2. Facade: Класс `MediaFacade` упрощает взаимодействие с подсистемами, предоставляя клиенту единый интерфейс для управления мультимедиа (видео, аудио и субтитры).

3. Клиент: Клиент использует `MediaFacade` для запуска и остановки мультимедийного контента. Клиентский код не знает деталей того, как работает каждая подсистема, так как вся сложность скрыта за фасадом.

### Преимущества использования `Facade`:
1. Упрощение использования: Клиенты взаимодействуют с системой через единый интерфейс, не погружаясь в детали работы каждой подсистемы.

2. Изоляция подсистем: Клиентский код не зависит от реализации подсистем. Это снижает связанность между компонентами системы.

3. Гибкость: Легко модифицировать и расширять подсистемы, не затрагивая клиентский код, так как взаимодействие с ними происходит через фасад.

4. Поддержка принципа единой ответственности: Фасад берет на себя ответственность за координацию взаимодействия между подсистемами, освобождая клиентский код от этой задачи.

### Недостатки `Facade`:
1. Ограниченная функциональность: Фасад может ограничивать доступ к некоторым специфическим функциям подсистем. Если нужно использовать весь функционал, возможно, придётся напрямую обращаться к подсистемам.

2. Добавление дополнительного уровня абстракции: В некоторых случаях использование фасада может привести к добавлению излишней абстракции, особенно если подсистемы уже достаточно просты для использования.

### Итог:
Шаблон `Facade` — это отличный способ упростить работу с комплексными системами, предоставляя удобный и единый интерфейс для взаимодействия с ними. Он помогает отделить клиентский код от деталей реализации подсистем, делая архитектуру системы более гибкой и легко изменяемой.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Bridge`, как он помогает отделить абстракцию от её реализации

`Bridge` (Мост) — это структурный шаблон проектирования, который разделяет абстракцию (интерфейс) и её реализацию таким образом, чтобы они могли изменяться независимо друг от друга. Шаблон `Bridge` помогает справиться со сложностью и увеличивает гибкость системы, позволяя динамически изменять реализации без изменения кода, который использует абстракцию.

### Ключевая идея:
* `Абстракция` — это часть программы, которая определяет, что нужно делать, но не как это должно быть сделано.

* `Реализация` — это конкретное поведение или действия, которые выполняют функции, описанные абстракцией.

`Bridge` позволяет изменять как саму абстракцию, так и её реализацию независимо друг от друга. Это особенно полезно, когда вам нужно создать несколько вариантов абстракции и их реализаций, которые должны работать вместе.

### Пример проблемы:
Без `Bridge` расширение абстракции и реализации может привести к необходимости создавать огромное количество классов. Например, если у вас есть две абстракции (например, фигуры: Круг и Квадрат) и две реализации (например, способы рисования: Рисование через `OpenGL` и Рисование через `DirectX`), без `Bridge` вам придется создать 4 класса для каждой комбинации: `OpenGLCircle`, `OpenGLSquare`, `DirectXCircle`, `DirectXSquare`. Это называется картезиальным взрывом классов.

### Как Bridge решает эту проблему?
`Bridge` позволяет разделить абстракцию (например, фигуру) и её реализацию (например, способ рисования), что позволяет легко добавлять новые фигуры или новые способы рисования, не изменяя существующий код. Абстракция будет ссылаться на интерфейс или абстрактный класс реализации, который можно легко менять, не меняя саму абстракцию.

### Пример использования `Bridge` в `Java`
### 1. Абстракция: Фигура (Shape)
Создадим абстрактный класс `Shape`, который содержит ссылку на интерфейс реализации рисования `DrawAPI`. Таким образом, конкретные фигуры будут делегировать работу по рисованию объектам, которые реализуют этот интерфейс.

Интерфейс `DrawAPI` для рисования:
```java
interface DrawAPI {
    void drawCircle(int radius, int x, int y);
}
```
#### Реализация интерфейса `DrawAPI`:
```java
class OpenGLAPI implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Рисуем круг через OpenGL с радиусом " + radius + " и координатами (" + x + ", " + y + ")");
    }
}

class DirectXAPI implements DrawAPI {
    @Override
    public void drawCircle(int radius, int x, int y) {
        System.out.println("Рисуем круг через DirectX с радиусом " + radius + " и координатами (" + x + ", " + y + ")");
    }
}
```

#### Абстрактный класс `Shape`:
```java
abstract class Shape {
    protected DrawAPI drawAPI;

    protected Shape(DrawAPI drawAPI) {
        this.drawAPI = drawAPI;
    }

    public abstract void draw();
}
```
#### Конкретная фигура `Circle`:
```java
class Circle extends Shape {
    private int radius;
    private int x;
    private int y;

    public Circle(int radius, int x, int y, DrawAPI drawAPI) {
        super(drawAPI);
        this.radius = radius;
        this.x = x;
        this.y = y;
    }

    @Override
    public void draw() {
        drawAPI.drawCircle(radius, x, y);  // Делегирование работы по рисованию реализации
    }
}
```
### 2. Использование `Bridge`:
Теперь мы можем использовать различные реализации `DrawAPI` с абстракцией `Shape`.

```java
public class BridgePatternDemo {
    public static void main(String[] args) {
        Shape circle1 = new Circle(10, 100, 100, new OpenGLAPI());
        Shape circle2 = new Circle(20, 200, 200, new DirectXAPI());

        circle1.draw();  // Рисуем круг через OpenGL
        circle2.draw();  // Рисуем круг через DirectX
    }
}
```

### Вывод программы:
```scss
Рисуем круг через OpenGL с радиусом 10 и координатами (100, 100)
Рисуем круг через DirectX с радиусом 20 и координатами (200, 200)
```

### Объяснение:
1. Абстракция Shape: Это абстрактный класс, который содержит ссылку на объект реализации DrawAPI. Абстракция не знает, как конкретно выполняется рисование, она только делегирует эту работу объекту реализации.

2. Реализация DrawAPI: Это интерфейс, который реализуется классами OpenGLAPI и DirectXAPI. Каждый из этих классов предоставляет свою реализацию метода рисования круга.

3. Класс Circle: Это конкретная фигура, которая наследуется от Shape и использует объект реализации для рисования.

4. Клиент: Теперь клиентский код может создавать объекты фигур и задавать им способ рисования (например, через OpenGL или DirectX). Реализация способа рисования может меняться независимо от абстракции.

### Преимущества использования `Bridge`:
1. Разделение абстракции и реализации: Шаблон позволяет изменять и абстракцию, и реализацию независимо друг от друга. Можно добавлять новые абстракции (фигуры) или реализации (способы рисования) без необходимости изменения существующего кода.

2. Уменьшение количества классов: Вместо создания большого числа подклассов для каждой комбинации абстракции и реализации, шаблон Bridge позволяет использовать комбинации объектов.

3. Упрощение расширения: Легко добавлять новые реализации или абстракции без изменения существующего кода.

### Недостатки `Bridge`:
1. Усложнение структуры: Введение дополнительных классов и интерфейсов может сделать код более сложным для понимания.

2. Нужно заранее планировать: Этот шаблон полезен, когда действительно необходимо разделить абстракцию и реализацию. В простых случаях его применение может быть излишним.

### Когда использовать `Bridge`:
1. Когда требуется разделить абстракцию и реализацию для независимого их изменения.
2. Когда нужно избежать большого количества подклассов для каждой комбинации абстракции и реализации.
3. Когда одна абстракция может иметь несколько возможных реализаций, которые могут изменяться независимо от абстракции.

`Bridge` — это мощный инструмент для создания гибких и масштабируемых архитектур, особенно в системах, где абстракции и реализации могут часто меняться и расширяться.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Flyweight`, уменьшение количества объектов в приложении

`Flyweight` — это структурный шаблон проектирования, который используется для минимизации потребления памяти при работе с большим количеством мелких объектов. Шаблон позволяет разделять общее состояние объектов, уменьшая избыточные данные и избегая создания большого количества однотипных объектов. Он фокусируется на повторном использовании существующих объектов вместо создания новых, что особенно полезно при работе с большими объемами данных или в системах с ограниченными ресурсами.

### Основная идея `Flyweight`:
* Разделение состояния: Состояние объекта делится на внутреннее (инвариантное, общее для всех объектов) и внешнее (уникальное для каждого объекта). Объекты хранят только внутреннее состояние, а внешнее передается им извне.

* Повторное использование объектов: Вместо создания множества объектов с одинаковым внутренним состоянием, `Flyweight` позволяет использовать один объект для нескольких экземпляров, разделяя внутреннее состояние между ними.

### Когда использовать `Flyweight`:
1. Когда приложение должно работать с большим количеством однотипных объектов.
2. Когда объекты содержат много общего состояния, которое можно разделить между ними.
3. Когда требуется уменьшить нагрузку на память или повысить производительность за счет уменьшения количества создаваемых объектов.

### Пример использования `Flyweight`:
Предположим, у нас есть графическое приложение, которое работает с большим количеством персонажей (игроков) в игре. Каждый персонаж может иметь определённый цвет, тип (например, воин, маг и т.д.) и координаты. Тип персонажа и цвет являются повторяющимися характеристиками, а координаты уникальны для каждого персонажа. Мы можем использовать `Flyweight` для того, чтобы избежать создания большого количества объектов для каждого персонажа и экономить память.

#### 1. Определим интерфейс `Player`:
```java
interface Player {
    void assignWeapon(String weapon);
    void mission();
}
```
#### 2. Классы-легковесы для различных типов игроков:
```java
// Конкретный класс игрока "Террорист"
class Terrorist implements Player {
    // Внутреннее состояние (разделяется между объектами)
    private final String TASK;

    // Внешнее состояние (уникально для каждого объекта)
    private String weapon;

    public Terrorist() {
        TASK = "Планировать взрыв";
    }

    @Override
    public void assignWeapon(String weapon) {
        this.weapon = weapon;
    }

    @Override
    public void mission() {
        System.out.println("Террорист с оружием " + weapon + " | Задача: " + TASK);
    }
}

// Конкретный класс игрока "Контр-террорист"
class CounterTerrorist implements Player {
    // Внутреннее состояние (разделяется между объектами)
    private final String TASK;

    // Внешнее состояние (уникально для каждого объекта)
    private String weapon;

    public CounterTerrorist() {
        TASK = "Разминировать бомбу";
    }

    @Override
    public void assignWeapon(String weapon) {
        this.weapon = weapon;
    }

    @Override
    public void mission() {
        System.out.println("Контр-террорист с оружием " + weapon + " | Задача: " + TASK);
    }
}
```
#### 3. Фабрика `PlayerFactory` для управления объектами-легковесами:
```java
import java.util.HashMap;

class PlayerFactory {
    // Коллекция для хранения созданных объектов-легковесов
    private static HashMap<String, Player> playerMap = new HashMap<>();

    public static Player getPlayer(String type) {
        Player player = null;

        // Если объект этого типа уже существует, возвращаем его
        if (playerMap.containsKey(type)) {
            player = playerMap.get(type);
        } else {
            // Если объект не существует, создаем его
            switch (type) {
                case "Terrorist":
                    System.out.println("Создаём террориста.");
                    player = new Terrorist();
                    break;
                case "CounterTerrorist":
                    System.out.println("Создаём контр-террориста.");
                    player = new CounterTerrorist();
                    break;
                default:
                    throw new IllegalArgumentException("Неизвестный тип игрока.");
            }
            // Сохраняем объект в коллекции
            playerMap.put(type, player);
        }
        return player;
    }
}
```
#### 4. Использование шаблона `Flyweight`:
```java
public class FlyweightPatternDemo {
    private static String[] playerTypes = {"Terrorist", "CounterTerrorist"};
    private static String[] weapons = {"AK-47", "M16", "Desert Eagle"};

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            // Получаем игрока (из фабрики или создаем нового)
            Player player = PlayerFactory.getPlayer(getRandomPlayerType());
            
            // Назначаем оружие (уникальное для каждого игрока)
            player.assignWeapon(getRandomWeapon());

            // Выполняем задачу игрока
            player.mission();
        }
    }

    public static String getRandomPlayerType() {
        return playerTypes[(int) (Math.random() * playerTypes.length)];
    }

    public static String getRandomWeapon() {
        return weapons[(int) (Math.random() * weapons.length)];
    }
}
```
#### Вывод программы:
```python
Создаём террориста.
Террорист с оружием AK-47 | Задача: Планировать взрыв
Создаём контр-террориста.
Контр-террорист с оружием M16 | Задача: Разминировать бомбу
Террорист с оружием Desert Eagle | Задача: Планировать взрыв
Контр-террорист с оружием AK-47 | Задача: Разминировать бомбу
...
```
### Описание:
1. Flyweight (Легковес): Игроки Terrorist и CounterTerrorist — это объекты-легковесы, которые разделяют общее состояние (задача). Эти объекты создаются только один раз и повторно используются для других игроков.

2. Внутреннее состояние (Shared State): Это часть состояния объекта, которая может быть разделена между объектами (например, задача для террориста или контр-террориста).

3. Внешнее состояние (Unique State): Это часть состояния объекта, которая является уникальной для каждого объекта (например, оружие, которое может быть разным у каждого игрока).

4. PlayerFactory: Фабрика отвечает за создание объектов-легковесов. Если объект с определённым внутренним состоянием уже существует, он возвращает его, избегая создания новых объектов.

### Преимущества `Flyweight`:
1. Экономия памяти: Повторное использование объектов с общим внутренним состоянием уменьшает количество создаваемых объектов, что особенно полезно при работе с большими объемами данных или ресурсов.

2. Повышение производительности: За счёт уменьшения количества создаваемых объектов уменьшается нагрузка на память и сборщик мусора.

3. Гибкость: Внешнее состояние передаётся объекту во время выполнения, что позволяет изменять его без создания новых объектов.

### Недостатки `Flyweight`:
1. Повышенная сложность: Разделение состояния на внутреннее и внешнее может усложнить код, так как нужно управлять разными аспектами состояния.

2. Не все объекты подходят для Flyweight: Если объект имеет очень много уникальных свойств, применение Flyweight не даст значительного выигрыша в производительности.

### Когда использовать `Flyweight`:
1. Когда у вас есть много однотипных объектов, которые содержат общие данные.

2. Когда создание большого количества объектов потребляет много ресурсов, и вы хотите уменьшить нагрузку на память.

3. Когда вы можете разделить состояние объекта на общую и уникальную части.

`Flyweight` — это мощный инструмент для оптимизации памяти и производительности, особенно в приложениях, где требуется создание множества однотипных объектов с похожим состоянием.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Chain of Responsibility`, передача запроса по цепочке объектов

`Chain of Responsibility` — это поведенческий шаблон проектирования, который позволяет передавать запрос по цепочке обработчиков, где каждый обработчик решает, обработать запрос или передать его дальше по цепочке. Таким образом, создаётся динамическая последовательность объектов-обработчиков, где каждый может обработать запрос либо делегировать его следующему обработчику.

### Основная идея:
* Запрос передаётся по цепочке обработчиков до тех пор, пока один из них не сможет его обработать.

* Каждый обработчик может либо обработать запрос, либо передать его следующему по цепочке.

* Этот шаблон позволяет уменьшить связанность между отправителем запроса и его обработчиками.

### Когда использовать `Chain of Responsibility`:
1. Когда требуется передать запрос через динамически формируемую цепочку обработчиков, и вы не хотите жестко связывать отправителя с конкретным обработчиком.

2. Когда несколько объектов могут обработать запрос, и требуется определить, кто это сделает на этапе выполнения программы.

3. Когда нужно дать возможность нескольким объектам обработать запрос, но при этом каждый объект-обработчик должен решить, обработать ли запрос самостоятельно или передать его дальше.

### Пример использования `Chain of Responsibility`
Предположим, что у нас есть система логирования, где разные уровни логов (информационные, предупреждения и ошибки) должны обрабатываться разными объектами. Например, информационные логи могут обрабатываться одним объектом, предупреждения — другим, а ошибки — третьим.

#### 1. Определим интерфейс обработчика:
```java
abstract class Logger {
    public static int INFO = 1;
    public static int WARNING = 2;
    public static int ERROR = 3;

    protected int level;

    // Следующий обработчик в цепочке
    protected Logger nextLogger;

    public void setNextLogger(Logger nextLogger) {
        this.nextLogger = nextLogger;
    }

    public void logMessage(int level, String message) {
        if (this.level <= level) {
            write(message);
        }
        if (nextLogger != null) {
            nextLogger.logMessage(level, message);
        }
    }

    protected abstract void write(String message);
}
```

#### 2. Конкретные классы обработчиков:
#### Обработчик для информационных сообщений:
```java
class InfoLogger extends Logger {
    public InfoLogger(int level) {
        this.level = level;
    }

    @Override
    protected void write(String message) {
        System.out.println("INFO: " + message);
    }
}
```
#### Обработчик для предупреждений:
```java
class WarningLogger extends Logger {
    public WarningLogger(int level) {
        this.level = level;
    }

    @Override
    protected void write(String message) {
        System.out.println("WARNING: " + message);
    }
}
```
#### Обработчик для ошибок:
```java
class ErrorLogger extends Logger {
    public ErrorLogger(int level) {
        this.level = level;
    }

    @Override
    protected void write(String message) {
        System.out.println("ERROR: " + message);
    }
}
```

#### 3. Настройка цепочки логгера:
Мы можем настроить цепочку таким образом, чтобы сообщения передавались от одного обработчика к другому в зависимости от их уровня.

```java
public class ChainPatternDemo {
    private static Logger getChainOfLoggers() {
        // Создаем обработчики разных уровней
        Logger errorLogger = new ErrorLogger(Logger.ERROR);
        Logger warningLogger = new WarningLogger(Logger.WARNING);
        Logger infoLogger = new InfoLogger(Logger.INFO);

        // Настраиваем цепочку
        infoLogger.setNextLogger(warningLogger);
        warningLogger.setNextLogger(errorLogger);

        return infoLogger; // Возвращаем начало цепочки
    }

    public static void main(String[] args) {
        Logger loggerChain = getChainOfLoggers();

        // Информационное сообщение
        loggerChain.logMessage(Logger.INFO, "Это информационное сообщение.");

        // Предупреждение
        loggerChain.logMessage(Logger.WARNING, "Это предупреждение.");

        // Ошибка
        loggerChain.logMessage(Logger.ERROR, "Это ошибка.");
    }
}
```

#### Вывод программы:
```makefile
INFO: Это информационное сообщение.
WARNING: Это предупреждение.
ERROR: Это ошибка.
```

### Объяснение:
1. Абстрактный класс Logger: Этот класс содержит логику для передачи запросов дальше по цепочке. В методе logMessage проверяется уровень запроса и, если текущий объект может обработать запрос, вызывается метод write. Если объект не может обработать запрос, он передаёт его следующему обработчику.

2. Конкретные обработчики (InfoLogger, WarningLogger, ErrorLogger): Каждый из этих классов реализует метод write, который отвечает за обработку сообщений соответствующего уровня. Например, InfoLogger обрабатывает информационные сообщения, а ErrorLogger — ошибки.

3. Цепочка: В методе getChainOfLoggers мы создаём цепочку из трёх логгеров. Цепочка настроена так, что информационные сообщения будут обрабатываться первым логгером, предупреждения вторым, а ошибки третьим.

4. Передача запроса: Когда мы вызываем метод logMessage, запрос передаётся по цепочке обработчиков. Каждый обработчик проверяет, может ли он обработать запрос. Если может — обрабатывает его, если нет — передаёт следующему по цепочке.

### Преимущества `Chain of Responsibility`:
1. Слабая связанность: Отправитель и обработчик запроса слабо связаны друг с другом. Отправителю не нужно знать, какой конкретно обработчик выполнит запрос.

2. Гибкость: Легко добавлять новые обработчики или изменять порядок их вызова без необходимости изменения существующего кода.

3. Устранение жесткой зависимости: Этот шаблон позволяет отправителю запроса не зависеть от конкретных классов обработчиков, что делает систему более гибкой.

### Недостатки `Chain of Responsibility`:
1. Нет гарантии обработки запроса: Если ни один из обработчиков не может обработать запрос, он может остаться необработанным.

2. Сложность трассировки: Если цепочка обработчиков велика, может быть сложно отследить, какой из обработчиков обработал запрос.

3. Производительность: В некоторых случаях передача запроса по длинной цепочке может вызвать задержки в обработке, особенно если много обработчиков не могут обработать запрос.

### Когда использовать `Chain of Responsibility`:
1. Когда нужно передавать запрос через несколько обработчиков и неважно, кто из них его выполнит.

2. Когда несколько обработчиков могут выполнить одну и ту же задачу, и решение о том, какой обработчик будет использоваться, должно приниматься во время выполнения программы.

3. Когда вы хотите избежать прямого связывания отправителя запроса с его обработчиками, чтобы сделать систему более гибкой и легко расширяемой.

`Chain of Responsibility` — это мощный инструмент, который позволяет гибко управлять запросами, передавая их через цепочку обработчиков, и особенно полезен в ситуациях, когда точный обработчик запроса неизвестен заранее или может изменяться во время выполнения программы.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Command`, инкапсулирование команд в объекте

`Command` (Команда) — это поведенческий шаблон проектирования, который инкапсулирует запрос, действие или операцию в виде объекта. Этот объект содержит всю информацию, необходимую для выполнения команды, включая метод, аргументы и получателя (объект, на котором команда должна быть выполнена). Шаблон `Command` позволяет откладывать, сохранять, регистрировать и отменять операции.

### Основная идея:
`Command` превращает действие в объект. Это позволяет:

1. Инкапсулировать команды, делая их независимыми от вызывающего кода.
2. Сохранять команды для последующего выполнения, например, для отложенных операций.
3. Реализовать отмену и повтор команд (undo/redo).
4. Легко добавлять новые команды без изменения существующего кода.

### Когда использовать `Command`:
1. Когда нужно передать в качестве параметра команду (например, кнопку в графическом интерфейсе).
2. Когда необходимо поддерживать операции отмены (undo) и повтора (redo).
3. Когда требуется сохранять команды для отложенного выполнения или для их записи в журнал.
4. Когда нужно декомпозировать сложные запросы в объекты.

### Пример использования `Command`
Рассмотрим пример с управлением бытовыми приборами (например, лампой или телевизором), где мы можем включать и выключать их по командам.

#### 1. Интерфейс команды `Command`:
Каждая конкретная команда будет реализовывать этот интерфейс и выполнять своё действие.

```java
interface Command {
    void execute();
    void undo();
}
```
#### 2. Класс `Receiver` — Лампа:
Это получатель (`Receiver`), на котором будет выполняться команда.

```java
class Light {
    public void turnOn() {
        System.out.println("Лампа включена.");
    }

    public void turnOff() {
        System.out.println("Лампа выключена.");
    }
}
```
#### 3. Конкретные команды для управления лампой:
Команды для включения и выключения лампы инкапсулируют операции в объекты.

#### Команда для включения лампы:
```java
class TurnOnLightCommand implements Command {
    private Light light;

    public TurnOnLightCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOn();
    }

    @Override
    public void undo() {
        light.turnOff();
    }
}
```
#### Команда для выключения лампы:
```java
class TurnOffLightCommand implements Command {
    private Light light;

    public TurnOffLightCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.turnOff();
    }

    @Override
    public void undo() {
        light.turnOn();
    }
}
```
### 4. Класс `Invoker` — пульт управления:
`Invoker` — это объект, который вызывает команды. Он не знает, как конкретно выполняются команды, он просто вызывает метод `execute()`.

```java
class RemoteControl {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void pressButton() {
        command.execute();
    }

    public void pressUndo() {
        command.undo();
    }
}
```
#### 5. Использование `Command`:
Теперь создадим лампу, команды для управления ею и пульт, чтобы выполнить команды.

```java
public class CommandPatternDemo {
    public static void main(String[] args) {
        // Создаем объект лампы
        Light light = new Light();

        // Создаем команды для включения и выключения лампы
        Command turnOn = new TurnOnLightCommand(light);
        Command turnOff = new TurnOffLightCommand(light);

        // Создаем пульт (Invoker)
        RemoteControl remote = new RemoteControl();

        // Включаем лампу
        remote.setCommand(turnOn);
        remote.pressButton();

        // Выключаем лампу
        remote.setCommand(turnOff);
        remote.pressButton();

        // Отмена последнего действия
        remote.pressUndo();
    }
}
```

#### Вывод программы:
```bash
Лампа включена.
Лампа выключена.
Лампа включена.
```

### Объяснение:
1. Command: Команды TurnOnLightCommand и TurnOffLightCommand инкапсулируют конкретные действия (включение и выключение лампы) и предоставляют методы execute() и undo().

2. Receiver: Объект лампы (Light) представляет собой получателя команды. Именно на нём выполняются действия, инкапсулированные в команды.

3. Invoker: Пульт управления (RemoteControl) не знает, что конкретно делают команды, он просто вызывает их. Это позволяет легко менять команды в зависимости от ситуации.

4. Undo: Каждая команда поддерживает метод undo(), который позволяет отменить предыдущее действие.

### Преимущества `Command`:
1. Инкапсуляция операций: Команды инкапсулируют операции в виде объектов. Это упрощает передачу, хранение и управление действиями.

2. Разделение обязанностей: Отправитель (Invoker) не знает, как именно выполняются команды. Он просто вызывает execute() на команде.

3. Упрощение добавления новых команд: Легко добавлять новые команды, не изменяя существующий код. Достаточно создать новый класс, который реализует интерфейс Command.

4. Поддержка отмены и повтора (Undo/Redo): Благодаря методу undo() можно легко реализовать операции отмены.

### Недостатки `Command`:
1. Увеличение числа классов: Каждая новая команда требует создания отдельного класса, что может привести к увеличению числа классов.

2. Иногда избыточен: В простых случаях использование Command может добавить излишнюю сложность, особенно если нужно выполнить одно простое действие.

### Когда использовать `Command`:
1. Когда требуется параметризовать объекты операциями, то есть передавать команды как параметры.

2. Когда нужно поддерживать отмену или повтор операций (undo/redo).

3. Когда необходимо ставить команды в очередь, логировать их или выполнять отложенные команды.

4. Когда нужно декомпозировать сложные операции или запросы в объекты, чтобы сделать их более гибкими и масштабируемыми.

`Command` — это мощный шаблон для работы с операциями в виде объектов. Он помогает инкапсулировать команды, давая возможность сохранять, отменять, передавать и обрабатывать команды независимо от контекста, в котором они были созданы.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Observer`, как реализовать паттерн наблюдателя

`Observer` (Наблюдатель) — это поведенческий шаблон проектирования, который позволяет объектам (наблюдателям) подписываться на изменения состояния другого объекта (наблюдаемого). Когда состояние наблюдаемого объекта изменяется, все подписчики уведомляются об этом автоматически. Это позволяет объектам быть слабо связанными друг с другом: наблюдаемый объект не знает, кто именно за ним следит.

### Основные идеи:
* Наблюдаемый объект (Observable, Subject) — это объект, который поддерживает список подписчиков (наблюдателей) и уведомляет их об изменении своего состояния.

* Наблюдатели (Observers) — это объекты, которые хотят быть уведомленными, когда наблюдаемый объект изменяется.

### Когда использовать `Observer`:
1. Когда один объект должен автоматически уведомлять другие объекты об изменениях своего состояния.

2. Когда система должна быть расширяемой без сильной связанности между её компонентами.

3. Когда требуется гибкое взаимодействие между объектами, где один объект может влиять на несколько других.

### Реализация `Observer` в `Java` с использованием `java.util.Observable`
До версии `Java 9` в стандартной библиотеке был класс `java.util.Observable` и интерфейс `java.util.Observer`, которые предоставляли встроенную поддержку паттерна Наблюдатель. В последних версиях они были помечены как устаревшие, и рекомендуется использовать собственные реализации шаблона. Однако для примера мы рассмотрим реализацию с использованием этих классов.

### 1. Класс Observable (Наблюдаемый объект):
Это объект, который поддерживает список наблюдателей и уведомляет их об изменениях своего состояния.

#### Пример задачи:
Предположим, что у нас есть класс WeatherStation, который отслеживает изменения температуры. Он уведомляет всех подписчиков (наблюдателей) о том, что температура изменилась.

Класс `WeatherStation` (наблюдаемый объект):
```java
import java.util.Observable;

class WeatherStation extends Observable {
    private float temperature;

    public void setTemperature(float temperature) {
        this.temperature = temperature;
        // Отмечаем, что объект был изменен
        setChanged();
        // Уведомляем всех наблюдателей
        notifyObservers(temperature);
    }

    public float getTemperature() {
        return temperature;
    }
}
```

### 2. Интерфейс `Observer` (Наблюдатель):
Класс `Observer` должен реализовать интерфейс `java.util.Observer` и переопределить метод `update()`, который вызывается при изменении наблюдаемого объекта.

#### Класс `TemperatureDisplay` (наблюдатель):
Этот класс реализует интерфейс `Observer` и будет получать обновления температуры от `WeatherStation`.

```java
import java.util.Observable;
import java.util.Observer;

class TemperatureDisplay implements Observer {
    private float currentTemperature;

    @Override
    public void update(Observable obs, Object arg) {
        if (obs instanceof WeatherStation) {
            this.currentTemperature = (float) arg;
            display();
        }
    }

    public void display() {
        System.out.println("Текущая температура: " + currentTemperature + "°C");
    }
}
```
### 3. Класс `Observer` (дополнительный наблюдатель):
Предположим, что у нас есть другой наблюдатель, который выводит предупреждение, если температура выше определённого значения.

#### Класс `TemperatureWarning` (наблюдатель):
```java
import java.util.Observable;
import java.util.Observer;

class TemperatureWarning implements Observer {
    @Override
    public void update(Observable obs, Object arg) {
        if (obs instanceof WeatherStation) {
            float temperature = (float) arg;
            if (temperature > 30.0) {
                System.out.println("Предупреждение! Высокая температура: " + temperature + "°C");
            }
        }
    }
}
```
### 4. Демонстрация работы:
Теперь создадим объект наблюдаемого класса `WeatherStation`, а также несколько наблюдателей `TemperatureDisplay` и `TemperatureWarning`, которые будут подписаны на обновления температуры.

```java
public class ObserverPatternDemo {
    public static void main(String[] args) {
        // Создаем наблюдаемый объект (WeatherStation)
        WeatherStation weatherStation = new WeatherStation();

        // Создаем два наблюдателя
        TemperatureDisplay display = new TemperatureDisplay();
        TemperatureWarning warning = new TemperatureWarning();

        // Подписываем наблюдателей на обновления от WeatherStation
        weatherStation.addObserver(display);
        weatherStation.addObserver(warning);

        // Изменяем температуру, что вызывает уведомление наблюдателей
        weatherStation.setTemperature(25.0f);
        weatherStation.setTemperature(35.0f);
    }
}
```
#### Вывод программы:
```mathematica
Текущая температура: 25.0°C
Текущая температура: 35.0°C
Предупреждение! Высокая температура: 35.0°C
```
### Объяснение:
1. WeatherStation (Observable) — это наблюдаемый объект, который отслеживает изменения температуры. Когда температура изменяется, объект вызывает методы setChanged() и notifyObservers(), чтобы уведомить всех подписчиков.

2. TemperatureDisplay (Observer) — это наблюдатель, который отображает текущую температуру каждый раз, когда она меняется.

3. TemperatureWarning (Observer) — это другой наблюдатель, который выводит предупреждение, если температура превышает 30°C.

4. Метод addObserver() — наблюдатели подписываются на уведомления о изменениях объекта WeatherStation.

5. Метод notifyObservers() — уведомляет всех подписчиков о том, что температура изменилась.

### Преимущества `Observer`:
1. Слабая связность: Наблюдаемые объекты не знают, кто их наблюдатели, и могут уведомлять любое количество наблюдателей.

2. Гибкость: Легко добавлять и удалять наблюдателей в любое время без изменения кода наблюдаемого объекта.

3. Автоматизация уведомлений: Изменение состояния наблюдаемого объекта автоматически уведомляет всех наблюдателей.

### Недостатки Observer:
1. Проблемы производительности: Если у наблюдаемого объекта много наблюдателей, уведомление всех может стать затратным.

2. Отсутствие контроля над порядком уведомления: Порядок уведомления наблюдателей не всегда определён, что может быть проблемой для некоторых сценариев.

3. Потенциальная сложность отладки: Если изменения вызывают каскадное уведомление множества наблюдателей, это может затруднить отладку и поддержку кода.

### Рекомендации:
Начиная с `Java 9`, использование `java.util.Observable` и `java.util.Observer` считается устаревшим. Рекомендуется реализовывать свой собственный механизм наблюдателя, используя интерфейсы и обработчики событий, так как это обеспечивает большую гибкость и лучше интегрируется с современными подходами.

### Собственная реализация `Observer`:
Если вы хотите использовать более современный подход, вы можете самостоятельно реализовать паттерн `Observer` через собственные интерфейсы `Observable` и `Observer`, что будет аналогично приведённому примеру, но без устаревших классов.

`Observer` — это мощный инструмент для создания систем с динамическими связями, где объекты могут реагировать на изменения состояния друг друга без жёсткой связанности между ними.

[наверх](#шаблоны-проектирования)


## Шаблон `Observer` и шаблон `Pub/Sub`, их архитектурная разница и примеры использования

`Observer` и `Publisher/Subscriber` (`Pub/Sub`) — это два схожих поведенческих шаблона, которые используются для организации взаимодействия между объектами и для уведомления о событиях. Однако их архитектура и способы взаимодействия имеют существенные отличия.

### Основные отличия:
<table border="1" cellpadding="10" cellspacing="0">
    <thead>
        <tr>
            <th>Характеристика</th>
            <th>Observer</th>
            <th>Pub/Sub</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Связанность</td>
            <td>Наблюдатели напрямую подписаны на субъект (наблюдаемый объект). Субъект знает, кто его наблюдатели.</td>
            <td>Подписчики и издатели не знают друг о друге. Уведомление осуществляется через посредника (брокера событий).</td>
        </tr>
        <tr>
            <td>Способ уведомления</td>
            <td>Наблюдатели уведомляются субъектом напрямую.</td>
            <td>Уведомления распространяются через брокера, который передаёт сообщения подписчикам.</td>
        </tr>
        <tr>
            <td>Посредник</td>
            <td>Посредник отсутствует, наблюдатели напрямую связаны с объектом.</td>
            <td>Посредник (брокер сообщений) управляет подписками и доставкой сообщений.</td>
        </tr>
        <tr>
            <td>Архитектура</td>
            <td>Используется для одного субъекта и его множества наблюдателей.</td>
            <td>Используется для распределённых систем, где подписчики и издатели могут быть в разных местах.</td>
        </tr>
        <tr>
            <td>Синхронность</td>
            <td>Обычно синхронный механизм: наблюдатели уведомляются сразу после изменения субъекта.</td>
            <td>Часто используется асинхронная модель, при которой сообщения могут быть доставлены позже.</td>
        </tr>
        <tr>
            <td>Пример использования</td>
            <td>Пример: пользовательский интерфейс, где разные элементы могут быть уведомлены о событии (например, изменение данных).</td>
            <td>Пример: системы сообщений (например, RabbitMQ), где одно приложение публикует сообщения, а несколько других подписываются на них.</td>
        </tr>
    </tbody>
</table>

### Подробное объяснение:
#### `Observer` (Наблюдатель):
* Связанность: Наблюдатели (объекты, которые интересуются состоянием субъекта) регистрируются напрямую у субъекта (наблюдаемого объекта). Субъект отслеживает, какие наблюдатели на него подписаны, и уведомляет их при изменении своего состояния.

* Прямое взаимодействие: Взаимодействие между субъектом и наблюдателями происходит напрямую, без посредников.

* Использование: Observer подходит для ситуаций, когда объект (субъект) должен уведомить конкретные подписанные на него объекты (наблюдатели), как только его состояние изменяется.

* Пример: В графических интерфейсах, когда одно событие (например, нажатие кнопки) должно вызвать обновление нескольких компонентов (наблюдателей).

#### Пример на основе `Observer`:
Когда объект типа `WeatherStation` изменяет своё состояние (например, обновляет данные о температуре), все его наблюдатели (например, `TemperatureDisplay`) немедленно получают обновление.

```java
WeatherStation weatherStation = new WeatherStation();
TemperatureDisplay display = new TemperatureDisplay();
weatherStation.addObserver(display);
weatherStation.setTemperature(25.0f);  // Сразу уведомляет наблюдателей
```

### `Pub/Sub` (Publisher/Subscriber):
* Посредник: В Pub/Sub модели между издателем (Publisher) и подписчиком (Subscriber) находится посредник — брокер сообщений. Издатель отправляет сообщения через брокера, и подписчики получают эти сообщения через брокера. Издатель и подписчик не знают друг о друге.

* Асинхронность: Сообщения могут быть отправлены в любой момент, и подписчики могут получить их позже, в зависимости от возможностей системы доставки сообщений.

* Использование: Pub/Sub часто используется в распределённых системах или в системах с высокой нагрузкой, где важно отделить издателя от подписчиков. Это позволяет подписчикам реагировать на события независимо от издателя, что повышает масштабируемость системы.

* Пример: Например, система обмена сообщениями, такая как `Kafka` или `RabbitMQ`, где издатель отправляет сообщения о событиях, а подписчики, возможно, на разных серверах, получают их через брокера сообщений.

#### Пример на основе `Pub/Sub`:
Пример системы обмена сообщениями с брокером (например, с использованием `RabbitMQ`, `Apache Kafka` или других систем):

1. `Publisher` публикует сообщение о том, что был выпущен новый продукт.

2. `Message Broker` передаёт это сообщение всем подписчикам, которые подписаны на тему "новые продукты".

3. `Subscribers` получают это сообщение и обрабатывают его (например, один подписчик обновляет базу данных продуктов, а другой уведомляет пользователей по `email`).

```java
// Публикация сообщения
messageBroker.publish("newProduct", "Продукт был выпущен");

// Подписчики получают сообщение через брокера
messageBroker.subscribe("newProduct", new EmailNotifier());
messageBroker.subscribe("newProduct", new DatabaseUpdater());
```

### Архитектурные различия:
1. Прямое vs. Непрямое взаимодействие:
    * В Observer наблюдатели напрямую взаимодействуют с объектом, за которым они следят. Когда объект изменяется, он сразу же уведомляет всех наблюдателей.

    * В Pub/Sub издатели и подписчики не знают друг о друге. Они взаимодействуют через брокера сообщений, который управляет подписками и передачей сообщений.

2. Связанность:
    * В Observer субъект и наблюдатели связаны напрямую. Субъект отслеживает, какие объекты на него подписаны.

    * В Pub/Sub издатели и подписчики не связаны друг с другом. Это обеспечивает низкую связанность и большую гибкость.

3. Синхронность vs. Асинхронность:
    * Observer чаще всего реализуется как синхронный шаблон, где уведомления наблюдателям отправляются немедленно.
    
    * Pub/Sub часто является асинхронным, когда подписчики могут получать сообщения позже, а сообщения могут быть поставлены в очередь.

4. Использование в распределённых системах:
    * Observer более эффективен для локальных систем, где объект и его наблюдатели находятся в одном приложении.

    * Pub/Sub используется в распределённых системах, где компоненты могут быть распределены между различными машинами или сервисами, и их взаимодействие организовано через брокеры сообщений.

### Примеры использования:
1. `Observer`:

    * Графические интерфейсы (GUI): Когда пользователь взаимодействует с элементом управления, другие компоненты могут быть уведомлены о событиях (например, изменение текста в текстовом поле может обновить связанные метки).

    * Модели с MVC (Model-View-Controller): Модель может уведомлять представления о том, что данные изменились, и те должны обновиться.

2. `Pub/Sub`:

    * Системы обмена сообщениями (MQ): Например, RabbitMQ, Kafka, или Google Pub/Sub, где издатели могут отправлять сообщения в топики, а подписчики получают сообщения из этих топиков.

    * Микросервисные архитектуры: Один сервис публикует события (например, изменения в заказах), а другие сервисы могут подписываться и обрабатывать эти события.

### Вывод:

* `Observer` лучше подходит для локальных, синхронных взаимодействий между объектами, где наблюдатели напрямую подписываются на изменения одного субъекта.

* `Pub/Sub` обеспечивает низкую связанность и асинхронную передачу сообщений, что делает его подходящим для распределённых систем и высоконагруженных приложений, где издатель и подписчик могут находиться на разных узлах.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Strategy`, как `Strategy` помогает выбирать алгоритмы на этапе выполнения

`Strategy` (Стратегия) — это поведенческий шаблон проектирования, который определяет семейство алгоритмов, инкапсулирует их в отдельные классы и делает их взаимозаменяемыми. Благодаря этому шаблону, алгоритмы могут быть изменены независимо от клиентов, которые ими пользуются. Это позволяет динамически выбирать алгоритм на этапе выполнения программы.

### Основная идея:
Шаблон `Strategy` предоставляет возможность:

1. Инкапсулировать алгоритмы: Каждый алгоритм (стратегия) реализуется в виде отдельного класса.

2. Заменять алгоритмы на этапе выполнения: Клиент может менять стратегии динамически, не изменяя основную логику программы.

3. Делать алгоритмы взаимозаменяемыми: Клиентский код работает с интерфейсом стратегии, поэтому любые стратегии могут быть заменены без изменения кода клиента.

### Когда использовать `Strategy`:
1. Когда нужно иметь возможность легко заменять различные алгоритмы или методы выполнения задачи.

2. Когда в классе есть множество условных операторов (например, if, else, switch) для выбора поведения в зависимости от условий.

3. Когда нужно предоставить несколько вариантов выполнения одной и той же задачи.

### Пример использования `Strategy`
Предположим, у нас есть система для вычисления стоимости доставки товара. В зависимости от способа доставки (например, авиапочта, наземная доставка или экспресс-доставка) стоимость доставки будет разной. Мы можем использовать `Strategy`, чтобы инкапсулировать каждый способ доставки и выбирать его на этапе выполнения.

#### 1. Интерфейс стратегии `ShippingStrategy`:
Этот интерфейс будет определять метод для расчета стоимости доставки.

```java
interface ShippingStrategy {
    double calculateShippingCost(double weight);
}
```

#### 2. Конкретные стратегии для разных способов доставки:
Стратегия для авиапочты:

```java
class AirShipping implements ShippingStrategy {
    @Override
    public double calculateShippingCost(double weight) {
        return weight * 10.0;  // Стоимость за кг
    }
}
```

Стратегия для наземной доставки:
```java
class GroundShipping implements ShippingStrategy {
    @Override
    public double calculateShippingCost(double weight) {
        return weight * 5.0;  // Стоимость за кг
    }
}
```
Стратегия для экспресс-доставки:
```java
class ExpressShipping implements ShippingStrategy {
    @Override
    public double calculateShippingCost(double weight) {
        return weight * 20.0;  // Стоимость за кг
    }
}
```

#### 3. Класс `Context`, который использует стратегию:
Класс `ShippingCostCalculator` будет принимать стратегию и использовать её для расчета стоимости доставки.

```java
class ShippingCostCalculator {
    private ShippingStrategy strategy;

    // Устанавливаем стратегию (алгоритм) доставки
    public void setStrategy(ShippingStrategy strategy) {
        this.strategy = strategy;
    }

    // Расчитываем стоимость доставки
    public double calculateCost(double weight) {
        return strategy.calculateShippingCost(weight);
    }
}
```
#### 4. Использование `Strategy`:
Теперь клиент может динамически выбирать стратегию доставки на этапе выполнения.

```java
public class StrategyPatternDemo {
    public static void main(String[] args) {
        ShippingCostCalculator calculator = new ShippingCostCalculator();

        // Устанавливаем стратегию авиапочты
        calculator.setStrategy(new AirShipping());
        System.out.println("Стоимость авиадоставки: " + calculator.calculateCost(10));

        // Меняем стратегию на наземную доставку
        calculator.setStrategy(new GroundShipping());
        System.out.println("Стоимость наземной доставки: " + calculator.calculateCost(10));

        // Меняем стратегию на экспресс-доставку
        calculator.setStrategy(new ExpressShipping());
        System.out.println("Стоимость экспресс-доставки: " + calculator.calculateCost(10));
    }
}
```
##### Вывод программы:
```bash
Стоимость авиадоставки: 100.0
Стоимость наземной доставки: 50.0
Стоимость экспресс-доставки: 200.0
```

### Объяснение:
1. Strategy: Каждая стратегия (например, AirShipping, GroundShipping, ExpressShipping) реализует интерфейс ShippingStrategy и предоставляет свою реализацию метода calculateShippingCost.

2. Context: Класс ShippingCostCalculator использует стратегию для расчета стоимости доставки. Стратегию можно менять динамически, что делает алгоритм гибким и расширяемым.

3. Динамический выбор: Клиентский код может менять стратегии доставки на этапе выполнения, и это не требует изменения самого класса ShippingCostCalculator.

### Преимущества `Strategy`:
1. Гибкость: Легко добавлять новые стратегии (алгоритмы), не изменяя существующий код.

2. Изоляция логики: Каждая стратегия инкапсулирует свой алгоритм, делая код более читаемым и поддерживаемым.

3. Поддержка открытости/закрытости: Легко расширять систему новыми стратегиями без изменения существующего кода.

### Недостатки `Strategy`:
1. Увеличение количества классов: Каждая новая стратегия требует создания отдельного класса.

2. Потенциальная сложность выбора стратегии: Клиент должен знать, какую стратегию выбрать, что может потребовать сложной логики выбора.

### Когда использовать `Strategy`:
1. Когда необходимо менять поведение объекта на этапе выполнения в зависимости от определенных условий.

2. Когда есть несколько взаимозаменяемых алгоритмов или стратегий выполнения задачи.

3. Когда необходимо избежать дублирования кода, связанного с разными реализациями алгоритмов.

`Strategy` — это мощный инструмент для создания гибких и расширяемых систем, где можно легко добавлять новые алгоритмы или менять существующие без изменения основного кода.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `State`, переключение состояний объекта в зависимости от его состояния

`State` (Состояние) — это поведенческий шаблон проектирования, который позволяет объекту изменять своё поведение в зависимости от его состояния. Этот шаблон инкапсулирует различные состояния объекта в отдельные классы, и объект делегирует работу этим классам в зависимости от текущего состояния.

### Основная идея:
* Объект может находиться в разных состояниях, и в каждом состоянии его поведение может изменяться.

* Вместо использования множества условных операторов (if, switch) для переключения состояний, каждый тип поведения инкапсулируется в отдельный класс.

* Шаблон позволяет объекту менять свое поведение, как будто он меняет свой класс.

### Когда использовать `State`:
1. Когда объект должен изменять свое поведение в зависимости от своего состояния.

2. Когда код содержит много условных операторов для определения текущего состояния объекта и вызова соответствующего поведения.

3. Когда необходимо сделать систему более гибкой и легко расширяемой за счёт добавления новых состояний.

### Пример использования `State`
Предположим, у нас есть автомат для покупки товаров. Автомат может находиться в различных состояниях: ожидание монеты, монета вставлена, выбор продукта, продукт выдан. В зависимости от состояния, поведение автомата должно изменяться.

#### 1. Интерфейс `State`:
Каждое состояние автомата будет реализовывать этот интерфейс, предоставляющий методы для различных действий.

```java
interface State {
    void insertCoin();
    void ejectCoin();
    void selectProduct();
    void dispenseProduct();
}
```

#### 2. Конкретные состояния автомата:
Состояние ожидания монеты:

```java
class NoCoinState implements State {
    private VendingMachine vendingMachine;

    public NoCoinState(VendingMachine vendingMachine) {
        this.vendingMachine = vendingMachine;
    }

    @Override
    public void insertCoin() {
        System.out.println("Монета вставлена.");
        vendingMachine.setState(vendingMachine.getHasCoinState());
    }

    @Override
    public void ejectCoin() {
        System.out.println("Монета не была вставлена.");
    }

    @Override
    public void selectProduct() {
        System.out.println("Сначала вставьте монету.");
    }

    @Override
    public void dispenseProduct() {
        System.out.println("Сначала вставьте монету.");
    }
}
```
Состояние, когда монета вставлена:
```java
class HasCoinState implements State {
    private VendingMachine vendingMachine;

    public HasCoinState(VendingMachine vendingMachine) {
        this.vendingMachine = vendingMachine;
    }

    @Override
    public void insertCoin() {
        System.out.println("Монета уже вставлена.");
    }

    @Override
    public void ejectCoin() {
        System.out.println("Монета возвращена.");
        vendingMachine.setState(vendingMachine.getNoCoinState());
    }

    @Override
    public void selectProduct() {
        System.out.println("Продукт выбран.");
        vendingMachine.setState(vendingMachine.getProductDispensedState());
    }

    @Override
    public void dispenseProduct() {
        System.out.println("Выберите продукт сначала.");
    }
}
```
Состояние выдачи продукта:
```java
class ProductDispensedState implements State {
    private VendingMachine vendingMachine;

    public ProductDispensedState(VendingMachine vendingMachine) {
        this.vendingMachine = vendingMachine;
    }

    @Override
    public void insertCoin() {
        System.out.println("Подождите, продукт уже выдаётся.");
    }

    @Override
    public void ejectCoin() {
        System.out.println("Нельзя вернуть монету после выбора продукта.");
    }

    @Override
    public void selectProduct() {
        System.out.println("Продукт уже выбран.");
    }

    @Override
    public void dispenseProduct() {
        System.out.println("Продукт выдан.");
        vendingMachine.setState(vendingMachine.getNoCoinState());
    }
}
```

#### 3. Класс `VendingMachine` (Контекст):
Контекст содержит текущее состояние автомата и методы для взаимодействия с ним.

```java
class VendingMachine {
    private State noCoinState;
    private State hasCoinState;
    private State productDispensedState;

    private State currentState;

    public VendingMachine() {
        noCoinState = new NoCoinState(this);
        hasCoinState = new HasCoinState(this);
        productDispensedState = new ProductDispensedState(this);

        currentState = noCoinState;  // Изначально автомат не имеет монеты
    }

    public void insertCoin() {
        currentState.insertCoin();
    }

    public void ejectCoin() {
        currentState.ejectCoin();
    }

    public void selectProduct() {
        currentState.selectProduct();
    }

    public void dispenseProduct() {
        currentState.dispenseProduct();
    }

    public void setState(State state) {
        currentState = state;
    }

    public State getNoCoinState() {
        return noCoinState;
    }

    public State getHasCoinState() {
        return hasCoinState;
    }

    public State getProductDispensedState() {
        return productDispensedState;
    }
}
```

#### 4. Использование `State`:
Теперь создадим объект автомата и будем взаимодействовать с ним, проверяя, как меняются его состояния.

```java
public class StatePatternDemo {
    public static void main(String[] args) {
        VendingMachine vendingMachine = new VendingMachine();

        // Пытаемся выбрать продукт без монеты
        vendingMachine.selectProduct();  // Сначала нужно вставить монету

        // Вставляем монету
        vendingMachine.insertCoin();

        // Выбираем продукт
        vendingMachine.selectProduct();

        // Выдаём продукт
        vendingMachine.dispenseProduct();
    }
}
```
#### Вывод программы:
```
Сначала вставьте монету.
Монета вставлена.
Продукт выбран.
Продукт выдан.
```

### Объяснение:
1. Контекст (VendingMachine): Автомат для продажи товаров, который может находиться в разных состояниях. Состояния инкапсулируются в отдельные классы.

2. Состояния: У автомата есть три состояния — без монеты (NoCoinState), с монетой (HasCoinState), и когда продукт выдан (ProductDispensedState). Каждое состояние имеет своё поведение.

3. Переключение состояний: Автомат меняет своё текущее состояние, используя метод setState(). В зависимости от состояния, методы, такие как insertCoin(), selectProduct() и другие, работают по-разному.

### Преимущества `State`:
1. Чистый код: Убирает необходимость использовать большие условные операторы (if, switch), определяющие текущее состояние объекта.

2. Легкость расширения: Новые состояния можно добавлять, не изменяя существующий код.

3. Поддержка открытости/закрытости: Поведение объектов можно легко изменять, просто добавляя новые классы состояний.

### Недостатки `State`:
1. Увеличение числа классов: Для каждого состояния создаётся отдельный класс, что может привести к увеличению количества классов в проекте.

2. Переусложнение для простых состояний: В простых сценариях с малым количеством состояний использование State может быть избыточным.

### Когда использовать `State`:
1. Когда объект может находиться в нескольких состояниях, и его поведение изменяется в зависимости от текущего состояния.

2. Когда код содержит большое количество условных операторов для обработки различных состояний объекта.

3. Когда требуется инкапсулировать различные состояния в отдельные классы для лучшей поддерживаемости и расширяемости.

`State` — это мощный шаблон, который помогает организовать код и сделать его более читаемым, особенно когда поведение объекта зависит от его текущего состояния.


[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Template Method`, использование для определения скелета алгоритма с возможностью изменения шагов

`Template Method` (Шаблонный метод) — это поведенческий шаблон проектирования, который определяет основу (скелет) алгоритма в виде метода в базовом классе, оставляя реализацию некоторых шагов этого алгоритма на усмотрение подклассов. Это позволяет переопределять конкретные шаги алгоритма, не изменяя его структуру и общий ход выполнения.

### Основная идея:
* В шаблонном методе базовый класс предоставляет основной алгоритм в виде метода, который состоит из шагов.

* Некоторые из этих шагов могут быть реализованы в базовом классе, а другие — абстрактными или виртуальными, и их должны реализовать подклассы.

* Таким образом, общий алгоритм фиксирован, а конкретные шаги могут быть изменены в подклассах.

### Когда использовать `Template Method`:
1. Когда требуется задать скелет алгоритма один раз, а реализацию его отдельных шагов делегировать подклассам.

2. Когда нужно избежать дублирования кода, оставляя общий алгоритм в одном месте.

3. Когда вы хотите дать подклассам возможность изменять части алгоритма, не трогая его основную структуру.

### Пример использования `Template Method`
Рассмотрим пример с процессом приготовления напитков (например, кофе и чая). Общий алгоритм приготовления напитка может быть одинаковым (например, вскипятить воду, заварить напиток, налить в чашку, добавить добавки), но конкретные шаги, такие как заваривание чая или кофе, будут различаться. Мы можем использовать шаблон `Template Method`, чтобы определить общий алгоритм и позволить подклассам изменять конкретные шаги.

#### 1. Базовый класс `Beverage` (алгоритм приготовления):
```java
abstract class Beverage {
    // Шаблонный метод, определяющий алгоритм приготовления
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    // Общие шаги алгоритма
    private void boilWater() {
        System.out.println("Вода кипятится...");
    }

    private void pourInCup() {
        System.out.println("Налить напиток в чашку...");
    }

    // Шаги, которые должны быть реализованы в подклассах
    protected abstract void brew();
    protected abstract void addCondiments();
}
```

#### 2. Конкретный подкласс для чая Tea:
Этот класс реализует специфические шаги для приготовления чая.

```java
class Tea extends Beverage {
    @Override
    protected void brew() {
        System.out.println("Заваривание чая...");
    }

    @Override
    protected void addCondiments() {
        System.out.println("Добавление лимона...");
    }
}
```
#### 3. Конкретный подкласс для кофе `Coffee`:
Этот класс реализует специфические шаги для приготовления кофе.

```java
class Coffee extends Beverage {
    @Override
    protected void brew() {
        System.out.println("Заваривание кофе...");
    }

    @Override
    protected void addCondiments() {
        System.out.println("Добавление молока и сахара...");
    }
}
```
#### 4. Демонстрация использования `Template Method`:
Теперь можно использовать классы для приготовления различных напитков, при этом общий алгоритм (вскипятить воду, налить в чашку) остаётся неизменным, а подклассы реализуют только уникальные шаги.

```java
public class TemplateMethodDemo {
    public static void main(String[] args) {
        Beverage tea = new Tea();
        Beverage coffee = new Coffee();

        System.out.println("Приготовление чая:");
        tea.prepareRecipe();  // Используем шаблонный метод для приготовления чая

        System.out.println("\nПриготовление кофе:");
        coffee.prepareRecipe();  // Используем шаблонный метод для приготовления кофе
    }
}
```
#### Вывод программы:
```
Приготовление чая:
Вода кипятится...
Заваривание чая...
Налить напиток в чашку...
Добавление лимона...

Приготовление кофе:
Вода кипятится...
Заваривание кофе...
Налить напиток в чашку...
Добавление молока и сахара...
```

#### Объяснение:
1. Шаблонный метод: Метод prepareRecipe() определяет общий алгоритм приготовления напитка (вскипятить воду, заварить, налить в чашку, добавить добавки). Он не меняется и всегда выполняется в таком порядке.

2. Абстрактные методы: Методы brew() (заварить) и addCondiments() (добавить добавки) объявлены как абстрактные, и их реализация должна быть предоставлена в подклассах, таких как Tea и Coffee. Это позволяет разным напиткам иметь разные способы заваривания и добавления добавок.

3. Наследование и полиморфизм: Подклассы Tea и Coffee наследуют алгоритм из базового класса, но предоставляют свою собственную реализацию уникальных шагов. Это обеспечивает гибкость и предотвращает дублирование кода.

### Преимущества `Template Method`:
1. Повторное использование кода: Общая структура алгоритма реализована один раз в базовом классе, что предотвращает дублирование кода в подклассах.

2. Гибкость: Легко изменять поведение отдельных шагов алгоритма, не трогая его общий скелет.

3. Поддержка принципа "открытости/закрытости": Алгоритм может быть расширен новыми шагами в подклассах без изменения базового класса.

### Недостатки `Template Method`:
1. Ограниченность наследованием: Так как шаблонный метод опирается на наследование, это может привести к жесткой структуре, особенно если требуется добавить новые поведения или изменить структуру алгоритма.

2. Сложность в поддержке: При большом количестве шагов в алгоритме и множестве подклассов структура может стать сложной для понимания и сопровождения.

### Когда использовать `Template Method`:
1. Когда нужно определить скелет алгоритма один раз, но дать возможность подклассам изменять отдельные шаги алгоритма.

2. Когда есть несколько классов, которые реализуют схожие алгоритмы с небольшими вариациями.

3. Когда нужно избежать дублирования кода, оставив общий алгоритм в одном месте, а конкретные реализации в разных классах.

`Template Method` — это полезный инструмент для создания гибких систем, где основная структура алгоритма фиксирована, но некоторые шаги могут быть изменены или переопределены в подклассах.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Memento`, сохранение и восстановление состояния объекта

`Memento` (Хранитель) — это поведенческий шаблон проектирования, который позволяет сохранять и восстанавливать предыдущее состояние объекта без раскрытия его внутренней структуры. Этот шаблон инкапсулирует состояние объекта в специальный объект (хранитель) и предоставляет возможность вернуться к сохранённому состоянию в будущем.

### Основная идея:
* Originator (Создатель) — объект, чьё состояние нужно сохранять и восстанавливать.

* Memento (Хранитель) — объект, который сохраняет состояние создателя, обеспечивая возможность его восстановления.

* Caretaker (Опекун) — объект, который отвечает за хранение хранителей и управление процессом сохранения и восстановления состояний.

### Когда использовать `Memento`:
1. Когда необходимо сохранять историю состояний объекта, чтобы в будущем можно было вернуться к одному из сохранённых состояний.

2. Когда нужно реализовать функционал отмены (undo/redo) операций.

3. Когда требуется изолировать сохранение состояния объекта от его внешнего интерфейса, чтобы другие объекты не могли получить доступ к его внутреннему состоянию.

### Пример использования `Memento`
Рассмотрим пример с текстовым редактором, где пользователь может вводить текст, а затем отменять изменения, восстанавливая предыдущее состояние текста.

#### 1. Класс `Originator` (Создатель):
Этот класс представляет текстовый редактор, который может сохранять и восстанавливать своё состояние (содержимое текста).

```java
class TextEditor {
    private String text;

    // Сохранить текущее состояние (создать хранитель)
    public Memento save() {
        return new Memento(text);
    }

    // Восстановить состояние (из хранителя)
    public void restore(Memento memento) {
        this.text = memento.getText();
    }

    // Установить новое содержимое текста
    public void setText(String text) {
        this.text = text;
    }

    // Получить текущее содержимое текста
    public String getText() {
        return text;
    }

    // Внутренний класс Memento
    public static class Memento {
        private final String text;

        private Memento(String text) {
            this.text = text;
        }

        private String getText() {
            return text;
        }
    }
}
```

#### 2. Класс `Caretaker` (Опекун):
Этот класс управляет сохранением и восстановлением состояний объекта `TextEditor`. Он сохраняет историю состояний.

```java
import java.util.Stack;

class Caretaker {
    private Stack<TextEditor.Memento> history = new Stack<>();

    // Сохранить состояние
    public void save(TextEditor textEditor) {
        history.push(textEditor.save());
    }

    // Восстановить последнее сохранённое состояние
    public void undo(TextEditor textEditor) {
        if (!history.isEmpty()) {
            textEditor.restore(history.pop());
        } else {
            System.out.println("История пуста, нечего восстанавливать.");
        }
    }
}
```

#### 3. Пример использования `Memento`:
Теперь создадим текстовый редактор, изменим его содержимое и восстановим предыдущее состояние.

```java
public class MementoPatternDemo {
    public static void main(String[] args) {
        TextEditor textEditor = new TextEditor();
        Caretaker caretaker = new Caretaker();

        // Установим текст и сохраним состояние
        textEditor.setText("Первый текст.");
        caretaker.save(textEditor);
        System.out.println("Текущее состояние: " + textEditor.getText());

        // Изменим текст и снова сохраним состояние
        textEditor.setText("Второй текст.");
        caretaker.save(textEditor);
        System.out.println("Текущее состояние: " + textEditor.getText());

        // Восстановим предыдущее состояние (отмена изменений)
        caretaker.undo(textEditor);
        System.out.println("После отмены: " + textEditor.getText());

        // Восстановим ещё одно предыдущее состояние
        caretaker.undo(textEditor);
        System.out.println("После ещё одной отмены: " + textEditor.getText());
    }
}
```
#### Вывод программы:
```
Текущее состояние: Первый текст.
Текущее состояние: Второй текст.
После отмены: Первый текст.
После ещё одной отмены: Первый текст.
```

### Объяснение:
1. Originator (TextEditor): Этот объект сохраняет своё состояние (содержимое текста) и может восстанавливать его из объекта Memento. Он имеет методы save() для создания объекта хранителя и restore() для восстановления состояния из хранителя.

2. Memento: Внутренний класс Memento инкапсулирует состояние текста. Он предоставляет возможность сохранения состояния (в виде строки текста) и его восстановления, но скрывает внутренние детали от других объектов.

3. Caretaker: Класс Caretaker управляет сохранением и восстановлением состояний, используя стек для хранения объектов Memento. Он отвечает за вызов методов сохранения и восстановления состояния у объекта TextEditor.

### Преимущества `Memento`:
1. Инкапсуляция состояния: Шаблон позволяет сохранять состояние объекта без нарушения его инкапсуляции, так как внутренние детали состояния не раскрываются внешним объектам.

2. Поддержка undo/redo: Легко реализуется функциональность отмены и повторения действий.

3. Изоляция состояния: Сохранение и восстановление состояния не требуют изменения кода клиента, который использует объект, а это упрощает архитектуру программы.

### Недостатки `Memento`:
1. Повышенные затраты памяти: Если объект имеет много состояний или если сами состояния очень объёмные, это может привести к значительному потреблению памяти.

2. Сложность управления состояниями: В некоторых случаях может быть сложно управлять большим количеством состояний, особенно если они требуют частого сохранения и восстановления.

### Когда использовать `Memento`:
1. Когда нужно сохранить и восстановить предыдущее состояние объекта (например, для реализации undo/redo).

2. Когда необходимо изолировать сохранение состояния от внешних объектов, чтобы сохранить инкапсуляцию объекта.

3. Когда важно, чтобы объект мог восстановить себя в предыдущем состоянии, не раскрывая деталей своего состояния другим объектам.

`Memento` — это мощный шаблон для управления состоянием объекта, который предоставляет безопасный способ сохранить и восстановить его состояние, не нарушая инкапсуляции и не раскрывая внутренние детали другим объектам.

[наверх](#шаблоны-проектирования)


## Шаблон проектирования `Mediator`, управление взаимодействием между объектами

`Mediator` (Посредник) — это поведенческий шаблон проектирования, который определяет объект, инкапсулирующий взаимодействие между множеством объектов. Посредник способствует уменьшению зависимости между объектами, так что они взаимодействуют не напрямую друг с другом, а через посредника, который управляет их взаимодействием.

### Основная идея:
* Mediator снижает связанность между объектами, обеспечивая управление взаимодействием через посредника.

* Вместо того, чтобы объекты напрямую ссылались друг на друга и напрямую общались, они передают всю коммуникацию через посредник. Это делает систему более гибкой и легче расширяемой.

* Объекты знают только о существовании посредника и не знают о других объектах, что упрощает поддержку и модификацию системы.

### Когда использовать `Mediator`:
1. Когда в системе много взаимосвязанных объектов, и прямое взаимодействие между ними приводит к сложной и сильно связанной архитектуре.

2. Когда требуется централизовать управление взаимодействиями между объектами.

3. Когда нужно минимизировать количество связей между объектами, чтобы уменьшить зависимость и упростить расширение системы.

### Пример использования `Mediator`
Предположим, у нас есть система чата, где несколько пользователей могут отправлять сообщения друг другу. Вместо того чтобы каждый пользователь знал об остальных пользователях и мог отправлять им сообщения напрямую, мы можем использовать `Mediator`, который будет управлять всеми сообщениями и рассылать их нужным пользователям.

#### 1. Интерфейс `Mediator`:
Это интерфейс для взаимодействия между объектами (например, пользователями в чате).

```java
interface ChatMediator {
    void sendMessage(String message, User user);
    void addUser(User user);
}
```

#### 2. Класс `ConcreteMediator` (Конкретный посредник):
Посредник управляет взаимодействием между пользователями (объектами `User`).

```java
import java.util.ArrayList;
import java.util.List;

class ChatRoom implements ChatMediator {
    private List<User> users;

    public ChatRoom() {
        this.users = new ArrayList<>();
    }

    @Override
    public void addUser(User user) {
        this.users.add(user);
    }

    @Override
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            // Сообщение не должно быть отправлено отправителю
            if (user != sender) {
                user.receive(message);
            }
        }
    }
}
```

#### 3. Класс `User` (Пользователь):
Пользователи взаимодействуют через посредника, отправляя и получая сообщения.

```java
abstract class User {
    protected ChatMediator mediator;
    protected String name;

    public User(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }

    public abstract void send(String message);
    public abstract void receive(String message);
}
```
#### 4. Класс `ConcreteUser` (Конкретный пользователь):
Это конкретная реализация пользователя, который может отправлять и получать сообщения через посредника.

```java
class ChatUser extends User {
    public ChatUser(ChatMediator mediator, String name) {
        super(mediator, name);
    }

    @Override
    public void send(String message) {
        System.out.println(this.name + ": Отправка сообщения: " + message);
        mediator.sendMessage(message, this);
    }

    @Override
    public void receive(String message) {
        System.out.println(this.name + ": Получено сообщение: " + message);
    }
}
```
#### 5. Демонстрация использования `Mediator`:
Теперь создадим чат (посредник), пользователей и организуем их взаимодействие через посредника.

```java
public class MediatorPatternDemo {
    public static void main(String[] args) {
        ChatMediator chatRoom = new ChatRoom();

        User user1 = new ChatUser(chatRoom, "Алекс");
        User user2 = new ChatUser(chatRoom, "Мария");
        User user3 = new ChatUser(chatRoom, "Дмитрий");
        User user4 = new ChatUser(chatRoom, "Анна");

        // Добавляем пользователей в чат
        chatRoom.addUser(user1);
        chatRoom.addUser(user2);
        chatRoom.addUser(user3);
        chatRoom.addUser(user4);

        // Пользователи отправляют сообщения через посредника
        user1.send("Всем привет!");
        user3.send("Привет, Алекс!");
    }
}
```
#### Вывод программы:
```makefile
Алекс: Отправка сообщения: Всем привет!
Мария: Получено сообщение: Всем привет!
Дмитрий: Получено сообщение: Всем привет!
Анна: Получено сообщение: Всем привет!
Дмитрий: Отправка сообщения: Привет, Алекс!
Алекс: Получено сообщение: Привет, Алекс!
Мария: Получено сообщение: Привет, Алекс!
Анна: Получено сообщение: Привет, Алекс!
```

### Объяснение:
1. Mediator (ChatRoom): Класс ChatRoom управляет взаимодействием между пользователями. Когда один пользователь отправляет сообщение, посредник пересылает его всем другим пользователям.

2. Users: Пользователи (ChatUser) взаимодействуют друг с другом не напрямую, а через объект посредника (ChatRoom), который управляет рассылкой сообщений.

3. Уменьшение связанности: Пользователи не знают напрямую друг о друге. Все взаимодействия между ними проходят через посредника. Это значительно упрощает поддержку и расширение системы, так как пользователи не зависят друг от друга.

### Преимущества `Mediator`:
1. Снижение зависимости между объектами: Объекты взаимодействуют через посредника, что уменьшает количество прямых связей между ними. Это упрощает изменение и расширение системы.

2. Централизованное управление взаимодействиями: Все взаимодействия между объектами сконцентрированы в одном месте, что делает их проще для отслеживания и управления.

3. Облегчение поддержки: Изменения в логике взаимодействия между объектами можно внести, изменив только посредника, не изменяя сами объекты.

### Недостатки `Mediator`:
1. Усложнение логики посредника: По мере роста системы посредник может стать очень сложным, так как ему придётся управлять всё большим числом объектов и взаимодействий между ними.

2. Единая точка отказа: Если посредник выйдет из строя или станет слишком сложным, это может привести к проблемам в работе всей системы.

### Когда использовать `Mediator`:
1. Когда необходимо минимизировать зависимости между многими взаимодействующими объектами.

2. Когда требуется централизованное управление взаимодействиями между компонентами системы.

3. Когда в системе много объектов, и прямое взаимодействие между ними привело бы к сильно связанной и сложно поддерживаемой системе.

`Mediator` — это отличный способ управлять сложными взаимодействиями между множеством объектов, централизуя эти взаимодействия и снижая связанность между объектами, что делает систему более гибкой и удобной для расширения.

[наверх](#шаблоны-проектирования)


[назад](../README.md)