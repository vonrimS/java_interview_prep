# Java Concurrency


[назад](../README.md)

* [Java Memory Model](#java-memomory-model)
* [Многопоточность и как создать поток в Java](#многопоточность-и-как-создать-поток-в-java)
* [Возмжоные проблемы при многопоточном доступе к ресурсам](#возмжоные-проблемы-при-многопоточном-доступе-к-ресурсам)
* [Как синхронизировать доступ к общим ресурсам](#как-синхронизировать-доступ-к-общим-ресурсам)
* [deadlocks и как их избегать](#deadlocks-и-как-их-избегать)
* [Ключевое слово `volatile`](#ключевое-слово-volatile)
* [Как работают методы wait(), notify() и notifyAll()](#как-работают-методы-wait()-notify()-и-notifyAll())
* [Многозадачность, её реализация в Java](#многозадачность-её-реализация-в-java)


## Java Memomory Model

`JMM` (Java Memory Model) - это модель памяти, используемая в языке программирования Java для определения порядка доступа к переменным в многопоточных приложениях. `JMM` предоставляет соглашения и правила для разработчиков, которые позволяют писать безопасные и предсказуемые многопоточные приложения.

### Важные аспекты `JMM` включают:

* **Порядок доступа к переменным**: `JMM` определяет, в каком порядке потоки могут видеть изменения, сделанные другими потоками к общим переменным. Это включает в себя определение, когда изменения видны другим потокам и когда они фактически записываются в основную память.

* **Синхронизация**: `JMM` предоставляет механизмы синхронизации, такие как ключевое слово `synchronized` и классы `java.util.concurrent`, для обеспечения правильного доступа к общим данным из нескольких потоков. Эти механизмы гарантируют, что изменения видны другим потокам в нужном порядке.

* **Видимость изменений**: `JMM` управляет тем, какие изменения видны в потоках. Это включает в себя понятие "видимости" изменений, которые были сделаны одним потоком, в другом потоке.

* **Атомарные операции**: `JMM` определяет операции, которые являются атомарными, что означает, что они выполняются целиком, без прерывания другими потоками. Примерами атомарных операций являются операции чтения и записи для переменных типа `volatile` и некоторые операции классов `java.util.concurrent.atomic`.

Цель `JMM` - обеспечить правильное и безопасное выполнение многопоточных программ без неопределенного поведения или гонок данных. Разработчики могут использовать правила `JMM` для создания надежных и многозадачных приложений 

[наверх](#java-concurrency)

## Принципы `JMM`

Понимание принципов `Java Memory Model (JMM)` важно для разработчиков, работающих с многозадачностью в `Java`. `JMM` определяет правила, которые регулируют доступ к памяти и порядок видимости изменений для переменных в многопоточных приложениях. 

### Вот основные принципы `JMM`:

* **Порядок записи и чтения**: `JMM` определяет порядок записи и чтения переменных между потоками. Она гарантирует, что если один поток записывает значение в переменную, то все последующие чтения этой переменной из других потоков будут видеть это значение.

* **Видимость изменений**: `JMM` гарантирует, что изменения, сделанные в одном потоке, становятся видимыми другим потокам. Это означает, что после записи значения в переменную одним потоком, другие потоки будут видеть это значение при последующем чтении.

* **Атомарность операций**: `JMM` определяет операции, которые должны быть атомарными. Например, операции чтения и записи для переменных типа `volatile` являются атомарными. Это означает, что они выполняются целиком и не могут быть прерваны другими потоками.

* **Синхронизация**: `JMM` предоставляет механизмы синхронизации, такие как ключевое слово `synchronized` и методы `wait()` и `notify()`, для обеспечения правильного взаимодействия между потоками и избегания гонок данных.

* **Взаимное исключение**: `JMM` обеспечивает взаимное исключение между потоками. Это означает, что только один поток может выполнить критическую секцию кода в определенный момент времени, что предотвращает гонки данных и дедлоки.

* **Оптимизации компилятора и `JIT`**: `JMM` учитывает оптимизации, которые может выполнять компилятор `Java` и `JIT`-компилятор для улучшения производительности. Однако она гарантирует, что оптимизации не нарушают видимость изменений.

* **Правила для `final`-полей**: `JMM` обеспечивает гарантии для полей, объявленных как `final`, что их значения видны другим потокам правильно и вовремя.

Понимание этих принципов позволяет разработчикам писать безопасные и надежные многозадачные приложения в `Java`. Соблюдение правил `JMM` и использование соответствующих механизмов синхронизации и обеспечения видимости изменений позволяют избегать гонок данных и других проблем, связанных с многозадачностью.

[наверх](#java-concurrency)

## Многопоточность и как создать поток в Java

`Многопоточность` - это способность программы выполнять несколько задач (потоков) параллельно. В Java многопоточность поддерживается с использованием классов и интерфейсов из пакета `java.lang` и `java.util.concurrent`. Вот основные аспекты многопоточности в Java и способы создания потоков:

1. Класс `Thread`: В Java потоки могут быть созданы путем создания экземпляра класса `Thread`. Вы можете создать подкласс, наследующийся от `Thread`, и переопределить метод `run()` для выполнения кода в потоке.
```java
class MyThread extends Thread {
    public void run() {
        // Код, выполняемый в потоке
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // Запуск потока
    }
}
```
2. Интерфейс `Runnable`: Вместо наследования от `Thread`, вы можете реализовать интерфейс `Runnable` и передать экземпляр `Runnable` конструктору `Thread`. Этот способ предоставляет большую гибкость. 
```java
class MyRunnable implements Runnable {
    public void run() {
        // Код, выполняемый в потоке
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // Запуск потока
    }
}
```
3. `Лямбда-выражения`: С Java 8 вы можете использовать лямбда-выражения для создания потоков. Пример:
```java
Runnable runnable = () -> {
    // Код, выполняемый в потоке
};

Thread thread = new Thread(runnable);
thread.start(); // Запуск потока
```
4. Пул потоков (`ThreadPool`): Для более эффективного управления потоками и их переиспользования рекомендуется использовать `ExecutorService`, который представляет собой пул потоков. 

```java
ExecutorService executor = Executors.newFixedThreadPool(5); // Создание пула из 5 потоков
executor.submit(() -> {
    // Код, выполняемый в потоке
});

executor.shutdown(); // Завершение пула потоков после завершения задач
```
Многопоточность в `Java` позволяет создавать асинхронные и параллельные приложения, что может улучшить производительность и отзывчивость. Однако она также может привести к проблемам с синхронизацией и безопасностью, таким как гонки данных и блокировки. Поэтому важно правильно управлять потоками и использовать средства синхронизации, такие как `synchronized`, `Lock`, и `java.util.concurrent` библиотеку, чтобы избегать потенциальных проблем.

[наверх](#java-concurrency)

## Возмжоные проблемы при многопоточном доступе к ресурсам

При многопоточном доступе к ресурсам могут возникать различные проблемы, связанные с совместным использованием ресурсов несколькими потоками. Основные проблемы включают:

1. **Гонки данных** (`Race Conditions`): Это ситуации, когда несколько потоков пытаются одновременно читать и/или записывать в разделяемый ресурс без правильной синхронизации. Это может привести к непредсказуемым и некорректным результатам.

2. **Дедлоки** (`Deadlocks`): Дедлок возникает, когда два или более потока блокируются в ожидании ресурсов, которые удерживают другие потоки. Как результат, ни один из потоков не может продолжить выполнение.

3. **Голодание** (`Starvation`): Это ситуация, когда один или несколько потоков постоянно уступают ресурсы другим потокам, и им не удается получить доступ к ресурсам из-за долгой блокировки других потоков.

4. **Состояние гонки** (`Thread Starvation`): Это когда один поток постоянно уступает ресурсы другим потокам из-за неправильной реализации приоритетов потоков.

5. **Нарушение порядка выполнения** (`Out-of-Order Execution`): Некоторые современные процессоры могут переупорядочивать инструкции, что может вызвать проблемы с синхронизацией при многопоточном доступе к разделяемым ресурсам.

6. **Проблемы с видимостью** (`Visibility Issues`): Потоки могут иметь локальные кэши памяти, что может привести к проблемам с видимостью изменений, сделанных одним потоком, другим потокам. Для решения этой проблемы можно использовать встроенные механизмы синхронизации, такие как `volatile` и `synchronized`.

Для избежания этих проблем необходимо правильно проектировать и синхронизировать свои многопоточные приложения, использовать средства синхронизации, такие как мониторы, блокировки, семафоры и т. д., и строго следовать принципам безопасности и согласованности данных при доступе к разделяемым ресурсам.

[наверх](#java-concurrency)

## Как синхронизировать доступ к общим ресурсам

Для синхронизации доступа к общим ресурсам в Java можно использовать различные механизмы синхронизации. Ниже приведены некоторые из них:

1. **Ключевое слово** `synchronized`: Вы можете использовать ключевое слово `synchronized` для синхронизации методов или блоков кода. Когда метод или блок помечен как `synchronized`, только один поток может выполнить его в данный момент времени. 

```java
public synchronized void synchronizedMethod() {
    // Код, требующий синхронизации
}
```
2. `Lock`: Java предоставляет интерфейс `java.util.concurrent.locks.Lock`, который позволяет более гибко управлять блокировкой. Вы можете использовать реализации этого интерфейса, такие как `ReentrantLock`, для создания более сложных сценариев синхронизации.

```java
Lock lock = new ReentrantLock();
lock.lock(); // Захват блокировки
try {
    // Код, требующий синхронизации
} finally {
    lock.unlock(); // Освобождение блокировки
}
```
3. `Monitors`: Вы также можете использовать мониторы с помощью ключевого слова `synchronized` для блокировки объекта. Пример:

```java
public void synchronizedMethod() {
    synchronized (this) {
        // Код, требующий синхронизации
    }
}
```
4. `Semaphore` : Семафоры могут использоваться для ограничения количества потоков, которые могут одновременно получить доступ к ресурсам.

```java
Semaphore semaphore = new Semaphore(1); // Ограничение на один поток
semaphore.acquire(); // Получение разрешения
try {
    // Код, требующий синхронизации
} finally {
    semaphore.release(); // Освобождение разрешения
}
```
5. `Wait` и `Notify`: Методы `wait()` и `notify()` могут использоваться для организации ожидания и уведомления потоков о состоянии ресурса.

```java
synchronized (sharedObject) {
    while (conditionIsNotMet) {
        sharedObject.wait();
    }
    // Код после выполнения условия
}

synchronized (sharedObject) {
    // Выполнение условия
    sharedObject.notify();
}
```
6. `Read/Write Locks`: Для синхронизации доступа к данным для чтения и записи можно использовать `Read/Write Locks`, такие как `ReentrantReadWriteLock`.

```java
ReadWriteLock lock = new ReentrantReadWriteLock();
lock.readLock().lock(); // Захват блокировки для чтения
try {
    // Код, разрешенный для чтения
} finally {
    lock.readLock().unlock(); // Освобождение блокировки для чтения
}

lock.writeLock().lock(); // Захват блокировки для записи
try {
    // Код, разрешенный для записи
} finally {
    lock.writeLock().unlock(); // Освобождение блокировки для записи
}
```
Выбор механизма синхронизации зависит от конкретных требований вашего приложения и характера общих ресурсов.

[наверх](#java-concurrency)

## `deadlocks` и как их избегать

`Deadlock` (заморозка) - это ситуация в многозадачной среде, когда два или более потока (или процесса) оказываются заблокированными и ждут друг друга, чтобы освободить ресурсы, которые они не могут освободить сами. В результате приложение останавливается, и ни один из потоков не может продолжить выполнение.

`Deadlock` можно представить как ситуацию, когда несколько потоков захватывают блокировки (`lock`) над ресурсами, и каждый из них ждет освобождения ресурса, который заблокирован другим потоком. Как только все потоки находятся в таком состоянии ожидания, они останавливаются и не могут двигаться дальше.

Для предотвращения и избегания `deadlock` следует придерживаться следующих практик:

1. **Избегайте вложенных блокировок**: Постарайтесь избегать ситуаций, когда один поток пытается получить блокировку, которая уже захвачена им же, или когда поток пытается получить несколько блокировок в разном порядке. Если это необходимо, используйте атомарные операции или библиотеки для управления ресурсами.

2. **Устанавливайте ограниченное время блокировки (`Timeout`)**: Если потребность в блокировке ресурса длится слишком долго, потоки могут быть вынуждены освободить ресурс или предпринять другие действия.

3. **Используйте `tryLock`**: Некоторые языки программирования и библиотеки предоставляют методы `tryLock`, которые позволяют потокам попытаться получить блокировку и вернуть управление, если блокировка недоступна, вместо ожидания. Это позволяет избежать `deadlock` в случае, если блокировка не может быть получена.

4. **Используйте `Livelock` или `Lock Avoidance` алгоритмы**: Эти методы представляют собой более сложные стратегии для управления ресурсами, которые могут избегать блокировок или разрешать их, если они возникают.

5. **Планируйте порядок блокировок**: Если ваше приложение обязательно должно захватывать несколько блокировок, установите строгий порядок их захвата, чтобы избежать возможных `deadlock` ситуаций.

6. **Используйте библиотеки и инструменты**: Существуют различные библиотеки и инструменты, такие как Java's `java.util.concurrent` и инструменты анализа кода, которые могут помочь выявить и предотвратить deadlock.

`Deadlock` может быть сложной проблемой, и его избегание требует осторожности и понимания, как устроены блокировки в вашей системе. Правильное проектирование и тестирование кода также помогут предотвратить появление `deadlock`.

[наверх](#java-concurrency)

## Ключевое слово `volatile`

Ключевое слово `volatile` используется в `Java` для обозначения переменных, которые могут быть изменены разными потоками. Оно оказывает влияние на то, как переменные хранятся в памяти и как к ним обращаются потоки. Вот как можно использовать `volatile`:

1. **Объявление переменных как** `volatile`: Чтобы объявить переменную как `volatile`, используйте ключевое слово `volatile` перед объявлением переменной. Например:
```java
public volatile boolean isRunning = true;
```
2. **Синхронизация переменных**: Переменные, объявленные как `volatile`, гарантируют, что их изменения видны всем потокам. Это значит, что если один поток изменяет значение `volatile` переменной, другие потоки увидят это изменение. Однако, `volatile` не обеспечивает атомарности операций, поэтому для более сложных операций, требующих атомарности, следует использовать другие механизмы синхронизации, такие как synchronized блоки или `java.util.concurrent` классы.

3. **Использование для `флагов` остановки потоков**: Один из наиболее распространенных примеров использования `volatile` - это для флагов, которые управляют выполнением потоков. Например, можно использовать `volatile boolean` флаг для безопасной остановки потока:

```java
public class MyThread extends Thread {
    private volatile boolean isRunning = true;

    public void run() {
        while (isRunning) {
            // Выполняйте какие-то действия
        }
    }

    public void stopThread() {
        isRunning = false;
    }
}
```
4. **Не используйте для операций, зависящих от предыдущих значений**: `volatile` подходит для простых случаев, когда вы просто хотите, чтобы изменения переменных были видны другим потокам. Однако, если ваши операции зависят от предыдущих значений переменных или требуют атомарности, лучше использовать другие механизмы синхронизации, такие как `synchronized` или `java.util.concurrent` классы.

**Будьте осторожны:** Использование `volatile` должно быть осознанным действием, так как оно может повлиять на производительность. В большинстве случаев, использование более сложных механизмов синхронизации, если это необходимо, может быть более эффективным и безопасным способом управления многопоточностью.

[наверх](#java-concurrency)

## Многозадачность, её реализация в Java

Многозадачность (`concurrency`) - это способность программы выполнять несколько задач или потоков выполнения одновременно. Это позволяет эффективно использовать ресурсы многопроцессорных систем и обеспечивает отзывчивость приложений. В Java многозадачность реализуется с использованием многопоточности.

В Java создание и управление потоками выполняется с помощью класса `Thread` и интерфейса `Runnable`. Вот пример создания потока в Java:

```java
public class MyThread extends Thread {
    public void run() {
        // Код, который будет выполняться внутри потока
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread();
        thread1.start(); // Запуск потока
    }
}
```
Также можно использовать интерфейс `Runnable` для создания потоков:

```java
Copy code
public class MyRunnable implements Runnable {
    public void run() {
        // Код, который будет выполняться внутри потока
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread2 = new Thread(myRunnable);
        thread2.start(); // Запуск потока
    }
}
```
Когда вы запускаете поток, он начинает выполнение метода `run()`. Вы также можете использовать синхронизацию и другие механизмы управления потоками для управления параллельным выполнением кода.

Java также предоставляет более высокоуровневые средства для работы с многозадачностью, такие как класс `ExecutorService` и пакет `java.util.concurrent`, который предоставляет более удобные и эффективные способы управления потоками и выполнения параллельных задач.

[наверх](#java-concurrency) | 
[назад](../README.md)