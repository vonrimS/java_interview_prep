# `JAVA CORE` 

[назад](../README.md)

* [Что такое `Java`](#что-такое-java)
* [Что в себя включает платформа `Java`](#что-в-себя-включает-платформа-java)
* [В чем разница между `JDK`, `JRE` и `JVM`](#в-чем-разница-между-jdk-jre-и-jvm)
* [Типы данных](#типы-данных)
* [Класс `Object` и его методы](#класс-object-и-его-методы)
* [Модификаторы доступа](#модификаторы-доступа)
* [Доступ к `private`-переменной класса](#доступ-к-private-переменной-класса)
* [Что такое переменная в `Java`](#что-такое-переменная-в-java)
* [Что означает `public static void main(String[] args)`](#что-означает-public-static-void-mainstring[]-args)
* [Ключевое слово static и как его использовать](#ключевое-слово-static-и-как-его-использовать)
* [Контракт `equals()` и `hashCode()`](#контракт-equals-и-hashcode)
* [Могут ли быть объекты равны по `equals()`, но иметь разный `hashCode`](#могут-ли-быть-объекты-равны-по-equals-но-иметь-разный-hashcode)
* [Как объявить и вызвать метод в `Java`](#как-объявить-и-вызвать-метод-в-java)
* [Конструкторы в `Java`, какие типы существуют](#конструкторы-в-java-какие-типы-существуют)
* [Зачем нужны и какие бывают блоки инициализации](#зачем-нужны-и-какие-бывают-блоки-инициализации)
* [Разница между `классом` и `объектом`](#разница-между-классом-и-объектом)
* [Типы классов в `Java`](#типы-классов-в-java)
* [Обрабатываемые и необрабатываемые `исключения`](#обрабатываемые-и-необрабатываемые-исключения)
* [Какие исключения могут возникнуть в `Java`, и как их обрабатывать](#какие-исключения-могут-возникнуть-в-java-и-как-их-обрабатывать)
* [Ключевое слово `abstract`](#ключевое-слово-abstract)
* [Абстрактный класс и интерфейс, какие различия](#aбстрактный-класс-и-интерфейс-какие-различия)
* [Уровни абстракции - класс, абстрактный класс, интерфейс](#уровни-абстракции---класс-абстрактный-класс-интерфейс)
* [`Default` методы и их применение](#default-методы-и-их-применение)
* [Что такое `аннотации` в `Java`](#что-такое-аннотации-в-java)
* [Aннотации связаные с `обобщениями`](#aннотации-связаные-с-обобщениями)
* [`Marker`-интерфейсы](#marker-интерфейсы)
* [Переопределение `Overriding`](#переопределение-overriding)
* [Перегрузка `Overloading`](#перегрузка-overloading)
* [Получение доступа к `переопределенным методам` родительского класса](#получение-доступа-к-переопределенным-методам-родительского-класса)
* [Чтение данных из консоли в `Java`](#чтение-данных-из-консоли-в-java)
* [Как записать данные в файл в `Java`](#как-записать-данные-в-файл-в-java)
* [Как считать данные из файла в `Java`](#как-считать-данные-из-файла-в-java)
* [Иерархия исключений в `Java`](#иерархия-исключений-в-java)
* [Как обработать исключение в Java с помощью `try-catch` блока](#как-обработать-исключение-в-java-с-помощью-try-catch-блока)
* [Что такое `finally` блок и для чего он используется](#что-такое-finally-блок-и-для-чего-он-используется)
* [В каких случаях `finally` не будет исполнен](#в-каких-случаях-finally-не-будет-исполнен)
* [Как создать и использовать пользовательские исключения](#как-создать-и-использовать-пользовательские-исключения)




## Что такое `Java`

`Java` - это высокоуровневый, объектно-ориентированный язык программирования, который разработан компанией Sun Microsystems (теперь часть Oracle Corporation) и был выпущен в 1995 году. `Java` изначально разрабатывалась для создания программного обеспечения для интерактивных телевизоров, но впоследствии стала популярным языком для создания разнообразных приложений, включая веб-приложения, мобильные приложения, корпоративные системы и многое другое.

`Java` является мультиплатформенным языком программирования, что означает, что программы, написанные на Java, могут выполняться на разных операционных системах без изменений. Это достигается благодаря использованию виртуальной машины Java (`JVM` - Java Virtual Machine), которая интерпретирует байт-код, созданный компилятором Java, и выполняет программу на конкретной платформе.

Java имеет ряд особенностей и преимуществ, включая:

* `Портабельность`: Благодаря JVM, Java-приложения могут работать на разных платформах без изменений в исходном коде.

* `Объектно-ориентированный подход`: Java поддерживает принципы объектно-ориентированного программирования (ООП), такие как инкапсуляция, наследование и полиморфизм.

* `Безопасность`: Java имеет множество встроенных механизмов безопасности, что делает его подходящим для создания надежных приложений.

* `Большая стандартная библиотека`: Java поставляется с обширной стандартной библиотекой, содержащей множество классов и методов для различных задач, что упрощает разработку приложений.

* `Поддержка многопоточности`: Java предоставляет мощные средства для работы с многопоточностью, что позволяет создавать эффективные многозадачные приложения.

`Java` остается одним из наиболее популярных языков программирования в мире и используется во многих сферах IT-индустрии, включая разработку мобильных приложений, веб-приложений, серверных приложений и многое другое.

[наверх](#java-core)

## Что в себя включает платформа `Java`

Платформа `Java` включает в себя два основных компонента:

1. `Java Virtual Machine` (JVM): Это виртуальная машина, которая выполняет байт-код, созданный компилятором Java, и обеспечивает выполнение Java-приложений на разных операционных системах без изменений в исходном коде. `JVM` является ключевым компонентом, обеспечивающим портабельность Java-приложений.

2. `Java Standard Library` (Java API): Это обширная библиотека классов и методов, предоставляемая Java для решения различных задач программирования. Она включает в себя классы для работы с вводом/выводом, сетью, коллекциями данных, графическим интерфейсом и многие другие функции. `Java API` делает разработку Java-приложений более удобной и эффективной.

Платформа Java также включает в себя следующие компоненты и инструменты:

* `Java Development Kit` (JDK): `JDK` представляет собой комплект инструментов для разработки Java-приложений. Он включает в себя компилятор Java, библиотеки и утилиты для разработки и отладки кода.

* `Java Runtime Environment` (JRE): `JRE` включает в себя `JVM` и минимальный набор библиотек, необходимых для выполнения Java-приложений. Пользователи, которые хотят только запускать Java-приложения, обычно устанавливают `JRE`.

* `Java EE` (Enterprise Edition): Это набор спецификаций и библиотек для разработки корпоративных приложений, включая веб-приложения, сервисы и многозадачные приложения. `Java EE` предоставляет средства для создания масштабируемых и надежных приложений для предприятий.

* `Java ME` (Micro Edition): Это набор технологий для разработки мобильных и встроенных приложений. `Java ME` позволяет создавать приложения, работающие на устройствах с ограниченными ресурсами.

* `JavaFX`: Это среда для создания интерактивных графических приложений, таких как приложения с графическим пользовательским интерфейсом (`GUI`) и мультимедийные приложения.

Платформа `Java` известна своей портабельностью, надежностью и безопасностью, что делает ее популярным выбором для разработки разнообразных приложений в различных областях. `Java` также имеет активное сообщество разработчиков и богатый экосистемный инструментарий, что делает ее мощным инструментом для программирования.

[наверх](#java-core)

## В чем разница между `JDK`, `JRE` и `JVM`
`JDK` (Java Development Kit), `JRE` (Java Runtime Environment) и `JVM` (Java Virtual Machine) - это ключевые компоненты платформы `Java`, но они выполняют разные роли в процессе разработки и выполнения Java-приложений. Вот их основные различия:

* `JDK` (Java Development Kit):

    * JDK представляет собой комплект инструментов для разработки Java-приложений.
    * Он включает в себя компилятор Java (javac), который преобразует исходный код Java в байт-код.
    * JDK также включает в себя библиотеки и классы, необходимые для разработки Java-приложений.

    * Разработчики используют JDK для создания, компиляции и отладки Java-кода.
    * `JDK` также включает в себя `JRE`.
* `JRE` (Java Runtime Environment):

    * JRE представляет собой среду выполнения Java-приложений.
    * Он включает в себя JVM (Java Virtual Machine), которая выполняет байт-код Java, и минимальный набор библиотек, необходимых для выполнения Java-приложений.
    * Пользователи, которые хотят только запускать Java-приложения, обычно устанавливают JRE.
    * JRE не включает в себя компилятор Java и инструменты для разработки, такие как javac.
* `JVM` (Java Virtual Machine):

    * JVM - это виртуальная машина, которая выполняет байт-код Java.
    * Она является частью JRE и обеспечивает выполнение Java-приложений на конкретной платформе.
    * JVM интерпретирует байт-код или может использовать JIT-компиляцию (Just-In-Time compilation), чтобы компилировать байт-код в машинный код для более быстрого выполнения.
    * JVM обеспечивает портабельность Java-приложений, так как один и тот же байт-код может выполняться на разных операционных системах, где есть подходящая JVM.

Вкратце, `JDK` - это инструменты для разработки, `JRE` - среда выполнения для конечных пользователей, а `JVM` - виртуальная машина, которая фактически выполняет Java-приложения. В процессе разработки вы используете `JDK`, а конечные пользователи вашего приложения будут использовать `JRE` для его выполнения.


[наверх](#java-core) 

## Типы данных

Примитивные типы данных: 
* `byte`: 8-битное целое число. Диапазон значений от -128 до 127.
* `short`: 16-битное целое число. Диапазон значений от -32,768 до 32,767.
* `int`: 32-битное целое число. Диапазон значений от -2^31 до 2^31-1.
* `long`: 64-битное целое число. Диапазон значений от -2^63 до 2^63-1.
* `float`: 32-битное число с плавающей точкой одинарной точности.
* `double`: 64-битное число с плавающей точкой двойной точности.
* `char`: 16-битный символьный тип данных, представляющий символ Unicode.
* `boolean`: Логический тип данных, который может принимать значения true или false.

Ссылочные типы данных:
* `String`: Строковый тип данных, представляющий последовательность символов.
* `Array` (массивы): Ссылочные типы данных, представляющие упорядоченные коллекции элементов одного типа.
* `Class` (классы): Тип данных, представляющий пользовательские типы данных, определенные программистом.
* `Interface` (интерфейсы): Тип данных, представляющий интерфейс, описывающий методы, которые должны быть реализованы классами.
* `Enum` (перечисления): Тип данных, представляющий фиксированный список констант.
* `Other Reference Types` (другие ссылочные типы): В Java также есть множество встроенных и пользовательских ссылочных типов данных, таких как списки (List), множества (Set), отображения (Map), классы для работы с датой и временем и многие другие.

[наверх](#java-core) 


## Класс `Object` и его методы

Класс `java.lang.Object` является корневым классом для всех классов в `Java` и наследуется всеми объектами в языке `Java`. Этот класс определяет некоторые основные методы и функциональность, которые доступны для всех объектов в `Java`. Вот некоторые из наиболее часто используемых методов класса `Object`:

### equals(Object obj)
Метод используется для сравнения объектов на равенство. По умолчанию (в реализации класса Object), этот метод выполняет сравнение по ссылке, что означает, что два объекта равны только в том случае, если это один и тот же объект. Однако этот метод часто переопределяется в пользовательских классах для выполнения сравнения по содержимому.

### hashCode()
Метод возвращает хеш-код объекта. Хеш-код - это целое число, которое обычно используется для оптимизации поиска и хранения объектов в хеш-таблицах и других структурах данных.

### toString()
Метод возвращает строковое представление объекта. По умолчанию, этот метод возвращает строку, состоящую из имени класса и хеш-кода объекта. Метод toString() также часто переопределяется в пользовательских классах для предоставления более информативного представления объекта.

### getClass()
Метод возвращает объект класса `java.lang.Class`, представляющий класс текущего объекта.

### clone()
Метод создает и возвращает копию объекта. Для корректного клонирования объекта требуется, чтобы класс поддерживал интерфейс Cloneable и переопределял метод clone().

### notify(), notifyAll(), wait()
Методы используются для синхронизации потоков выполнения и работают в контексте многопоточности.

### finalize()
Метод вызывается сборщиком мусора перед удалением объекта и может быть переопределен для выполнения завершающих операций, таких как освобождение ресурсов.

Поскольку все классы в Java являются наследниками класса `Object`, методы этого класса доступны для всех объектов в языке `Java`.

[наверх](#java-core) 

## Модификаторы доступа

Модификаторы доступа в Java определяют видимость и доступность классов, методов, полей и других членов класса. В Java существуют четыре основных модификатора доступа:

* `public`: Члены с модификатором public доступны из любой части программы. Это наиболее открытый уровень доступа.

* `private`: Члены с модификатором private доступны только внутри того же класса, в котором они объявлены. Они недоступны извне класса.

* `protected`: Члены с модификатором protected доступны внутри того же пакета и также доступны для подклассов (наследующих классов) из любого пакета.

* `package-private` (по умолчанию): Если член не имеет явно указанного модификатора доступа (`public`, `private`, или `protected`), то он доступен только внутри того же пакета. Этот модификатор называется также `по умолчанию`.

```java
public class MyClass {
    public int publicField; // Доступен из любой части программы

    private int privateField; // Доступен только внутри класса

    protected int protectedField; // Доступен внутри класса и подклассам

    int packagePrivateField; // Доступен только внутри того же пакета
}
```

[наверх](#java-core) 

## Доступ к `private`-переменной класса

`private`-переменные класса в Java являются членами класса, которые доступны только внутри этого класса. Они недоступны за пределами класса, включая его подклассы. Доступ к `private`-переменным напрямую извне класса запрещен.

Однако есть несколько способов получить доступ к `private`-переменным:

### 1. Использование `геттеров` и `сеттеров`:
Создание публичных методов-геттеров и методов-сеттеров в классе, которые позволяют получить и установить значения `private`-переменных. Это позволяет контролировать доступ к переменным и применять логику при их доступе.

Пример:

```java
public class MyClass {
    private int privateField;

    public int getPrivateField() {
        return privateField;
    }

    public void setPrivateField(int value) {
        privateField = value;
    }
}
```

### 2. Рефлексия (`Reflection API`):
С использованием рефлексии можно получить доступ к `private`-переменным, даже если это нарушает инкапсуляцию. Однако рефлексия является мощным инструментом и может создавать проблемы с безопасностью и стабильностью приложения. Рекомендуется использовать рефлексию осторожно.

Пример использования рефлексии для доступа к `private`-переменной:

```java
import java.lang.reflect.Field;

public class Main {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        MyClass obj = new MyClass();
        
        Field privateField = MyClass.class.getDeclaredField("privateField");
        privateField.setAccessible(true);
        
        int value = (int) privateField.get(obj);
        System.out.println("Значение privateField: " + value);
    }
}
```

Обратите внимание, что использование рефлексии для доступа к `private`-переменным может нарушать инкапсуляцию и приводить к нежелательным эффектам. Оно должно применяться только в случаях крайней необходимости и с осторожностью.


[наверх](#java-core) 


## Что такое переменная в `Java`
Это именованная область памяти, которая используется для хранения данных. Каждая переменная имеет определенный тип данных, который определяет, какие значения могут быть сохранены в этой переменной, и операции, которые можно выполнять над этими значениями.


Переменная в Java - это именованная область памяти, которая используется для хранения данных. Каждая переменная имеет определенный тип данных, который определяет, какие значения могут быть сохранены в этой переменной, и операции, которые можно выполнять над этими значениями.

В Java переменные делятся на два основных типа:

1. **Примитивные переменные** (Primitive Variables): Эти переменные хранят примитивные типы данных, такие как целые числа, числа с плавающей точкой, символы и логические значения. Примитивные переменные хранят сами значения, а не ссылки на объекты. Примеры примитивных типов данных в Java: int, double, char, boolean, и другие.

```java
int age = 30;
double salary = 1000.50;
char grade = 'A';
boolean isActive = true;
```
2. **Ссылочные переменные** (Reference Variables): Эти переменные хранят ссылки на объекты. Объекты могут быть экземплярами классов или массивами. Ссылочные переменные не содержат сами объекты, они указывают на местоположение объекта в памяти. В `Java` все классы и массивы являются ссылочными типами данных.
```java
String name = "John"; // name - ссылочная переменная, указывающая на объект String
MyClass myObject = new MyClass(); // myObject - ссылочная переменная, указывающая на экземпляр класса MyClass
```
Переменные в `Java` должны быть объявлены с указанием их типа и могут быть инициализированы начальным значением. Переменные могут изменять свое значение в процессе выполнения программы (если они не объявлены как `final`, что делает их неизменными).

[наверх](#java-core)

## Что означает `public static void main(String[] args)`

`public static void main(String[] args)` - это сигнатура метода `main` в языке программирования `Java`. Этот метод является входной точкой для запуска `Java`-приложения.

* `public`: Этот модификатор доступа позволяет методу быть доступным из любого места внутри и за пределами класса.

* `static`: Этот модификатор означает, что метод принадлежит классу, а не объекту этого класса. Метод main является статическим, потому что он вызывается до создания объектов класса.

* `void`: Это ключевое слово, указывающее на то, что метод main не возвращает какое-либо значение.

* `main`: Это имя метода.

* `(String[] args)`: Это список параметров метода. В данном случае, метод `main` принимает один аргумент - массив строк (`args`), который может использоваться для передачи аргументов командной строки в приложение.

Когда вы запускаете `Java`-приложение, виртуальная машина `Java (JVM)` ищет метод `main` в указанном классе и начинает выполнение программы с этого метода.

[наверх](#java-core) 

## Ключевое слово `static` и как его использовать

Ключевое слово `static` в Java используется для создания статических членов класса, которые принадлежат самому классу, а не его экземплярам. Это означает, что статические члены существуют в единственном экземпляре в памяти и могут быть доступны без создания объекта класса. Когда член класса объявлен как `static`, он доступен через имя класса, а не через экземпляр класса.

В Java можно создавать следующие статические члены класса:

1. **Статические поля (Static Fields)**: Это переменные, которые принадлежат классу, а не экземплярам класса. Они используются, например, для хранения общих данных, доступных всем объектам класса. Объявляются с использованием ключевого слова `static`.

```java
public class MyClass {
    static int count = 0; // Статическое поле, хранит количество созданных объектов
}
```
2. **Статические методы (Static Methods)**: Это методы, которые принадлежат классу, а не экземплярам класса. Они могут быть вызваны без создания объекта класса. Объявляются с использованием ключевого слова `static`.

```java
public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }
}
```
3. **Статические блоки инициализации (Static Initialization Blocks)**: Это блоки кода, которые выполняются один раз при загрузке класса. Они используются, например, для инициализации статических полей.

```java
public class MyClass {
    static {
        // Инициализация статических полей
        count = 0;
    }
}
```
Использование статических членов класса полезно в следующих случаях:

* Когда нужно обеспечить доступ к данным или функциональности без создания экземпляра класса.
* Когда нужно совместно использовать данные между всеми экземплярами класса.
* Когда нужно выполнить инициализацию, которая должна произойти только один раз при загрузке класса.

```java
public class MyClass {
    static int count = 0; // Статическое поле

    public MyClass() {
        count++; // Увеличиваем счетчик при создании нового объекта
    }

    public static int getCount() { // Статический метод
        return count;
    }
}
```
```java
int total = MyClass.getCount(); // Вызов статического метода без создания объект
```

[наверх](#java-core) 



## Контракт `equals()` и `hashCode()`

В Java методы `equals()` и `hashCode()` играют важную роль при работе с объектами. Они связаны друг с другом, и правильная их реализация позволяет корректно использовать объекты в коллекциях, таких как `HashSet` и `HashMap`. Вот связь и рекомендации по реализации этих методов:

### 1. Связь между `equals()` и `hashCode()`:

* `equals()`:   
Этот метод используется для сравнения содержимого двух объектов на равенство. По умолчанию, equals() сравнивает объекты по ссылке (т.е., они равны только в случае, если это один и тот же объект). Однако **в большинстве случаев разработчики переопределяют метод equals(), чтобы сравнивать объекты на основе их содержимого.**

* `hashCode()`:    
Этот метод возвращает целочисленное значение, называемое хеш-кодом объекта. Хеш-код представляет собой "отпечаток" объекта и используется для быстрого поиска объекта в хеш-таблицах, таких как `HashSet` и `HashMap`. Важно, чтобы хеш-код объекта оставался неизменным во времени и был согласованным с методом `equals()`, то есть если два объекта равны согласно методу `equals()`, их хеш-коды должны быть равными.

### 2. Рекомендации по реализации `equals()`:

* Переопределите метод equals() в своем классе, чтобы сравнивать объекты на основе их содержимого, а не на основе ссылок.

* Проверяйте, является ли переданный объект null, и возвращайте false, если это так.

* Проверяйте, является ли переданный объект экземпляром вашего класса, прежде чем сравнивать его с текущим объектом.

* Сравнивайте каждое поле вашего объекта с соответствующим полем другого объекта, используя методы equals() для сравнения полей.

### 3. Рекомендации по реализации `hashCode()`:

* Хеш-код объекта должен быть вычисляемым на основе полей объекта, которые используются при сравнении в методе equals().

* Если два объекта равны согласно методу equals(), их хеш-коды должны быть одинаковыми.

* При вычислении хеш-кода используйте поля объекта, которые не изменяются во времени.

* Избегайте возвращать константные значения для хеш-кода, так как это может привести к коллизиям (разным объектам с одинаковыми хеш-кодами).

* Если переопределяете equals(), обязательно переопределите и hashCode().

Пример реализации `equals()` и `hashCode()` для класса `Person`:

```java
public class Person {
    private String name;
    private int age;

    // Конструктор и геттеры/сеттеры

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

В этом примере методы `equals()` и `hashCode()` учитывают поле name и age при сравнении объектов. Важно использовать `Objects.hash()`, чтобы вычислить хеш-код на основе полей класса.

[наверх](#java-core)


## Могут ли быть объекты равны по `equals()`, но иметь разный `hashCode`

Да, это возможно. Объекты могут быть равными согласно методу `equals()`, но иметь разные значения хеш-кода (или наоборот). Это может произойти, если не соблюдаются следующие правила:

1. **Правило согласованности**:   
Если два объекта равны согласно методу `equals()`, их хеш-коды должны быть одинаковыми. То есть, если `a.equals(b) == true`, то `a.hashCode() == b.hashCode()`.

2. **Правило недопустимости изменения хеш-кода**:    
Хеш-код объекта должен оставаться неизменным во времени, пока не изменяются поля, используемые для вычисления хеш-кода. Если какое-либо из этих полей изменяется после создания объекта, это может привести к различным значениям хеш-кода для одного и того же объекта.

3. **Правило коллизий**:    
Разные объекты могут иметь одинаковые значения хеш-кода, и это нормально. Однако, если два объекта имеют разные значения полей и одинаковые хеш-коды, это называется коллизией хеш-кода.

Нарушение этих правил может привести к некорректному поведению при использовании объектов в коллекциях, таких как `HashSet` и `HashMap`. Коллизии хеш-кода могут привести к неправильной работе алгоритмов поиска и хранения, что может привести к неожиданным результатам и некорректному доступу к данным.

Поэтому важно соблюдать эти правила при реализации методов `equals()` и `hashCode()` для классов, которые используются в коллекциях или при сравнении объектов. Соблюдение этих правил обеспечивает корректное поведение объектов при работе с хеш-таблицами и другими структурами данных.




[наверх](#java-core) 

## Как объявить и вызвать метод в `Java`

В `Java` метод объявляется внутри класса и может быть вызван в других частях вашего кода, предоставив имя класса и имя метода. Вот как объявить и вызвать метод в `Java`:
```java
public class MyClass {
    // Объявление метода без параметров и возвращаемого значения
    public void myMethod() {
        // Тело метода
        System.out.println("Привет, это мой метод!");
    }

    // Объявление метода с параметрами и возвращаемым значением
    public int add(int a, int b) {
        int sum = a + b;
        return sum;
    }
}
```
В приведенном выше коде `MyClass` - это класс, который содержит два метода: `myMethod` и `add`. `myMethod` не принимает параметров и не возвращает значения, а `add` принимает два целых числа и возвращает их сумму.

```java
public class Main {
    public static void main(String[] args) {
        MyClass myObject = new MyClass(); // Создание объекта класса MyClass
        myObject.myMethod(); // Вызов метода без параметров и возвращаемого значения

        int result = myObject.add(5, 3); // Вызов метода с параметрами и возвращаемым значением
        System.out.println("Результат сложения: " + result);
    }
}
```
В методе `main` создается объект `myObject` класса `MyClass`, и мы вызываем его методы `myMethod` и `add`. Вызов метода происходит с использованием оператора . после имени объекта, за которым следует имя метода и, если необходимо, передаются параметры.

При запуске программы вы увидите вывод на консоль:
```cmd
Привет, это мой метод!
Результат сложения: 8
```
Таким образом, объявление и вызов методов - это основная концепция в ООП, которая позволяет структурировать код и повторно использовать функциональность.

[наверх](#java-core) 

## Конструкторы в `Java`, какие типы существуют

В `Java` конструктор - это специальный `метод` класса, который вызывается при создании объекта этого класса. Конструкторы используются для инициализации объектов, устанавливая начальные значения полей и выполняя другие необходимые действия.

В `Java` существуют два основных типа конструкторов:

1. **Параметризованный конструктор** (`Parameterized Constructor`): Этот тип конструкторов принимает аргументы или параметры, которые передаются при создании объекта. Он используется для инициализации объекта с определенными значениями. 

```java
public class MyClass {
    private int number;
    private String text;

    // Параметризованный конструктор
    public MyClass(int num, String txt) {
        number = num;
        text = txt;
    }
}
```
2. **Конструктор по умолчанию** (`Default Constructor`): Если в классе не определен явно ни один конструктор, компилятор `Java` создает конструктор по умолчанию без параметров. Этот конструктор не выполняет никаких дополнительных действий и устанавливает начальные значения полей в их значения по умолчанию (нулевое значение для числовых типов, `null` для ссылочных типов). 

```java
public class MyClass {
    private int number;
    private String text;

    // Конструктор по умолчанию
    public MyClass() {
        // Начальные значения полей устанавливаются автоматически
    }
}
```
Помимо этих **двух основных** типов, существуют также:

3. **Конструкторы копирования** (`Copy Constructors`): Эти конструкторы принимают объект того же класса и создают новый объект, идентичный переданному. Они используются для создания копий объектов.

```java
public class MyClass {
    private int number;

    // Конструктор копирования
    public MyClass(MyClass other) {
        number = other.number;
    }
}
```
4. **Конструкторы с инициализаторами** (`Initializer Constructors`): Это конструкторы, которые принимают аргументы и выполняют их инициализацию с использованием инициализаторов.

```java
public class MyClass {
    private int number;

    // Конструктор с инициализатором
    public MyClass(int num) : number = num {
        // Дополнительные действия
    }
}
```
Выбор типа конструктора зависит от требований вашего класса и того, какие начальные значения вы хотите установить при создании объектов.

[наверх](#java-core) 

## Зачем нужны и какие бывают `блоки инициализации`

`Блоки инициализации` в Java представляют собой участки кода внутри класса, которые выполняются при создании объекта этого класса или при загрузке класса. Они позволяют выполнять определенные действия до инициализации объекта или во время инициализации класса. Блоки инициализации бывают двух видов:

### 1.`Static Initialization Block`:

Статический блок инициализации выполняется один раз, при загрузке класса в `JVM` (Java Virtual Machine).
Он часто **используется для инициализации статических переменных и выполнения других операций, которые должны быть выполнены однократно для всего класса**.

Пример статического блока инициализации:

```java
public class MyClass {
    private static int staticVariable;

    static {
        // Инициализация статической переменной
        staticVariable = 10;
        System.out.println("Статический блок инициализации выполнен");
    }
}
```
### 2. `Instance Initialization Block`:
**Нестатический блок инициализации выполняется каждый раз при создании нового объекта класса.**
Он может использоваться для инициализации экземплярных переменных, выполнения какой-либо логики при создании объекта и так далее.

Пример нестатического блока инициализации:

```java
public class MyClass {
    private int instanceVariable;

    {
        // Инициализация экземплярной переменной
        instanceVariable = 20;
        System.out.println("Нестатический блок инициализации выполнен");
    }
}
```

Использование блоков инициализации полезно, когда требуется выполнить какие-либо действия при создании объектов или при загрузке класса. Они обеспечивают более гибкую инициализацию по сравнению с конструкторами и могут быть полезными, например, при работе с исключениями, инициализацией статических ресурсов, проверкой данных перед созданием объектов и многими другими сценариями.

[наверх](#java-core) 

## Разница между `классом` и `объектом`

`Класс` и `объект` - это два основных концепта объектно-ориентированного программирования (ООП). Вот их различия:

1. `Класс`:

    * Класс является абстрактным шаблоном или чертой, описывающей состояние и поведение объектов.
    * Класс определяет атрибуты (поля) и методы (функции), которые будут доступны объектам этого класса.
    * Он служит как "конструктор" для создания объектов. Из класса можно создать несколько объектов.
    * Класс сам по себе не имеет значений или данных. Он предоставляет определение для создания объектов.
2. `Объект`:

    * Объект - это конкретный экземпляр класса, созданный на основе его определения.
    * Объект имеет свое собственное состояние, определенное значениями его полей (атрибутов).
    * Он также имеет поведение, определенное методами класса, которые можно вызвать для выполнения операций с объектом.
    * Объекты являются реальными данными, которые манипулируются и используются в программе.

Предположим, у вас есть класс `Собака`. Класс `Собака` определяет атрибуты, такие как `имя`, `возраст` и `порода`, а также методы, такие как `лаять` и `кушать`. Когда вы создаете объект на основе этого класса, например, `мойПес`, вы создаете конкретного представителя собаки с определенными характеристиками и способностями.

```java
class Dog {
    String name;
    int age;
    String breed;

    void bark() {
        System.out.println(name + " лает!");
    }

    void eat() {
        System.out.println(name + " кушает.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog(); // Создание объекта "myDog" на основе класса "Dog"
        myDog.name = "Рэкс";
        myDog.age = 3;
        myDog.breed = "Лабрадор";

        myDog.bark(); // Вызов метода "лаять" для объекта "myDog"
        myDog.eat();  // Вызов метода "кушать" для объекта "myDog"
    }
}
```
В этом примере `Dog` - это класс, который определяет общие характеристики и действия собак, а `myDog` - это объект, который представляет конкретную собаку с определенными значениями атрибутов.

[наверх](#java-core) 


## Типы классов в Java

В `Java` существует несколько типов классов в зависимости от их назначения и свойств. Вот основные типы классов в `Java`:

### 1. Обычные классы
Это классы, которые создаются разработчиком для определения структуры данных, поведения и методов объектов. Обычные классы могут быть инстанциированы (созданы в виде объектов) и использованы для создания экземпляров.
```java
class MyClass {
    // Поля и методы класса
}
```

### 2. Абстрактные классы
Абстрактный класс является классом, который не может быть инстанциирован (создан в виде объекта). Он предоставляет общий интерфейс и может содержать абстрактные методы, которые должны быть реализованы в подклассах.
```java
abstract class MyAbstractClass {
    // Абстрактные методы и/или обычные методы
}
```

### 3. Интерфейсы
Интерфейс определяет абстрактный контракт, который классы могут реализовывать. Он содержит только абстрактные методы (без тела) и статические поля. Классы могут реализовывать несколько интерфейсов.

```java
interface MyInterface {
    // Абстрактные методы
}
```

### 4. Вложенные классы (Nested Classes)
Это классы, объявленные внутри других классов. В Java существуют четыре типа вложенных классов: статические вложенные классы, внутренние классы (inner classes), локальные классы и анонимные классы.

* **Статические вложенные классы**:   
Не имеют доступа к экземплярам внешнего класса и могут быть инстанциированы независимо от внешнего класса.

* **Внутренние классы (Inner Classes)**:    
Имеют доступ к экземплярам внешнего класса и могут обращаться к их членам.

* **Локальные классы**:    
Определены внутри методов и имеют доступ к локальным переменным метода, в котором они определены.

* **Анонимные классы**:   
Это безымянные классы, создаваемые на месте и обычно используемые для реализации интерфейсов или абстрактных классов.
```java
public class AnonymousClassExample {
    public static void main(String[] args) {
        // Создаем анонимный класс, реализующий интерфейс Runnable
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Это анонимный класс, реализующий интерфейс Runnable");
            }
        };

        // Создаем и запускаем поток с использованием анонимного класса
        Thread thread = new Thread(runnable);
        thread.start();
    }
}
```

* **Финальные (Final) классы**:   
Финальный класс не может быть унаследован (расширен) другими классами. Он может быть использован для создания классов, которые не должны иметь подклассов.

```java
final class MyFinalClass {
    // ...
}
```
Это основные типы классов в Java. Каждый из них имеет свои собственные свойства и назначение, и выбор типа класса зависит от конкретных требований и задач вашей программы.

[наверх](#java-core) 

## Обрабатываемые и необрабатываемые исключения

В Java исключения делятся на две основные категории: **обрабатываемые** исключения (`checked exceptions`) и **необрабатываемые** исключения (`unchecked exceptions`).

1. **Обрабатываемые исключения** (`Checked Exceptions`): Эти исключения должны быть явно обработаны или объявлены в сигнатуре метода с использованием ключевого слова `throws`. Обрабатываемые исключения обычно представляют собой ошибки, которые могут возникнуть внутри программы и требуют обязательной обработки. Например, `IOException` или `SQLException` являются обрабатываемыми исключениями.

```java
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        try {
            // Попытка выполнить код, который может вызвать IOException
            throw new IOException("An I/O error occurred");
        } catch (IOException e) {
            // Обработка исключения
            System.err.println("Caught an IOException: " + e.getMessage());
        }
    }
}
```
2. **Необрабатываемые исключения** (`Unchecked Exceptions`): Эти исключения не требуют явной обработки или объявления в сигнатуре метода. Необрабатываемые исключения обычно являются ошибками времени выполнения (`runtime errors`) и могут возникнуть внезапно. Примерами необрабатываемых исключений являются `NullPointerException`, `ArrayIndexOutOfBoundsException` и `ArithmeticException`.

```java
public class Main {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3};
        int result = numbers[4]; // Вызовет ArrayIndexOutOfBoundsException
    }
}
```
Обычно `необрабатываемые исключения` свидетельствуют о нарушении логики программы или непредвиденных ситуациях. Хорошей практикой является предотвращение возникновения необрабатываемых исключений через проверки и корректное программирование.

Обратите внимание, что все исключения в `Java` наследуются от класса `java.lang.Throwable`, который имеет два основных подкласса: `java.lang.Exception` (для обрабатываемых исключений) и `java.lang.RuntimeException` (для необрабатываемых исключений).

[наверх](#java-core) 

## Какие исключения могут возникнуть в Java, и как их обрабатывать


В Java существует множество видов исключений, и они могут возникнуть из-за различных причин. Ниже перечислены некоторые из наиболее распространенных видов исключений, а также способы их обработки:

1. `NullPointerException`: Это исключение возникает, когда программа пытается обратиться к методу или полю объекта, который равен `null`. Обработка обычно включает проверку на `null` перед доступом к объекту.
```java
String str = null;
if (str != null) {
    // Обработка строки, которая не равна null
}
```
2. `ArrayIndexOutOfBoundsException`: Исключение возникает, когда программа пытается получить доступ к элементу массива по индексу, выходящему за его границы. Обработка включает проверку допустимых индексов перед доступом к элементам массива.
```java
int[] numbers = {1, 2, 3};
if (index >= 0 && index < numbers.length) {
    int value = numbers[index];
}
```
3. `ArithmeticException`: Это исключение возникает при арифметических операциях, таких как деление на ноль. Обработка может включать проверку делителя перед выполнением операции.
```java
int numerator = 10;
int denominator = 0;
if (denominator != 0) {
    int result = numerator / denominator;
}
```
4. `IOException`: Это общее исключение для ошибок ввода-вывода, таких как проблемы с чтением или записью файлов. Обработка включает обработку ошибок ввода-вывода, например, с использованием блока `try-catch`.
```java
try {
    // Попытка выполнить операции ввода-вывода
} catch (IOException e) {
    // Обработка ошибки ввода-вывода
}
```
5. `Custom Exceptions`: В `Java` можно создавать собственные пользовательские исключения, расширяя классы исключений, такие как `Exception` или `RuntimeException`. Это позволяет создавать исключения, которые отражают специфические ошибочные ситуации в вашей программе.

```java
public class MyCustomException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}
```
```java
try {
    // Попытка выполнить операции, которые могут вызвать MyCustomException
} catch (MyCustomException e) {
    // Обработка пользовательского исключения
}
```
Обработка исключений в `Java` выполняется с использованием блоков `try`, `catch`, `finally`, а также ключевых слов `throw` и `throws`. Правильная обработка исключений позволяет программе адекватно реагировать на ошибки и предотвращать сбои в выполнении.

[наверх](#java-core) 

## Ключевое слово `abstract`

Ключевое слово `abstract` в Java используется для определения абстрактных классов и методов. Абстрактные классы и методы имеют следующие основные характеристики и применения:

### Абстрактные `классы`:

* **Абстрактный класс (abstract class)**:     
Это класс, который не может быть инстанциирован (т.е., создан объект этого класса), но может содержать абстрактные методы и/или реализованные методы.

* Абстрактные классы используются как базовые классы для других классов. Они могут определять общее поведение и методы, которые должны быть реализованы в подклассах.

* Для объявления абстрактного класса используется ключевое слово `abstract`. 

Пример:
```java
abstract class Shape {
    abstract void draw(); // Абстрактный метод
}
```

### Абстрактные `методы`:

* **Абстрактный метод (abstract method)** - это метод, который объявлен в абстрактном классе, но не имеет реализации в этом классе. Он зависит от конкретных подклассов для его реализации.

* Абстрактные методы объявляются с ключевым словом abstract и не содержат тела метода. 

Пример:
```java
abstract void draw(); // Абстрактный метод
```

### Применение абстрактных классов и методов:

* Абстрактные классы и методы используются для создания иерархии классов, где абстрактный класс определяет общее поведение и интерфейс, а его подклассы (конкретные классы) обязаны реализовать абстрактные методы.

* Они позволяют установить структуру и ограничения для классов и обеспечивают единообразие в интерфейсах разных классов.

* Абстрактные методы вынуждают подклассы предоставить свои собственные реализации методов, что делает код более надежным и предсказуемым.

Пример использования абстрактных классов и методов может быть в области графики, где абстрактный класс `Shape` определяет общие методы для фигур (например, `draw()`), а конкретные подклассы, такие как `Circle` и `Rectangle`, реализуют эти методы согласно своей специфике.








[наверх](#java-core) 



## `Абстрактный класс` и `интерфейс`, какие различия

### Абстрактный класс (`Abstract Class`)

* Абстрактный класс может содержать как абстрактные (не имеющие реализации) методы, так и конкретные методы с реализацией.
* Абстрактный класс может иметь поля (переменные экземпляра), конструкторы и обычные методы.
* От абстрактного класса нельзя создать объект напрямую; его нужно расширить другим классом, который предоставит реализацию абстрактных методов.

```java
public abstract class Animal {
    private String name;

    public Animal(String name) {
        this.name = name;
    }

    public abstract void makeSound();

    public void eat() {
        System.out.println(name + " is eating.");
    }
}
```
### Интерфейс (`Interface`):

* Интерфейс может содержать только абстрактные методы (без реализации), статические константы (переменные, объявленные как static final) и `default` методы (начиная с Java 8).
* Класс может реализовать несколько интерфейсов одновременно, но он не может наследовать несколько классов.
* Интерфейсы предоставляют способ реализации множественного наследования в `Java`.

```java
public interface Shape {
    double getArea();
    double getPerimeter();
}
```
### Различия между `абстрактным классом` и `интерфейсом`:

1. **Реализация методов**: Абстрактный класс может содержать методы с реализацией, в то время как интерфейс содержит только абстрактные методы без реализации.
2. **Множественное наследование**: Класс может расширять только один абстрактный класс, но реализовать несколько интерфейсов.
3. **Конструкторы**: Абстрактный класс может иметь конструкторы, в то время как интерфейс не может иметь конструкторов.
4. **Поля**: Абстрактный класс может содержать поля (переменные экземпляра), а интерфейс - только статические константы.

Выбор между `абстрактным классом` и `интерфейсом` зависит от конкретных требований вашего приложения. Если вы хотите предоставить базовую реализацию методов и/или использовать поля, то абстрактный класс может быть более подходящим. Если вам нужна возможность, чтобы классы реализовывали несколько разных контрактов, то интерфейс будет более подходящим. В некоторых случаях, комбинирование абстрактных классов и интерфейсов может быть наилучшим решением.

[наверх](#java-core) 

## Уровни `абстракции` - класс, абстрактный класс, интерфейс

Уровень абстракции в Java можно рассматривать следующим образом:

### 1. Класс (`Class`):

* Класс представляет собой конкретную реализацию сущности или объекта.

* Он может содержать поля, методы, конструкторы и реализацию всех методов.

* Класс имеет самый низкий уровень абстракции, поскольку он предоставляет конкретную реализацию и может быть инстанциирован (создан объект).

### 2. Абстрактный класс (`Abstract Class`):

* Абстрактный класс находится на более высоком уровне абстракции по сравнению с обычным классом.

* Он может содержать как реализацию методов, так и абстрактные методы.

* Абстрактный класс не может быть инстанциирован, но может быть расширен (подклассами) для предоставления более конкретных реализаций.

* Абстрактные методы, определенные в абстрактном классе, предоставляют интерфейс для подклассов, требуя их реализации.

### 3. Интерфейс (`Interface`):

* Интерфейс имеет самый высокий уровень абстракции в Java.

* Он определяет только абстрактные методы, но не содержит их реализации.

* Интерфейс определяет контракт (сигнатуры методов), который классы должны реализовать.

* Классы могут реализовать несколько интерфейсов, что обеспечивает множественное наследование через интерфейсы.

### Итак, **по уровню абстракции**:

1. **Интерфейс имеет самый высокий уровень абстракции**, так как он определяет только сигнатуры методов без какой-либо реализации.
2. Абстрактный класс находится на промежуточном уровне и может предоставлять как реализацию методов, так и абстрактные методы.
3. Обычный **класс предоставляет конкретную реализацию** и имеет самый низкий уровень абстракции.

[наверх](#java-core) 


Это класс, введённый в `Java 8`, который предоставляет возможность работы с асинхронным программированием. Он представляет собой улучшенную версию `Future`, предлагая больше гибкости и контроля над асинхронными операциями.

### Основные характеристики `CompletableFuture`:

1. **Позволяет выполнять асинхронные операции**: CompletableFuture можно использовать для асинхронного выполнения задач без блокирования основного потока.

2. **Комбинирование и цепочка вызовов**: Он позволяет комбинировать несколько асинхронных операций последовательно или параллельно. Вы можете использовать методы, такие как thenApply, thenAccept, thenCompose, чтобы создать цепочку асинхронных задач.

3. **Обработка исключений**: CompletableFuture предоставляет методы для обработки исключений в асинхронных операциях, например, exceptionally.

4. **Возвращение результатов**: Он может возвращать результат выполнения задачи, в отличие от простого Future, который просто предоставляет статус завершения.

5. **Программное завершение**: Вы можете программно завершить или отменить выполнение CompletableFuture.

6. **Асинхронные методы**: Предоставляет асинхронные варианты многих методов, что позволяет задачам выполняться в другом потоке.

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // имитация длительной задачи
    try {
        TimeUnit.SECONDS.sleep(1);
    } catch (InterruptedException e) {
        throw new IllegalStateException(e);
    }
    return "Результат асинхронной задачи";
});

future.thenAccept(result -> System.out.println(result)); // обработка результата асинхронной задачи
```

### Зачем использовать `CompletableFuture`?

1. **Повышение производительности**: Асинхронные операции позволяют лучше использовать ресурсы, поскольку основной поток не блокируется в ожидании завершения операции.

2. **Улучшение масштабируемости**: Программы становятся более масштабируемыми, так как они могут обрабатывать больше операций параллельно.

3. **Больше контроля и гибкости**: `CompletableFuture` предоставляет богатый интерфейс для управления асинхронными операциями, включая комбинирование задач, обработку исключений и преобразование результатов.

В общем, `CompletableFuture` является мощным инструментом для асинхронного программирования в `Java`, позволяя создавать более эффективные и масштабируемые приложения.

[наверх](#java-core) 

## `Default` методы и их применение

В `Java 8` и более поздних версиях появилась возможность в интерфейсах определять методы с реализацией, которые называются `default` методами (или методами по умолчанию). Эти методы предоставляют реализацию по умолчанию для интерфейса и могут быть унаследованы всеми классами, реализующими этот интерфейс. `Default` методы добавляют возможность добавления новых методов в интерфейсы без необходимости изменения всех классов, реализующих этот интерфейс.

### Основные особенности `default` методов:

1. Default методы имеют реализацию по умолчанию в интерфейсе.
2. Они помечаются ключевым словом `default` перед объявлением метода.
3. Классы, реализующие интерфейс с `default` методом, могут использовать этот метод без явной реализации.
4. Если класс, реализующий интерфейс, хочет переопределить `default` метод, он может сделать это.

```java
public interface MyInterface {
    void regularMethod(); // Обычный абстрактный метод

    default void defaultMethod() {
        System.out.println("Это default метод");
    }
}
```
Класс, реализующий этот интерфейс, может использовать `default` метод без явной реализации:

```java
public class MyClass implements MyInterface {
    public void regularMethod() {
        System.out.println("Это реализация regularMethod");
    }
    
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.regularMethod(); // Вызывает реализацию regularMethod
        obj.defaultMethod(); // Вызывает default метод из интерфейса
    }
}
```
`Default` методы полезны, когда вы хотите добавить новую функциональность в существующие интерфейсы, не нарушая обратной совместимости с существующими классами, реализующими интерфейс.

[наверх](#java-core) 


## Что такое `аннотации` в Java

Аннотации (`annotations`) в Java представляют собой метаданные, которые могут быть добавлены к классам, методам, полям, параметрам методов и другим элементам кода, чтобы предоставить дополнительную информацию о программе. Аннотации используются для аннотирования кода с метаданными, которые могут быть использованы компилятором, средами разработки или другими инструментами для различных целей.

### Вот некоторые основные аспекты аннотаций в Java:

1. **Декларация аннотации**: Аннотация объявляется с использованием символа "@" перед ключевым словом interface.
```java
@interface MyAnnotation {
    // Элементы аннотации
    String value() default "";
}
```
2. **Применение аннотации**: Аннотацию можно применить к элементам кода, таким как классы, методы и поля, с использованием символа `@` перед аннотацией.
```java
@MyAnnotation("Пример аннотации")
public class MyClass {
    // ...
}
```
3. **Элементы аннотации**: Аннотации могут иметь элементы, которые могут принимать значения. В приведенном выше примере `@MyAnnotation` имеет один элемент `value()`, который может быть установлен при применении аннотации.

4. **Встроенные аннотации**: Java предоставляет несколько встроенных аннотаций, таких как `@Override`, `@Deprecated`, `@SuppressWarnings` и другие, которые используются для различных целей, таких как обозначение переопределенных методов, указание устаревших элементов и подавление предупреждений.

5. **Создание пользовательских аннотаций**: Вы можете создавать собственные пользовательские аннотации для аннотирования вашего кода и предоставления дополнительной информации.

6. **Обработка аннотаций**: Аннотации могут быть обработаны с помощью `рефлексии` во время выполнения, что позволяет анализировать аннотации и принимать решения на основе их содержания.

Аннотации используются в `Java` для различных целей, таких как документирование кода, управление компиляцией, поддержка аспектно-ориентированного программирования `AOP` и другие. Они предоставляют мощный механизм для добавления метаданных к вашему коду и управления его поведением.

[наверх](#java-core)

## Aннотации связаные с обобщениями

В языке `Java` существует несколько аннотаций, связанных с обобщенными типами (`Generics`), которые могут использоваться для добавления метаданных к обобщенному коду. Эти аннотации предоставляют информацию о типах и могут использоваться компилятором и инструментами для статической анализа кода. Вот некоторые из них:

1. `@SuppressWarnings("unchecked")`: Эта аннотация используется для подавления предупреждений компилятора о непроверенных (`unchecked`) операциях с обобщенными типами. Например:
```java
@SuppressWarnings("unchecked")
List<String> list = new ArrayList();
```
2. `@SafeVarargs`: Данная аннотация применяется к методам, которые используют переменное количество аргументов с обобщенными типами. Она позволяет компилятору гарантировать безопасность `varargs`-аргументов.
```java

@SafeVarargs
static <T> List<T> asList(T... elements) {
    // ...
}
```

3. `@FunctionalInterface`: Эта аннотация применяется к интерфейсам, которые предназначены для использования как функциональные интерфейсы, то есть интерфейсы с одним абстрактным методом (как, например, интерфейс `java.util.function.Function`). Эта аннотация помогает компилятору проверить, что интерфейс действительно является функциональным. 
```java
@FunctionalInterface
interface MyFunction<T, R> {
    R apply(T t);
}
```
4. `@Repeatable`: Эта аннотация позволяет аннотировать элемент кода несколько раз с одним типом аннотации. Она используется в сочетании с другой аннотацией, которая является контейнером для повторяющейся аннотации. 
```java
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(MyAnnotations.class)
@interface MyAnnotation {
    String value();
}

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotations {
    MyAnnotation[] value();
}
```
Это некоторые из аннотаций, связанных с обобщенными типами в `Java`. Они помогают управлять и документировать обобщенный код и повышают безопасность и читаемость кода.

[наверх](#java-core)

## `Marker`-интерфейсы
Маркер-интерфейс (`Marker Interface`) в `Java` представляет собой **интерфейс, не содержащий методов**. Вместо этого он служит только как маркер или флаг, указывающий на определенное свойство или характеристику класса. `Маркер`-интерфейсы не имеют методов для реализации, и их целью является предоставление информации компилятору или другим инструментам о классах, которые **имеют определенное поведение или особенность**.

### Примеры `маркер`-интерфейсов в Java:

1. `java.io.Serializable`: Этот интерфейс является маркером и указывает, что класс может быть сериализован, то есть его объекты могут быть записаны в поток и восстановлены из потока. Когда класс реализует `Serializable`, это означает, что объекты этого класса могут быть переданы через сеть, сохранены в файле и т.д.
```java
import java.io.Serializable;

public class MyClass implements Serializable {
    // ...
}
```
2. `java.lang.Cloneable`: Этот маркер-интерфейс указывает, что класс поддерживает клонирование объектов с помощью метода `clone()`. Он не содержит методов и служит для указания, что объекты класса можно клонировать.
```java
public class MyCloneableClass implements Cloneable {
    // ...
}
```
3. `Собственные маркер-интерфейсы`: Вы также можете создавать собственные маркер-интерфейсы для указания определенных характеристик ваших классов. Например, если у вас есть иерархия животных, вы можете создать маркер-интерфейс `Herbivore` или `Carnivore`, чтобы указать, какие животные являются травоядными или хищниками.
```java
public interface Herbivore {
    // Это маркер-интерфейс
}

public class Elephant implements Herbivore {
    // ...
}

public class Lion {
    // Хищник, не реализует Herbivore
}
```
Маркер-интерфейсы обычно используются для добавления метаданных или обозначения классов, и их наличие или отсутствие может повлиять на поведение кода или инструментов, таких как сериализация, клонирование и другие.

[наверх](#java-core)

## Переопределение `Overriding`

Переопределение (`Overriding`) - это процесс создания новой реализации метода в подклассе, который имеет ту же сигнатуру (название, типы параметров и возвращаемое значение) метода из его суперкласса (родительского класса). При переопределении метод в подклассе полностью заменяет метод из суперкласса и предоставляет новую реализацию для этого метода.

### Основные правила и соглашения по переопределению методов в Java:

1. Метод в подклассе должен иметь точно такую же сигнатуру (название, типы параметров и возвращаемое значение) как метод в суперклассе.

2. Используйте аннотацию `@Override` (опционально, но рекомендуется) перед переопределенным методом. Это помогает компилятору и другим разработчикам понять вашу намеренность переопределения. `static` методы не могут иметь аннотацию `@Override`.

3. Метод в подклассе не может иметь менее ограниченный модификатор доступа, чем метод в суперклассе. Например, если метод в суперклассе объявлен как `protected`, то метод в подклассе может быть объявлен как `protected` или `public`, но не `private`.

4. Метод в подклассе не может выбрасывать более общие (широкие) исключения, чем метод в суперклассе. Он может выбрасывать те же исключения, менее общие исключения или вообще не выбрасывать исключения.

5. Вызывая переопределенный метод в объекте подкласса, вызывается реализация этого метода в подклассе, даже если ссылка на объект имеет тип суперкласса.

Пример:

```java
class Animal {
    void makeSound() {
        System.out.println("Some generic animal sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof! Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        myDog.makeSound(); // Вызывается переопределенный метод из класса Dog
    }
}
```

В этом примере метод `makeSound()` в классе `Dog` переопределяет метод с той же сигнатурой из класса `Animal`. При вызове `myDog.makeSound()`, вызывается реализация из класса `Dog`, даже если переменная `myDog` имеет тип `Animal`. Это называется полиморфизмом.

[наверх](#java-core)



## Перегрузка `Overloading`

Перегрузка методов (`Overloading`) - это создание нескольких методов с одним и тем же именем внутри одного класса или интерфейса, но с разными параметрами. Перегрузка позволяет создавать методы с разными входными данными и типами параметров, но с одинаковыми именами.

Основные правила и соглашения, касающиеся перегрузки методов в Java:

### 1. Сигнатура метода:

* Сигнатура метода включает в себя его имя и список параметров, включая их типы и порядок.

* Перегруженные методы должны иметь разные сигнатуры. Это означает, что хотя имена методов должны быть одинаковыми, типы и/или количество параметров должны отличаться.

### 2. Типы параметров:

* Перегрузка может включать в себя разные типы параметров, например, `int`, `double`, `String`, `boolean`, и так далее.

### 3. Количество параметров:

* Перегрузка также может включать в себя разное количество параметров. Например, один метод может иметь один параметр, а другой - два или больше.

### 4. Тип возвращаемого значения:

* Перегруженные методы могут иметь разные типы возвращаемого значения. Однако **только типы параметров и их количество учитываются при определении сигнатуры метода**.

### 5. Модификаторы доступа:

* Модификаторы доступа (`public`, `protected`, `private`) исключения для перегрузки. Методы могут иметь разные модификаторы доступа и все равно считаться перегруженными.

### 6. Ключевое слово `static`:

* Методы могут быть статическими (с модификатором `static`) или нестатическими (обычными). Статические и нестатические методы могут перегружать друг друга.

### 7. Передача значений:

* Параметры метода могут передаваться по значению (как примитивные типы) или по ссылке (как объекты). Это также учитывается при определении сигнатуры метода.

Пример перегрузки методов:

```java
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}
```

В этом примере класс `Calculator` имеет три перегруженных метода `add` с разными сигнатурами. Первый принимает два целых числа, второй - два числа с плавающей запятой, а третий - три целых числа. Это позволяет вызывать метод `add` с разными аргументами в зависимости от типа данных и их количества.

[наверх](#java-core)

## Получение доступа к переопределенным методам родительского класса

Для получения доступа к переопределенным методам родительского класса из подкласса в `Java`, вы можете использовать ключевое слово super. Ключевое слово `super` ссылается на родительский класс (суперкласс) и может использоваться для вызова его методов, включая переопределенные методы. Вот как это работает:

Вызов переопределенного метода родительского класса с помощью `super`:

```java
class Parent {
    void someMethod() {
        System.out.println("Метод в родительском классе");
    }
}

class Child extends Parent {
    void someMethod() {
        super.someMethod(); // Вызов метода из родительского класса
        System.out.println("Метод в дочернем классе");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.someMethod();
    }
}
```

В этом примере метод `someMethod()` в классе `Child` переопределяет метод с той же сигнатурой из класса `Parent`. При вызове `super.someMethod()` в методе `someMethod()` класса `Child`, вызывается версия метода из класса `Parent`, а затем выполняется дополнительный код из метода `someMethod()` класса `Child`.

Вызов конструктора родительского класса с помощью `super`:

```java
class Parent {
    Parent() {
        System.out.println("Конструктор родительского класса");
    }
}

class Child extends Parent {
    Child() {
        super(); // Вызов конструктора родительского класса
        System.out.println("Конструктор дочернего класса");
    }
}

public class Main {
    public static void main(String[] args) {
        Child child = new Child();
    }
}
```

В этом примере конструктор класса `Child` вызывает конструктор класса `Parent` с помощью `super()`. Это позволяет выполнить инициализацию объекта в родительском классе перед выполнением кода конструктора дочернего класса.

Использование `super` полезно в случаях, когда вам нужно добавить дополнительное поведение к функциональности родительского метода или вызвать конструктор родительского класса для инициализации.

[наверх](#java-core)


## Чтение данных из консоли в Java
Для чтения данных из консоли в `Java` вы можете использовать класс `java.util.Scanner`. Вот пример того, как можно считывать строки и числа с консоли с помощью `Scanner`:

Считывание строки с консоли:
java
Copy code
import java.util.Scanner;

public class ConsoleInputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Введите строку: ");
        String inputString = scanner.nextLine();

        System.out.println("Вы ввели: " + inputString);

        // Не забудьте закрыть сканнер, когда он больше не нужен.
        scanner.close();
    }
}
Считывание числа с консоли:
java
Copy code
import java.util.Scanner;

public class ConsoleInputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Введите целое число: ");
        int inputNumber = scanner.nextInt();

        System.out.println("Вы ввели: " + inputNumber);

        // Не забудьте закрыть сканнер, когда он больше не нужен.
        scanner.close();
    }
}
Обратите внимание, что после использования Scanner его следует закрыть, чтобы освободить ресурсы. Вы можете использовать блок try-with-resources, чтобы автоматически закрыть сканнер после завершения блока кода:

java
Copy code
try (Scanner scanner = new Scanner(System.in)) {
    // Ваш код для считывания данных из консоли
} // Сканнер будет автоматически закрыт здесь
Scanner также предоставляет методы для считывания других типов данных, таких как double, float, boolean, и т. д. Вы можете выбрать метод, соответствующий ожидаемому типу данных ввода.

[наверх](#java-core)

## Как записать данные в файл в `Java`

Для записи данных в файл в `Java`, вы можете использовать класс `FileOutputStream` или `BufferedWriter` в сочетании с классами `File` и `FileWriter`. Также можно использовать библиотеку `Jackson` через включенную в `Java` `ObjectMapper`.


### FileOutputStream

`FileOutputStream` используется для записи байтовых данных в файл. Этот метод хорошо подходит, если вам нужно записать бинарные данные.

```java
import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamExample {
    public static void main(String[] args) {
        String content = "Пример записи в файл с использованием FileOutputStream.";

        try (FileOutputStream fos = new FileOutputStream("example.txt")) {
            byte[] bytes = content.getBytes();
            fos.write(bytes);
            System.out.println("Данные успешно записаны в файл.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### BufferedWriter и FileWriter
`BufferedWriter` и `FileWriter` используются для записи символьных данных в файл. Они более удобны для записи текстовых данных.

```java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        String content = "Пример записи в файл с использованием BufferedWriter и FileWriter.";

        try (BufferedWriter writer = new BufferedWriter(new FileWriter("example.txt"))) {
            writer.write(content);
            System.out.println("Данные успешно записаны в файл.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### Jackson
`Jackson` используется для сериализации `Java` объектов в формат `JSON` и десериализации `JSON` в `Java` объекты. Этот метод удобен, когда вам нужно сохранить структурированные данные, такие как объекты `Java`, в файл.

Вам нужно добавить зависимость на `Jackson` в вашем проекте (например, через `Maven` или `Gradle`). Затем, вы можете использовать `ObjectMapper` для записи и чтения данных:

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import java.io.File;
import java.io.IOException;

public class JacksonExample {
    public static void main(String[] args) {
        ObjectMapper mapper = new ObjectMapper();
        mapper.enable(SerializationFeature.INDENT_OUTPUT);

        try {
            // Сериализация объекта в JSON и запись в файл
            MyObject myObject = new MyObject();
            mapper.writeValue(new File("example.json"), myObject);

            // Десериализация JSON из файла в объект
            MyObject readObject = mapper.readValue(new File("example.json"), MyObject.class);

            System.out.println("Данные успешно записаны и считаны из файла.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

В приведенном примере `MyObject` - это ваш пользовательский класс, который вы хотите записать и считать из файла в формате `JSON`.

[наверх](#java-core)

## Как считать данные из файла в `Java`

Для считывания данных из файла в `Java`, вы можете использовать различные классы, такие как `FileInputStream`, `BufferedReader`, `Scanner`, и другие. Вот несколько примеров различных способов:

### С использованием `FileInputStream`

Этот метод подходит для считывания бинарных данных из файла.

```java
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class FileInputStreamExample {
    public static void main(String[] args) {
        try (FileInputStream fis = new FileInputStream("example.txt")) {
            int data;
            while ((data = fis.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### С использованием `BufferedReader`

Этот метод удобен для считывания текстовых данных из файла.

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample {
    public static void main(String[] args) {
        try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
### С использованием `Scanner`

`Scanner` можно использовать для более удобного считывания различных типов данных из файла.

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class ScannerExample {
    public static void main(String[] args) {
        try (Scanner scanner = new Scanner(new File("example.txt"))) {
            while (scanner.hasNextLine()) {
                String line = scanner.nextLine();
                System.out.println(line);
            }
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```

### С использованием `Jackson` библиотеки

Вам сначала нужно импортировать библиотеку `Jackson` в ваш проект и создать объект `ObjectMapper`, который будет использоваться для десериализации данных `JSON` из файла.

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.File;
import java.io.IOException;

public class JacksonReadExample {
    public static void main(String[] args) {
        ObjectMapper mapper = new ObjectMapper();
        try {
            // Считывание данных из файла и десериализация в объект
            MyObject myObject = mapper.readValue(new File("data.json"), MyObject.class);
            System.out.println("Данные успешно считаны из файла: " + myObject);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
В приведенном примере `MyObject` - это класс, соответствующий структуре данных, хранящейся в `JSON`-файле. `Jackson` автоматически десериализует данные из файла в объект `Java`.

Пример `JSON`-файла (`data.json`):

```json
{
    "name": "John",
    "age": 30,
    "city": "New York"
}
```

Пример `JSON`-файла `data.json`, который будет считан и преобразован в объект `Java`.

Этот пример демонстрирует, как можно использовать `Jackson` для считывания данных из `JSON`-файла. Если данные в файле хранятся в формате `JSON`, `Jackson` предоставляет удобный способ их считать и преобразовать в объекты `Java`.

Это лишь некоторые из методов считывания данных из файла в `Java`. Выберите метод, который наиболее подходит для вашей задачи и типа данных, который вы хотите считать из файла.

[наверх](#java-core)


## Иерархия исключений в `Java`

Ниже представлена часть иерархии исключений с наиболее часто используемыми классами:

```scss
java.lang.Throwable
    ├── java.lang.Error (Неперехватываемые ошибки)
    │   ├── java.lang.AssertionError (Ошибка утверждения)
    │   ├── java.lang.VirtualMachineError (Ошибка виртуальной машины)
    │   │   ├── java.lang.OutOfMemoryError (Ошибка "недостаточно памяти")
    │   │   └── java.lang.StackOverflowError (Ошибка переполнения стека)
    │   └── ...
    │
    └── java.lang.Exception (Проверяемые исключения)
        ├── java.lang.RuntimeException (Непроверяемые исключения)
        │   ├── java.lang.NullPointerException (Ошибка "нулевой ссылки")
        │   ├── java.lang.ClassCastException (Ошибка приведения типов)
        │   ├── java.lang.ArithmeticException (Арифметическая ошибка)
        │   ├── java.lang.ArrayIndexOutOfBoundsException (Выход за пределы массива)
        │   ├── java.lang.IllegalArgumentException (Ошибка аргумента)
        │   ├── java.lang.IllegalStateException (Недопустимое состояние)
        │   ├── java.lang.UnsupportedOperationException (Неподдерживаемая операция)
        │   ├── java.lang.IndexOutOfBoundsException (Выход за пределы индекса)
        │   └── ...
        │
        ├── java.io.IOException (Исключения ввода-вывода)
        │   ├── java.io.FileNotFoundException (Файл не найден)
        │   ├── java.io.EOFException (Достигнут конец файла)
        │   ├── java.io.IOException (Общее исключение I/O)
        │   └── ...
        │
        ├── java.sql.SQLException (Исключения SQL)
        │   ├── java.sql.SQLSyntaxErrorException (Ошибка синтаксиса SQL)
        │   ├── java.sql.SQLDataException (Ошибка данных SQL)
        │   ├── java.sql.SQLException (Общее исключение SQL)
        │   └── ...
        │
        └── ...
```
Это лишь часть иерархии исключений в Java. Каждый из этих классов может иметь подклассы или более специфические исключения. Также в иерархии присутствуют пользовательские исключения, создаваемые разработчиками для обработки специфических ситуаций.

При работе с исключениями в Java, важно выбирать подходящий тип исключения для обработки конкретной ситуации и грамотно обрабатывать ошибки в вашем коде.

[наверх](#java-core)

## Как обработать исключение в `Java` с помощью `try-catch` блока

В `Java` исключения обрабатываются с помощью блока `try-catch`. Этот механизм позволяет вашей программе обрабатывать ошибки и исключительные ситуации во время выполнения. Вот базовый синтаксис `try-catch` блока:

```java
try {
    // Код, который может вызвать исключение
} catch (ExceptionType1 e1) {
    // Обработка исключения типа ExceptionType1
} catch (ExceptionType2 e2) {
    // Обработка исключения типа ExceptionType2
} finally {
    // Опциональный блок 'finally'
    // Выполняется всегда, независимо от того, было исключение или нет
}
```
* `try`: Здесь размещается код, который может вызвать исключение.
* `catch (ExceptionType e)`: Здесь вы указываете тип исключения, которое вы хотите перехватить, и код для его обработки. Вы можете иметь несколько блоков `catch` для разных типов исключений.
* `finally`: Опциональный блок `finally`, который выполняется всегда, независимо от того, было исключение или нет. Этот блок используется, например, для освобождения ресурсов или выполнения завершающих действий.

Пример использования `try-catch` блока:

```java
public class ExceptionHandlingExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0); // Вызывает ArithmeticException
            System.out.println("Результат деления: " + result);
        } catch (ArithmeticException e) {
            System.out.println("Ошибка: Нельзя делить на ноль.");
        }
    }

    public static int divide(int a, int b) {
        return a / b;
    }
}
```
В этом примере мы пытаемся выполнить деление `10 / 0`, что вызывает `ArithmeticException`. Мы перехватываем это исключение с помощью блока `catch` и выводим сообщение об ошибке.

Обработка исключений важна для обеспечения надежности и устойчивости программы к неожиданным ситуациям.

[наверх](#java-core)

## Что такое `finally` блок и для чего он используется

`finally` блок является частью конструкции обработки исключений (`try-catch-finally`) в Java. Он представляет собой опциональную часть, которая используется для выполнения кода независимо от того, было исключение или нет. `finally` блок может содержать код, который должен быть выполнен всегда, даже если в блоке `try` было выброшено исключение.

### Основные цели `finally` блока:

* **Освобождение ресурсов**: `finally` часто используется для освобождения ресурсов, таких как файловые дескрипторы, сетевые соединения, базы данных и другие ресурсы, которые необходимо корректно закрыть, даже если произошло исключение.

* **Завершение операций**: `finally` может использоваться для завершения операций или транзакций, даже если исключение было выброшено. Например, можно закрыть файл или базу данных, выполнив команды завершения транзакции.

* **Выполнение завершающих действий**: `finally` блок может содержать код, который должен выполниться независимо от того, какие исключения были выброшены. Это может включать в себя вывод логов, фиксацию состояния, восстановление данных и т. д.

Пример использования `finally` блока:

```java
public class FinallyExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0); // Вызывает ArithmeticException
            System.out.println("Результат деления: " + result);
        } catch (ArithmeticException e) {
            System.out.println("Ошибка: Нельзя делить на ноль.");
        } finally {
            System.out.println("Блок finally выполнен независимо от исключения.");
        }
    }

    public static int divide(int a, int b) {
        return a / b;
    }
}
```
В этом примере, даже если исключение `ArithmeticException` выбрасывается в блоке `try`, блок `finally` все равно будет выполнен, и мы увидим сообщение `"Блок finally выполнен независимо от исключения."` 

Это демонстрирует, как `finally` может быть полезным для выполнения завершающих действий и освобождения ресурсов в надежном и предсказуемом порядке.

[наверх](#java-core)

## В каких случаях `finally` не будет исполнен

Eсть случаи, когда блок `finally` не будет выполнен.

### Выход из программы
Если в блоке `try` или `catch` вызывается метод `System.exit()` или происходит аварийное завершение программы (например, с помощью `Runtime.getRuntime().halt()`), то выполнение программы завершается немедленно, и блок `finally` не будет выполнен.

```java
Copy code
public class FinallyExample {
    public static void main(String[] args) {
        try {
            System.exit(0); // Программа завершается, finally не выполнится
        } finally {
            System.out.println("Блок finally");
        }
    }
}
```

### Бесконечные циклы или потоки

Если блок `try` выполняется в бесконечном цикле или внутри потока, который не завершается, то блок `finally` не выполнится до тех пор, пока программа не будет прервана вручную.

```java
public class FinallyExample {
    public static void main(String[] args) {
        while (true) {
            try {
                // Бесконечный цикл
            } finally {
                System.out.println("Блок finally");
            }
        }
    }
}
```
### Преждевременное завершение `JVM`
Если процесс `JVM` (Java Virtual Machine) завершается неожиданно, например, из-за сбоя в системе или принудительной остановки, то блок `finally` может не выполниться.
***

Блок `finally` гарантирует выполнение кода в нормальных условиях и в случае возникновения исключения, но не может обеспечить выполнение в случае аварийного завершения программы или при принудительном прерывании выполнения `JVM`.

[наверх](#java-core)

## Как создать и использовать пользовательские исключения

Cоздание и использование пользовательских исключений в `Java` позволяет вам определить собственные типы исключений, которые соответствуют вашим потребностям и лучше передают информацию об ошибке. 

Вот как создать и использовать пользовательские исключения:

### 1. Создание пользовательского исключения

Вы можете создать класс, который расширяет один из существующих классов исключений, таких как `Exception` или `RuntimeException`. 

Обычно рекомендуется наследовать `Exception`, если вы хотите, чтобы ваше исключение было проверяемым (`checked exception`).

Пример создания пользовательского исключения:

```java
public class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}
```

### 2. Использование пользовательского исключения

Вы можете выбрасывать пользовательское исключение с помощью ключевого слова `throw` и обрабатывать его с помощью `try-catch` блока.

Пример выбрасывания и обработки пользовательского исключения:

```java
public class CustomExceptionExample {
    public static void main(String[] args) {
        try {
            int result = divide(10, 0);
            System.out.println("Результат деления: " + result);
        } catch (CustomException e) {
            System.out.println("Произошла ошибка: " + e.getMessage());
        }
    }

    public static int divide(int a, int b) throws CustomException {
        if (b == 0) {
            throw new CustomException("Деление на ноль недопустимо.");
        }
        return a / b;
    }
}
```

В этом примере мы выбрасываем пользовательское исключение `CustomException` в методе `divide`, если делитель равен нулю. Затем мы перехватываем это исключение в блоке `catch` и выводим сообщение об ошибке.

Пользовательские исключения полезны, когда вы хотите создать собственные классы ошибок, чтобы лучше описать ситуацию и передать дополнительную информацию об ошибке. Они позволяют вам улучшить читаемость и обработку ошибок в вашем коде.

[наверх](#java-core)

## Как работать со строками в `Java`

Работа со строками в `Java` выполняется с использованием класса `java.lang.String` и других классов, таких как `StringBuilder` и `StringBuffer`. Вот некоторые основные операции, которые вы можете выполнять со строками в `Java`:

### 1. Создание строк

```java
String str1 = "Привет, мир!"; // Создание строки с помощью литерала
String str2 = new String("Java"); // Создание строки с использованием конструктора
```
### 2. Сравнение строк

Для сравнения строк на равенство используйте `equals()` или `equalsIgnoreCase()` для игнорирования регистра. Для сравнения с учетом порядка символов используйте операторы `==`, `compareTo()`, `compareToIgnoreCase()`.

```java
String str1 = "hello";
String str2 = "Hello";

boolean isEqual = str1.equals(str2); // false
boolean isEqualIgnoreCase = str1.equalsIgnoreCase(str2); // true
int compareResult = str1.compareTo(str2); // > 0
```

### 3. Объединение строк

Для объединения строк используйте оператор `+` или метод `concat()`.

```java
String firstName = "John";
String lastName = "Doe";

String fullName = firstName + " " + lastName; // "John Doe"
String fullNameConcat = firstName.concat(" ").concat(lastName); // "John Doe"
```

### 4. Извлечение подстроки

Для извлечения подстроки из строки используйте метод `substring()`.

```java
String text = "Это пример строки";
String subString = text.substring(5, 11); // "пример"
```

### 5. Поиск и замена подстроки

Для поиска и замены подстроки используйте методы `indexOf()`, `replace()`, `replaceAll()`, `replaceFirst()`.

```java
String text = "Это пример строки";
int index = text.indexOf("пример"); // 4
String replaced = text.replace("пример", "пример изменен"); // "Это пример изменен строки"
```

### 6. Разделение строки

Для разделения строки на подстроки используйте метод `split()`.

```java
String text = "apple,banana,orange";
String[] fruits = text.split(","); // ["apple", "banana", "orange"]
```

### 7. Преобразование в верхний и нижний регистр

Для преобразования символов в верхний и нижний регистр используйте методы `toUpperCase()` и `toLowerCase()`.

```java
String text = "Java Programming";
String upperCase = text.toUpperCase(); // "JAVA PROGRAMMING"
String lowerCase = text.toLowerCase(); // "java programming"
```

### 8. Удаление лишних пробелов

Для удаления лишних пробелов в начале и конце строки используйте метод `trim()`.

```java
String text = "   Пример текста   ";
String trimmedText = text.trim(); // "Пример текста"
```

### 9. Длина строки

Для определения длины строки используйте метод `length()`.

```java
String text = "Hello, World!";
int length = text.length(); // 13
```

### 10. `StringBuilder` и `StringBuffer`

Если вам нужно выполнять множественные операции изменения строки, рекомендуется использовать `StringBuilder` (для однопоточных приложений) или `StringBuffer` (для многопоточных приложений), так как они более эффективны при построении и изменении строк.

```java
StringBuilder sb = new StringBuilder();
sb.append("Hello");
sb.append(" ");
sb.append("World");
String result = sb.toString(); // "Hello World"
```

Это основные операции работы со строками в `Java`. `Java` предоставляет множество методов для манипуляции строками, и вы можете выбирать наиболее подходящие в зависимости от вашей задачи.

[наверх](#java-core)

## Как работать с `regex` в `Java`

Регулярные выражения (`regex` или регулярные выражения) в `Java` позволяют выполнять сложный поиск и манипуляции с текстом на основе заданных шаблонов. В `Java` работа с `regex` выполняется с использованием классов из пакета `java.util.regex`.

Вот основные шаги по работе с `regex` в `Java`:

### 1. Создание шаблона

В `Java` вы создаете шаблон с использованием класса `Pattern`. Шаблон представляет собой строку, содержащую регулярное выражение.

```java
import java.util.regex.Pattern;
import java.util.regex.Matcher;

String regex = "pattern"; // Пример регулярного выражения
Pattern pattern = Pattern.compile(regex);
```

### 2. Создание объекта `Matcher`

Вы создаете объект `Matcher`, который будет использоваться для сравнения текста с регулярным выражением.

```java
Matcher matcher = pattern.matcher(inputText);
```

### 3. Поиск соответствия

Используйте методы `matches()`, `find()`,` lookingAt()`, чтобы проверить, соответствует ли текст регулярному выражению.

```java
if (matcher.matches()) {
    // Соответствует полностью
} else if (matcher.find()) {
    // Найдено соответствие
} else if (matcher.lookingAt()) {
    // Соответствует в начале строки
}
```

### 4. Извлечение совпадений

Используйте методы `group()` и `group(int groupNumber)` для извлечения найденных совпадений.

```java
String match = matcher.group(); // Извлекает найденное совпадение
String matchGroup = matcher.group(1); // Извлекает совпадение по номеру группы
```

### 5. Замена совпадений

Для замены совпадений в тексте используйте метод `replaceAll()` или `replaceFirst()`.

```java
String replacedText = matcher.replaceAll("replacement"); // Заменяет все совпадения
String replacedFirst = matcher.replaceFirst("replacement"); // Заменяет первое совпадение
```

### 6. Получение групп

`Regex` позволяет определять группы с помощью скобок () в выражении. Группы позволяют извлекать определенные части совпадений.

```java
Pattern pattern = Pattern.compile("([A-Za-z]+) (\\d+)");
Matcher matcher = pattern.matcher("Word 123");
if (matcher.find()) {
    String word = matcher.group(1); // "Word"
    String number = matcher.group(2); // "123"
}
```

### 7. Специальные символы

Regex включает специальные символы, такие как `.`, `*`, `+`, `?`, `[ ]`, `{ }`, `^`, `$`, и другие. Они имеют специальное значение и могут потребовать экранирования с помощью обратной косой черты (`\`).

Пример: `\d+` соответствует одной или более цифр.

Примеры:

### Вот несколько примеров регулярных выражений

Поиск `email`-адресов: 
```
"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"
```
Поиск `URL`: 
```
"https?://[A-Za-z0-9.-]+\\.[A-Za-z]{2,4}"
```
Поиск чисел: "-?\\d+"

### Исключения:

При работе с `regex` могут возникнуть исключения типа `PatternSyntaxException`, если регулярное выражение не является корректным. Убедитесь, что ваше выражение синтаксически правильно.

Это основы работы с `regex` в `Java`. `Regex` мощный инструмент для работы с текстовой информацией и поиска совпадений.

[наверх](#java-core)




[наверх](#java-core) | 
[назад](../README.md)


