# Тестирование в `Java`

* [Каковы основные отличия модульного тестирования `Unit Testing` от интеграционного тестирования `Integration Testing`](#1-каковы-основные-отличия-модульного-тестирования-unit-testing-от-интеграционного-тестирования-integration-testing)

* [Как в Java написать тест для метода, который возвращает void](#2-как-в-java-написать-тест-для-метода-который-возвращает-void)

* [Как тестировать методы, которые работают с коллекциями (например, List, Map), и на что обращать внимание](#3-как-тестировать-методы-которые-работают-с-коллекциями-например-list-map-и-на-что-обращать-внимание)

* [Что такое тестовое покрытие (Test Coverage), и какие существуют инструменты для его измерения в Java](#что-такое-тестовое-покрытие-test-coverage-и-какие-существуют-инструменты-для-его-измерения-в-java)

* [Какие практики нужно соблюдать при написании модульных тестов, чтобы они были эффективными и поддерживаемыми](#какие-практики-нужно-соблюдать-при-написании-модульных-тестов-чтобы-они-были-эффективными-и-поддерживаемыми)

* [Чем отличаются @Before, @BeforeEach, @BeforeClass и @AfterEach в JUnit](#чем-отличаются-before-beforeeach-beforeclass-и-aftereach-в-junit)

* [Как в JUnit проверить, что метод выбрасывает ожидаемое исключение](#как-в-junit-проверить-что-метод-выбрасывает-ожидаемое-исключение)

* [Как провести параметризованные тесты в JUnit, и когда они полезны](#как-провести-параметризованные-тесты-в-junit-и-когда-они-полезны)

* [Что такое assertEquals, assertTrue, assertFalse, и в каких случаях их использовать в JUnit](#что-такое-assertequals-asserttrue-assertfalse-и-в-каких-случаях-их-использовать-в-junit)

* [Как организовать набор тестов в JUnit для последовательного выполнения нескольких тестовых классов](#как-организовать-набор-тестов-в-junit-для-последовательного-выполнения-нескольких-тестовых-классов)

* [Какие инструменты вы используете для отладки Java-приложений, и как настроить точку останова (breakpoint)](#какие-инструменты-вы-используете-для-отладки-java-приложений-и-как-настроить-точку-останова-breakpoint)

* [Как включить подробное логгирование (debug logging) в Java-приложении](#как-включить-подробное-логгирование-debug-logging-в-java-приложении)

* [Какие стратегии вы используете для отладки многопоточных (multithreaded) приложений в Java](#какие-стратегии-вы-используете-для-отладки-многопоточных-multithreaded-приложений-в-java)

* [Что такое "stack trace" в Java, и как его правильно анализировать при возникновении исключений](#что-такое-stack-trace-в-java-и-как-его-правильно-анализировать-при-возникновении-исключений)

* [Как вы ищете и устраняете проблемы с утечкой памяти (memory leak) в Java-приложении](#как-вы-ищете-и-устраняете-проблемы-с-утечкой-памяти-memory-leak-в-java-приложении)

* [Что такое @SpringBootTest, и когда его следует использовать](#что-такое-springboottest-и-когда-его-следует-использовать)

* [Как в Spring-тестах использовать @MockBean, и в чем его отличие от @Mock из Mockito](#как-в-spring-тестах-использовать-mockbean-и-в-чем-его-отличие-от-mock-из-mockito)

* [Как провести интеграционное тестирование REST API, созданного с использованием Spring Boot](#как-провести-интеграционное-тестирование-rest-api-созданного-с-использованием-spring-boot)

* [Как протестировать компонент, использующий @Autowired, чтобы не загружать полный контекст приложения](#как-протестировать-компонент-использующий-autowired-чтобы-не-загружать-полный-контекст-приложения)

* [Что такое "контекст приложения" (Application Context) в Spring, и как его правильно тестировать](#что-такое-контекст-приложения-application-context-в-spring-и-как-его-правильно-тестировать)

* [Чем отличается Mockito от PowerMock, и в каких случаях стоит использовать каждый из них](#чем-отличается-mockito-от-powermock-и-в-каких-случаях-стоит-использовать-каждый-из-них)

* [Как подменить зависимость (mock dependency) в JUnit-тестах, если компонент сильно связан (tightly coupled) с другими классами](#как-подменить-зависимость-mock-dependency-в-junit-тестах-если-компонент-сильно-связан-tightly-coupled-с-другими-классами)

* [Что такое "spy" и "mock" в контексте Mockito, и в чем их различия](#что-такое-spy-и-mock-в-контексте-mockito-и-в-чем-их-различия)

* [Как тестировать код, который выполняет внешние запросы (например, к базе данных или REST API)](#как-тестировать-код-который-выполняет-внешние-запросы-например-к-базе-данных-или-rest-api)

* [Как провести юнит-тестирование асинхронных методов в Java](#как-провести-юнит-тестирование-асинхронных-методов-в-java)

* [Как обеспечить независимость (isolation) модульных тестов, чтобы они не влияли друг на друга](#как-обеспечить-независимость-isolation-модульных-тестов-чтобы-они-не-влияли-друг-на-друга)

* [Как проверить производительность (performance testing) отдельных методов или компонентов в Java](#как-проверить-производительность-performance-testing-отдельных-методов-или-компонентов-в-java)

* [Какие критерии вы используете, чтобы понять, что тест написан хорошо](#какие-критерии-вы-используете-чтобы-понять-что-тест-написан-хорошо)

* [Как организовать структуру тестов в проекте, чтобы они были легко поддерживаемыми и расширяемыми](#как-организовать-структуру-тестов-в-проекте-чтобы-они-были-легко-поддерживаемыми-и-расширяемыми)

* [Какие типичные ошибки встречаются при написании тестов в Java, и как их избежать](#какие-типичные-ошибки-встречаются-при-написании-тестов-в-java-и-как-их-избежать)



## 1. Каковы основные отличия модульного тестирования `Unit Testing` от интеграционного тестирования `Integration Testing`

Основные отличия между модульным тестированием (Unit Testing) и интеграционным тестированием (Integration Testing) заключаются в следующих аспектах:

### 1. Цель тестирования
* Модульное тестирование: Проверяет работу отдельного компонента или модуля программы (например, класс, метод). Цель — убедиться, что каждый модуль работает правильно и соответствует своим спецификациям независимо от других компонентов.

* Интеграционное тестирование: Проверяет, как взаимодействуют между собой несколько модулей или компонентов. Цель — убедиться, что связки и взаимодействия между модулями работают корректно после их объединения.

### 2. Уровень изолированности
* Модульное тестирование: Тесты максимально изолированы. В идеале, каждый тест проверяет только один конкретный модуль, поэтому внешние зависимости заменяются на моки или стабы (заглушки).

* Интеграционное тестирование: Включает взаимодействие реальных компонентов и систем. Зависимости между модулями сохраняются, и тесты проверяют не только функциональность, но и корректность связей между компонентами.

### 3. Объем и сложность тестов
* Модульное тестирование: Обычно короткие и простые тесты, которые проверяют определенный функционал. Они запускаются быстро и нацелены на конкретный аспект функциональности.

* Интеграционное тестирование: Сложнее в написании и выполнении, поскольку тесты должны учитывать взаимодействие разных модулей. Такие тесты могут быть более объемными и требуют больше времени для выполнения.

### 4. Инструменты и подходы
* Модульное тестирование: Часто используются фреймворки вроде `JUnit`, `NUnit`, или тестовые двойники (`Mockito` для моков в Java). Акцент делается на быструю проверку функционала небольших частей кода.

* Интеграционное тестирование: Может использовать инструменты, которые позволяют запускать несколько сервисов или частей приложения вместе (например, `SpringBootTest` для интеграционного тестирования в `Spring`). Может потребоваться поднятие окружения, например, базы данных или сторонних сервисов.

### 5. Время выполнения и стабильность
* Модульное тестирование: Тесты выполняются быстро и стабильно, так как они изолированы и не зависят от состояния внешних систем или окружения.

* Интеграционное тестирование: Тесты могут быть медленнее, так как задействуют больше компонентов системы, их взаимодействие, а также могут требовать настройки тестового окружения. Из-за этого они более подвержены сбоям, связанным с внешними зависимостями.

### 6. Ошибки и дефекты
* Модульное тестирование: Обнаруживает дефекты на уровне конкретного модуля. Помогает выявить ошибки на ранних этапах разработки и изолировать проблему в определенном участке кода.

* Интеграционное тестирование: Помогает выявить дефекты, возникающие из-за некорректного взаимодействия модулей. Здесь важно проверить правильность интеграции и связей между различными частями системы.

### Пример:
* Модульный тест: Тестирует работу метода calculateTax() в классе TaxService.

* Интеграционный тест: Тестирует, как TaxService работает вместе с PaymentService, чтобы убедиться, что весь процесс оплаты и расчета налога происходит корректно.

Оба вида тестирования важны и дополняют друг друга в процессе проверки работоспособности и надежности приложения.

[наверх](#тестирование-в-java)

## 2. Как в `Java` написать тест для метода, который возвращает `void`

Для тестирования методов, которые возвращают `void` в `Java`, обычно проверяют поведение метода, побочные эффекты или взаимодействие с другими компонентами. Вот основные подходы к тестированию void методов:

### 1. Проверка изменений состояния
Если метод изменяет состояние объекта или какого-либо поля класса, необходимо проверить это изменение.

Пример:

```java
public class Calculator {
    private int value;

    public void add(int number) {
        value += number;
    }

    public int getValue() {
        return value;
    }
}
```

Тест:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {

    @Test
    public void testAdd() {
        Calculator calculator = new Calculator();
        calculator.add(5);
        
        assertEquals(5, calculator.getValue());
    }
}
```

В этом примере мы проверяем, что вызов метода `add()` правильно изменяет состояние объекта `Calculator`.

### 2. Использование моков (Mocking)
Если метод вызывает другие сервисы, `DAO` (Data Access Object - *это класс или интерфейс, который предоставляет методы для работы с данными (например, сохранение, обновление, удаление, получение данных), скрывая детали доступа к базе данных*) или другие зависимости, можно использовать моки (например, с помощью `Mockito`), чтобы проверить вызов этих зависимостей.

Пример:

```java
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void saveUser(User user) {
        userRepository.save(user);
    }
}
```

Тест с использованием `Mockito`:

```java
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

public class UserServiceTest {

    @Test
    public void testSaveUser() {
        // Создаем мок для UserRepository
        UserRepository userRepositoryMock = Mockito.mock(UserRepository.class);
        
        // Создаем сервис с использованием мока
        UserService userService = new UserService(userRepositoryMock);
        
        User user = new User("John", "Doe");
        userService.saveUser(user);
        
        // Проверяем, что метод save был вызван один раз с правильным аргументом
        Mockito.verify(userRepositoryMock, Mockito.times(1)).save(user);
    }
}
```

Здесь мы используем `Mockito` для создания мока `UserRepository` и проверки, что метод `save()` был вызван с нужным аргументом.

### 3. Проверка побочных эффектов
Если метод вызывает какие-либо побочные эффекты (например, запись в файл, логгирование), можно протестировать эти эффекты напрямую.

Пример:

```java
public class LoggerService {
    public void log(String message) {
        System.out.println(message);
        // Запись в файл или консоль
    }
}
```

Тест:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertTrue;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

public class LoggerServiceTest {

    @Test
    public void testLog() {
        // Перенаправляем System.out для проверки вывода
        ByteArrayOutputStream outContent = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outContent));
        
        LoggerService logger = new LoggerService();
        logger.log("Hello, World!");
        
        // Проверяем, что вывод содержит ожидаемое сообщение
        assertTrue(outContent.toString().contains("Hello, World!"));
    }
}
```

Здесь мы перенаправляем стандартный поток вывода, чтобы проверить, что метод `log()` записывает правильное сообщение.

### 4. Проверка исключений
Если метод `void` может выбросить исключение, необходимо убедиться, что оно выбрасывается в нужных ситуациях.

Пример:

```java
public class Validator {
    public void validateAge(int age) {
        if (age < 18) {
            throw new IllegalArgumentException("Age must be 18 or older");
        }
    }
}
```

Тест:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class ValidatorTest {

    @Test
    public void testValidateAge() {
        Validator validator = new Validator();
        
        // Проверяем, что вызывается исключение IllegalArgumentException
        assertThrows(IllegalArgumentException.class, () -> validator.validateAge(15));
    }
}
```

Этот тест проверяет, что при вызове метода `validateAge()` с некорректным значением выбрасывается ожидаемое исключение.

Эти подходы помогут эффективно тестировать методы, которые не возвращают значения, но влияют на состояние, взаимодействуют с другими объектами или выбрасывают исключения.

[наверх](#тестирование-в-java)


## 3. Как тестировать методы, которые работают с коллекциями (например, `List`, `Map`), и на что обращать внимание

Тестирование методов, которые работают с коллекциями, предполагает проверку корректности работы с элементами, добавляемыми или извлекаемыми из коллекции. Важно убедиться, что методы правильно обрабатывают различные сценарии, включая граничные случаи. Вот некоторые рекомендации и аспекты, на которые следует обращать внимание:

### 1. Проверка содержимого коллекции
Проверяйте, что коллекция содержит ожидаемые элементы после вызова тестируемого метода.
Используйте методы сравнения (`assertEquals`, `assertTrue`) для проверки содержимого коллекций.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class CollectionTest {

    @Test
    public void testAddElementsToList() {
        List<String> list = new ArrayList<>();
        list.add("apple");
        list.add("banana");

        assertEquals(2, list.size());
        assertEquals("apple", list.get(0));
        assertEquals("banana", list.get(1));
    }
}
```

Здесь проверяется, что элементы добавлены в коллекцию в правильном порядке и в нужном количестве.

### 2. Проверка граничных условий (`Boundary Cases`)
Тестируйте пустые коллекции и проверяйте их поведение при вызове методов, которые должны добавлять или удалять элементы.
Проверьте работу метода при наличии одного элемента в коллекции.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class BoundaryTest {

    @Test
    public void testEmptyList() {
        List<String> list = new ArrayList<>();

        assertTrue(list.isEmpty());
    }
    
    @Test
    public void testSingleElementList() {
        List<String> list = new ArrayList<>();
        list.add("single");

        assertEquals(1, list.size());
        assertEquals("single", list.get(0));
    }
}
```

Здесь мы проверяем случаи, когда коллекция пуста или содержит ровно один элемент.

### 3. Проверка порядка элементов

Если коллекция имеет порядок (например, `List`), проверьте, что элементы располагаются в правильной последовательности.
Если порядок `не гарантирован` (`Set`, `Map`), используйте соответствующие методы для проверки.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.LinkedList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class OrderTest {

    @Test
    public void testElementOrder() {
        List<String> list = new LinkedList<>();
        list.add("first");
        list.add("second");

        assertEquals("first", list.get(0));
        assertEquals("second", list.get(1));
    }
}
```

В этом примере проверяется, что элементы находятся в ожидаемом порядке.

### 4. Проверка отсутствия/наличия элементов

Убедитесь, что коллекция не содержит лишних элементов или, наоборот, все необходимые элементы присутствуют.

Используйте такие методы, как `contains()`, `isEmpty()`, `size()`.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.HashSet;
import java.util.Set;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertFalse;

public class ContainsTest {

    @Test
    public void testSetContains() {
        Set<String> set = new HashSet<>();
        set.add("element");

        assertTrue(set.contains("element"));
        assertFalse(set.contains("missing"));
    }
}
```

Этот тест проверяет, что коллекция содержит или не содержит определенные элементы.

### 5. Проверка изменения коллекции (`Mutation`)
Если метод изменяет коллекцию (например, добавляет или удаляет элементы), убедитесь, что после вызова метода коллекция изменилась ожидаемым образом.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class MutationTest {

    @Test
    public void testRemoveElementFromList() {
        List<String> list = new ArrayList<>();
        list.add("apple");
        list.add("banana");
        
        list.remove("apple");

        assertEquals(1, list.size());
        assertEquals("banana", list.get(0));
    }
}
```

Здесь проверяется, что после удаления элемента коллекция изменилась так, как ожидалось.

6. Проверка корректного маппинга в Map
Для тестирования Map убедитесь, что каждый ключ связан с ожидаемым значением.
Проверьте поведение Map при добавлении или удалении пар ключ-значение.
Пример:

java
Copy code
import org.junit.jupiter.api.Test;
import java.util.HashMap;
import java.util.Map;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class MapTest {

    @Test
    public void testAddKeyValueToMap() {
        Map<String, Integer> map = new HashMap<>();
        map.put("one", 1);
        map.put("two", 2);

        assertEquals(2, map.size());
        assertEquals(Integer.valueOf(1), map.get("one"));
        assertEquals(Integer.valueOf(2), map.get("two"));
    }
}
Здесь проверяется, что добавленные пары ключ-значение корректно хранятся в Map.

7. Тестирование неизменяемых (Immutable) коллекций
Если вы работаете с неизменяемыми коллекциями (например, List.of()), проверьте, что попытки изменения коллекции вызывают соответствующие исключения.
Пример:

java
Copy code
import org.junit.jupiter.api.Test;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class ImmutableTest {

    @Test
    public void testImmutableList() {
        List<String> immutableList = List.of("one", "two");

        assertThrows(UnsupportedOperationException.class, () -> immutableList.add("three"));
    }
}
Здесь проверяется, что попытка изменить неизменяемую коллекцию выбрасывает UnsupportedOperationException.

8. Проверка обработки дубликатов
Если коллекция должна или не должна содержать дубликаты, проверьте, что метод обрабатывает дублирующиеся значения правильно (например, Set не допускает дубликатов).
Пример:

java
Copy code
import org.junit.jupiter.api.Test;
import java.util.HashSet;
import java.util.Set;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class DuplicatesTest {

    @Test
    public void testSetNoDuplicates() {
        Set<String> set = new HashSet<>();
        set.add("element");
        set.add("element"); // Дублирующий элемент
        
        assertEquals(1, set.size()); // Проверка, что размер остался 1
    }
}
Здесь проверяется, что добавление дубликата не увеличивает размер Set.

Эти аспекты помогут протестировать методы, работающие с коллекциями, на разные сценарии и убедиться в корректной обработке элементов в коллекции.

[наверх](#тестирование-в-java)

Что такое тестовое покрытие (Test Coverage), и какие существуют инструменты для его измерения в Java?

Какие практики нужно соблюдать при написании модульных тестов, чтобы они были эффективными и поддерживаемыми?

JUnit и фреймворки для тестирования
Чем отличаются @Before, @BeforeEach, @BeforeClass и @AfterEach в JUnit?

Как в JUnit проверить, что метод выбрасывает ожидаемое исключение?

Как провести параметризованные тесты в JUnit, и когда они полезны?

Что такое assertEquals, assertTrue, assertFalse, и в каких случаях их использовать в JUnit?

Как организовать набор тестов в JUnit для последовательного выполнения нескольких тестовых классов?

Какие инструменты вы используете для отладки Java-приложений, и как настроить точку останова (breakpoint)?

Как включить подробное логгирование (debug logging) в Java-приложении?

Какие стратегии вы используете для отладки многопоточных (multithreaded) приложений в Java?

Что такое "stack trace" в Java, и как его правильно анализировать при возникновении исключений?

Как вы ищете и устраняете проблемы с утечкой памяти (memory leak) в Java-приложении?

Что такое @SpringBootTest, и когда его следует использовать?

Как в Spring-тестах использовать @MockBean, и в чем его отличие от @Mock из Mockito?

Как провести интеграционное тестирование REST API, созданного с использованием Spring Boot?

Как протестировать компонент, использующий @Autowired, чтобы не загружать полный контекст приложения?

Что такое "контекст приложения" (Application Context) в Spring, и как его правильно тестировать?

Чем отличается Mockito от PowerMock, и в каких случаях стоит использовать каждый из них?

Как подменить зависимость (mock dependency) в JUnit-тестах, если компонент сильно связан (tightly coupled) с другими классами?

Что такое "spy" и "mock" в контексте Mockito, и в чем их различия?

Как тестировать код, который выполняет внешние запросы (например, к базе данных или REST API)?

Как провести юнит-тестирование асинхронных методов в Java?

Как обеспечить независимость (isolation) модульных тестов, чтобы они не влияли друг на друга?

Как проверить производительность (performance testing) отдельных методов или компонентов в Java?

Какие критерии вы используете, чтобы понять, что тест написан хорошо?

Как организовать структуру тестов в проекте, чтобы они были легко поддерживаемыми и расширяемыми?

Какие типичные ошибки встречаются при написании тестов в Java, и как их избежать?