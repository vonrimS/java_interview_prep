# Тестирование в `Java`

* [Отличия `Unit Testing` от `Integration Testing`](#отличия-unit-testing-от-integration-testing)
* [Тест для метода, который возвращает `void`](#тест-для-метода-который-возвращает-void)
* [Тестирование методов, которые работают с коллекциями (например, `List`, `Map`)](#тестирование-методов-которые-работают-с-коллекциями-например-list-map)
* [`Test Coverage` и какие существуют инструменты для его измерения в `Java`](#test-coverage-и-какие-существуют-инструменты-для-его-измерения-в-java)
* [Какие практики нужно соблюдать при написании модульных тестов, чтобы они были эффективными и поддерживаемыми](#какие-практики-нужно-соблюдать-при-написании-модульных-тестов-чтобы-они-были-эффективными-и-поддерживаемыми)
* [`JUnit` и фреймворки для тестирования](#junit-и-фреймворки-для-тестирования)



## Отличия `Unit Testing` от `Integration Testing`

Основные отличия между модульным тестированием (Unit Testing) и интеграционным тестированием (Integration Testing) заключаются в следующих аспектах:

### 1. Цель тестирования
* Модульное тестирование: Проверяет работу отдельного компонента или модуля программы (например, класс, метод). Цель — убедиться, что каждый модуль работает правильно и соответствует своим спецификациям независимо от других компонентов.

* Интеграционное тестирование: Проверяет, как взаимодействуют между собой несколько модулей или компонентов. Цель — убедиться, что связки и взаимодействия между модулями работают корректно после их объединения.

### 2. Уровень изолированности
* Модульное тестирование: Тесты максимально изолированы. В идеале, каждый тест проверяет только один конкретный модуль, поэтому внешние зависимости заменяются на моки или стабы (заглушки).

* Интеграционное тестирование: Включает взаимодействие реальных компонентов и систем. Зависимости между модулями сохраняются, и тесты проверяют не только функциональность, но и корректность связей между компонентами.

### 3. Объем и сложность тестов
* Модульное тестирование: Обычно короткие и простые тесты, которые проверяют определенный функционал. Они запускаются быстро и нацелены на конкретный аспект функциональности.

* Интеграционное тестирование: Сложнее в написании и выполнении, поскольку тесты должны учитывать взаимодействие разных модулей. Такие тесты могут быть более объемными и требуют больше времени для выполнения.

### 4. Инструменты и подходы
* Модульное тестирование: Часто используются фреймворки вроде `JUnit`, `NUnit`, или тестовые двойники (`Mockito` для моков в Java). Акцент делается на быструю проверку функционала небольших частей кода.

* Интеграционное тестирование: Может использовать инструменты, которые позволяют запускать несколько сервисов или частей приложения вместе (например, `SpringBootTest` для интеграционного тестирования в `Spring`). Может потребоваться поднятие окружения, например, базы данных или сторонних сервисов.

### 5. Время выполнения и стабильность
* Модульное тестирование: Тесты выполняются быстро и стабильно, так как они изолированы и не зависят от состояния внешних систем или окружения.

* Интеграционное тестирование: Тесты могут быть медленнее, так как задействуют больше компонентов системы, их взаимодействие, а также могут требовать настройки тестового окружения. Из-за этого они более подвержены сбоям, связанным с внешними зависимостями.

### 6. Ошибки и дефекты
* Модульное тестирование: Обнаруживает дефекты на уровне конкретного модуля. Помогает выявить ошибки на ранних этапах разработки и изолировать проблему в определенном участке кода.

* Интеграционное тестирование: Помогает выявить дефекты, возникающие из-за некорректного взаимодействия модулей. Здесь важно проверить правильность интеграции и связей между различными частями системы.

### Пример:
* Модульный тест: Тестирует работу метода calculateTax() в классе TaxService.

* Интеграционный тест: Тестирует, как TaxService работает вместе с PaymentService, чтобы убедиться, что весь процесс оплаты и расчета налога происходит корректно.

Оба вида тестирования важны и дополняют друг друга в процессе проверки работоспособности и надежности приложения.

[наверх](#тестирование-в-java)

## Тест для метода, который возвращает `void`

Для тестирования методов, которые возвращают `void` в `Java`, обычно проверяют поведение метода, побочные эффекты или взаимодействие с другими компонентами. Вот основные подходы к тестированию void методов:

### 1. Проверка изменений состояния
Если метод изменяет состояние объекта или какого-либо поля класса, необходимо проверить это изменение.

Пример:

```java
public class Calculator {
    private int value;

    public void add(int number) {
        value += number;
    }

    public int getValue() {
        return value;
    }
}
```

Тест:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class CalculatorTest {

    @Test
    public void testAdd() {
        Calculator calculator = new Calculator();
        calculator.add(5);
        
        assertEquals(5, calculator.getValue());
    }
}
```

В этом примере мы проверяем, что вызов метода `add()` правильно изменяет состояние объекта `Calculator`.

### 2. Использование моков (Mocking)
Если метод вызывает другие сервисы, `DAO` (Data Access Object - *это класс или интерфейс, который предоставляет методы для работы с данными (например, сохранение, обновление, удаление, получение данных), скрывая детали доступа к базе данных*) или другие зависимости, можно использовать моки (например, с помощью `Mockito`), чтобы проверить вызов этих зависимостей.

Пример:

```java
public class UserService {
    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void saveUser(User user) {
        userRepository.save(user);
    }
}
```

Тест с использованием `Mockito`:

```java
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

public class UserServiceTest {

    @Test
    public void testSaveUser() {
        // Создаем мок для UserRepository
        UserRepository userRepositoryMock = Mockito.mock(UserRepository.class);
        
        // Создаем сервис с использованием мока
        UserService userService = new UserService(userRepositoryMock);
        
        User user = new User("John", "Doe");
        userService.saveUser(user);
        
        // Проверяем, что метод save был вызван один раз с правильным аргументом
        Mockito.verify(userRepositoryMock, Mockito.times(1)).save(user);
    }
}
```

Здесь мы используем `Mockito` для создания мока `UserRepository` и проверки, что метод `save()` был вызван с нужным аргументом.

### 3. Проверка побочных эффектов
Если метод вызывает какие-либо побочные эффекты (например, запись в файл, логгирование), можно протестировать эти эффекты напрямую.

Пример:

```java
public class LoggerService {
    public void log(String message) {
        System.out.println(message);
        // Запись в файл или консоль
    }
}
```

Тест:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertTrue;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;

public class LoggerServiceTest {

    @Test
    public void testLog() {
        // Перенаправляем System.out для проверки вывода
        ByteArrayOutputStream outContent = new ByteArrayOutputStream();
        System.setOut(new PrintStream(outContent));
        
        LoggerService logger = new LoggerService();
        logger.log("Hello, World!");
        
        // Проверяем, что вывод содержит ожидаемое сообщение
        assertTrue(outContent.toString().contains("Hello, World!"));
    }
}
```

Здесь мы перенаправляем стандартный поток вывода, чтобы проверить, что метод `log()` записывает правильное сообщение.

### 4. Проверка исключений
Если метод `void` может выбросить исключение, необходимо убедиться, что оно выбрасывается в нужных ситуациях.

Пример:

```java
public class Validator {
    public void validateAge(int age) {
        if (age < 18) {
            throw new IllegalArgumentException("Age must be 18 or older");
        }
    }
}
```

Тест:

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class ValidatorTest {

    @Test
    public void testValidateAge() {
        Validator validator = new Validator();
        
        // Проверяем, что вызывается исключение IllegalArgumentException
        assertThrows(IllegalArgumentException.class, () -> validator.validateAge(15));
    }
}
```

Этот тест проверяет, что при вызове метода `validateAge()` с некорректным значением выбрасывается ожидаемое исключение.

Эти подходы помогут эффективно тестировать методы, которые не возвращают значения, но влияют на состояние, взаимодействуют с другими объектами или выбрасывают исключения.

[наверх](#тестирование-в-java)


## Тестирование методов, которые работают с коллекциями (например, `List`, `Map`)

Тестирование методов, которые работают с коллекциями, предполагает проверку корректности работы с элементами, добавляемыми или извлекаемыми из коллекции. Важно убедиться, что методы правильно обрабатывают различные сценарии, включая граничные случаи. Вот некоторые рекомендации и аспекты, на которые следует обращать внимание:

### 1. Проверка содержимого коллекции
Проверяйте, что коллекция содержит ожидаемые элементы после вызова тестируемого метода.
Используйте методы сравнения (`assertEquals`, `assertTrue`) для проверки содержимого коллекций.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class CollectionTest {

    @Test
    public void testAddElementsToList() {
        List<String> list = new ArrayList<>();
        list.add("apple");
        list.add("banana");

        assertEquals(2, list.size());
        assertEquals("apple", list.get(0));
        assertEquals("banana", list.get(1));
    }
}
```

Здесь проверяется, что элементы добавлены в коллекцию в правильном порядке и в нужном количестве.

### 2. Проверка граничных условий (`Boundary Cases`)
Тестируйте пустые коллекции и проверяйте их поведение при вызове методов, которые должны добавлять или удалять элементы.
Проверьте работу метода при наличии одного элемента в коллекции.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class BoundaryTest {

    @Test
    public void testEmptyList() {
        List<String> list = new ArrayList<>();

        assertTrue(list.isEmpty());
    }
    
    @Test
    public void testSingleElementList() {
        List<String> list = new ArrayList<>();
        list.add("single");

        assertEquals(1, list.size());
        assertEquals("single", list.get(0));
    }
}
```

Здесь мы проверяем случаи, когда коллекция пуста или содержит ровно один элемент.

### 3. Проверка порядка элементов

Если коллекция имеет порядок (например, `List`), проверьте, что элементы располагаются в правильной последовательности.
Если порядок `не гарантирован` (`Set`, `Map`), используйте соответствующие методы для проверки.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.LinkedList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class OrderTest {

    @Test
    public void testElementOrder() {
        List<String> list = new LinkedList<>();
        list.add("first");
        list.add("second");

        assertEquals("first", list.get(0));
        assertEquals("second", list.get(1));
    }
}
```

В этом примере проверяется, что элементы находятся в ожидаемом порядке.

### 4. Проверка отсутствия/наличия элементов

Убедитесь, что коллекция не содержит лишних элементов или, наоборот, все необходимые элементы присутствуют.

Используйте такие методы, как `contains()`, `isEmpty()`, `size()`.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.HashSet;
import java.util.Set;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertFalse;

public class ContainsTest {

    @Test
    public void testSetContains() {
        Set<String> set = new HashSet<>();
        set.add("element");

        assertTrue(set.contains("element"));
        assertFalse(set.contains("missing"));
    }
}
```

Этот тест проверяет, что коллекция содержит или не содержит определенные элементы.

### 5. Проверка изменения коллекции (`Mutation`)
Если метод изменяет коллекцию (например, добавляет или удаляет элементы), убедитесь, что после вызова метода коллекция изменилась ожидаемым образом.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class MutationTest {

    @Test
    public void testRemoveElementFromList() {
        List<String> list = new ArrayList<>();
        list.add("apple");
        list.add("banana");
        
        list.remove("apple");

        assertEquals(1, list.size());
        assertEquals("banana", list.get(0));
    }
}
```

Здесь проверяется, что после удаления элемента коллекция изменилась так, как ожидалось.

### 6. Проверка корректного маппинга в `Map`
Для тестирования `Map` убедитесь, что каждый ключ связан с ожидаемым значением.
Проверьте поведение `Map` при добавлении или удалении пар ключ-значение.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.HashMap;
import java.util.Map;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class MapTest {

    @Test
    public void testAddKeyValueToMap() {
        Map<String, Integer> map = new HashMap<>();
        map.put("one", 1);
        map.put("two", 2);

        assertEquals(2, map.size());
        assertEquals(Integer.valueOf(1), map.get("one"));
        assertEquals(Integer.valueOf(2), map.get("two"));
    }
}
```

Здесь проверяется, что добавленные пары ключ-значение корректно хранятся в `Map`.

### 7. Тестирование неизменяемых (`Immutable`) коллекций
Если вы работаете с неизменяемыми коллекциями (например, `List.of()`), проверьте, что попытки изменения коллекции вызывают соответствующие исключения.

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.List;
import static org.junit.jupiter.api.Assertions.assertThrows;

public class ImmutableTest {

    @Test
    public void testImmutableList() {
        List<String> immutableList = List.of("one", "two");

        assertThrows(UnsupportedOperationException.class, () -> immutableList.add("three"));
    }
}
```

Здесь проверяется, что попытка изменить неизменяемую коллекцию выбрасывает `UnsupportedOperationException`.

### 8. Проверка обработки дубликатов
Если коллекция должна или не должна содержать дубликаты, проверьте, что метод обрабатывает дублирующиеся значения правильно (например, `Set` не допускает дубликатов).

Пример:

```java
import org.junit.jupiter.api.Test;
import java.util.HashSet;
import java.util.Set;
import static org.junit.jupiter.api.Assertions.assertEquals;

public class DuplicatesTest {

    @Test
    public void testSetNoDuplicates() {
        Set<String> set = new HashSet<>();
        set.add("element");
        set.add("element"); // Дублирующий элемент
        
        assertEquals(1, set.size()); // Проверка, что размер остался 1
    }
}
```

Здесь проверяется, что добавление дубликата не увеличивает размер `Set`.

Эти аспекты помогут протестировать методы, работающие с коллекциями, на разные сценарии и убедиться в корректной обработке элементов в коллекции.

[наверх](#тестирование-в-java)


## `Test Coverage` и какие существуют инструменты для его измерения в `Java`

Тестовое покрытие (`Test Coverage`) — это показатель, который указывает, насколько полно тесты проверяют ваш код. Проще говоря, это процент кода, который был выполнен (покрыт) во время выполнения набора тестов. Тестовое покрытие помогает оценить качество тестирования программы и выявить области, которые не тестируются.

### Виды тестового покрытия:
1. Покрытие строк кода (Line Coverage):

    * Показывает, какой процент строк кода был выполнен при запуске тестов. Это самый базовый и часто используемый метрика тестового покрытия.

2. Покрытие ветвей (Branch Coverage):

    * Измеряет процент выполненных ветвей условных операторов (например, if, switch). Проверяет, были ли проверены все возможные исходы условий.

3. Покрытие условных операторов (Condition Coverage):

    * Определяет, проверены ли все возможные логические условия в операторах (например, в операторе if (a && b) проверяются оба условия).

4. Покрытие методов (Method Coverage):

    * Показывает, какой процент методов был вызван в тестах.

5. Покрытие классов (Class Coverage):

    * Показывает, какие классы в коде были задействованы при выполнении тестов.

6. Покрытие путей (Path Coverage):

    * Проверяет все возможные пути выполнения программы, что является более сложной и детализированной метрикой.

### Зачем нужно измерять тестовое покрытие?
* Выявление пропущенных тестов: Тестовое покрытие помогает увидеть, какие участки кода не покрыты тестами.

* Улучшение качества кода: Хорошее тестовое покрытие повышает уверенность в том, что код работает правильно, и позволяет быстрее находить ошибки.

* Поддержка рефакторинга: Высокое покрытие тестами облегчает рефакторинг, так как тесты могут выявить изменения в поведении программы.

* Поддержание стандартов качества: В командах разработки могут быть установлены определенные пороги тестового покрытия, которые помогают поддерживать качество проекта.

### Инструменты для измерения тестового покрытия в `Java`
В `Java` существует несколько популярных инструментов для измерения тестового покрытия. Они интегрируются с процессом сборки и запуска тестов, предоставляя подробную информацию о том, какие части кода были выполнены.

#### 1. JaCoCo (Java Code Coverage Library)
* Описание: JaCoCo — это один из самых популярных инструментов для измерения тестового покрытия в Java. Он интегрируется с системами сборки, такими как Maven, Gradle, Ant.
* Преимущества:
    * Простота интеграции с Maven и Gradle.
    * Поддержка измерения различных видов покрытия: строк, ветвей, методов.
    * Интуитивно понятные HTML-отчеты.
* Как использовать с Maven:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.jacoco</groupId>
            <artifactId>jacoco-maven-plugin</artifactId>
            <version>0.8.7</version>
            <executions>
                <execution>
                    <goals>
                        <goal>prepare-agent</goal>
                    </goals>
                </execution>
                <execution>
                    <id>report</id>
                    <phase>test</phase>
                    <goals>
                        <goal>report</goal>
                    </goals>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```
#### 2. Cobertura
* Описание: Cobertura — это старый, но всё ещё используемый инструмент для измерения покрытия. Он также интегрируется с Maven и Ant.
* Преимущества:
    * Поддержка как измерения покрытия кода, так и анализа качества тестов.
    * Поддержка простого интеграционного тестирования.
* Недостатки: Проект редко обновляется и может не поддерживать новые версии JVM.
* Использование с Maven:
```xml
<plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>cobertura-maven-plugin</artifactId>
    <version>2.7</version>
</plugin>
```
#### 3. Emma
* Описание: Emma — это легковесный и быстрый инструмент для анализа покрытия кода. Этот инструмент предоставляет детализированные отчеты с информацией о покрытии строк и методов.
* Преимущества:
    * Лёгкость и скорость работы.
    * Хорошая поддержка в интеграции с Ant.
* Недостатки: Проект больше не развивается, и рекомендуется использовать более современные альтернативы (например, JaCoCo).

#### 4. IntelliJ IDEA Coverage Tool
* Описание: Встроенный инструмент для измерения покрытия кода в IntelliJ IDEA, который поддерживает как JaCoCo, так и собственный механизм покрытия.
* Преимущества:
    * Интегрирован в среду разработки, не требуется дополнительной настройки.
    * Поддержка тестов JUnit и TestNG.
    * Визуальное отображение покрытия прямо в коде.

#### 5. EclEmma
* Описание: Плагин для Eclipse, который интегрируется с JaCoCo и предоставляет удобные инструменты для анализа покрытия в среде разработки Eclipse.
* Преимущества:
    * Полная интеграция с Eclipse.
    * Визуализация покрытия прямо в редакторе кода.
    * Поддержка различных форматов отчетов: HTML, XML и др.

#### 6. SonarQube
* Описание: SonarQube — это платформа для анализа кода, которая также поддерживает анализ тестового покрытия через интеграцию с инструментами вроде JaCoCo.
* Преимущества:
    * Комплексный анализ кода, включающий не только покрытие, но и другие метрики качества кода.
    * Интеграция с различными системами сборки и CI/CD.
    * Визуальные отчёты и метрики, которые можно просматривать на веб-интерфейсе.

#### 7. Gradle Test Coverage Plugin
* Описание: Встроенная поддержка тестового покрытия через JaCoCo, доступная в Gradle, позволяет легко интегрировать измерение покрытия в проекты, использующие Gradle.
* Использование с Gradle:
```gradle
apply plugin: 'jacoco'

jacoco {
    toolVersion = "0.8.7"
}

test {
    finalizedBy jacocoTestReport
}

jacocoTestReport {
    reports {
        xml.enabled true
        html.enabled true
    }
}
```

### Заключение
Тестовое покрытие — это важный инструмент для оценки полноты тестирования и улучшения качества кода. Инструменты, такие как JaCoCo, Cobertura, Emma, и другие, помогают автоматически измерять, насколько ваш код протестирован, и предоставляют полезные отчеты для анализа.

[наверх](#тестирование-в-java)

## Какие практики нужно соблюдать при написании модульных тестов, чтобы они были эффективными и поддерживаемыми

Чтобы модульные тесты были эффективными и поддерживаемыми, необходимо следовать нескольким ключевым практикам, которые помогут улучшить их качество, упростить поддержку и сделать процесс тестирования более надёжным. Вот основные принципы и практики:

### 1. Написание атомарных тестов
* Описание: Модульные тесты должны проверять одну конкретную вещь или аспект поведения функции. Это позволяет легче выявлять причину ошибки, если тест не пройдёт.
* Пример: Тест должен проверять только одну логику, например, проверку возврата правильного значения метода или выброс исключения, а не их сочетание.

### 2. Использование принципа "Arrange, Act, Assert" (AAA)
* Описание: Придерживайтесь чёткой структуры теста:
    * `Arrange`: Подготовка данных и объектов для теста.
    * `Act`: Выполнение действия или вызова тестируемого метода.
    * `Assert`: Проверка ожидаемого результата.
* Пример:
```java
@Test
public void testAddition() {
    // Arrange
    Calculator calc = new Calculator();
    int a = 5;
    int b = 10;

    // Act
    int result = calc.add(a, b);

    // Assert
    assertEquals(15, result);
}
```
### 3. Использование понятных имён для тестов
* Описание: Имена тестов должны чётко описывать, что именно проверяется, чтобы было легко понять цель теста без необходимости заглядывать в код.
* Пример: Вместо общего названия `testAddition` лучше использовать более подробное, такое как `shouldReturnSumOfTwoNumbers`.

### 4. Использование небольших тестовых данных
* Описание: Тесты должны использовать минимальный набор данных, необходимый для проверки функционала. Это делает тесты проще и быстрее.
* Пример: Используйте простые и небольшие примеры входных данных, таких как небольшие списки или минимальные значения.
### 5. Изоляция тестируемого кода (Mocking)
* Описание: Используйте моки, стабы или фейки для изоляции тестируемого модуля от зависимостей, таких как базы данных, внешние API и другие модули. Это гарантирует, что тесты проверяют только код, а не внешние зависимости.
* Пример:
```java
@Mock
private Database mockDatabase;

@Test
public void testWithMock() {
    when(mockDatabase.getData()).thenReturn("Mock Data");
    // ... вызов метода с использованием mockDatabase
}
```

### 6. Минимизация зависимости тестов друг от друга
* Описание: Тесты должны быть независимыми. Каждый тест должен быть способен запускаться в любом порядке без зависимости от других тестов.
* Пример: Убедитесь, что каждый тест создаёт и уничтожает данные, которые могут повлиять на другие тесты.

### 7. Использование тестов с учётом крайних случаев
* Описание: Тестируйте как нормальные, так и крайние случаи, такие как нулевые значения, пустые данные, большие числа, граничные значения и исключительные ситуации.
* Пример: Проверьте работу метода с пустыми списками или `null`-значениями.

### 8. Чёткое определение ожидаемых результатов
* Описание: Каждое утверждение в тестах должно чётко определять, что ожидается. Используйте подходящие методы проверки (`assertEquals`, `assertThrows` и т.д.).
* Пример:
```java
assertEquals(10, result);  // Чёткое определение ожидаемого результата
```

### 9. Использование аннотаций `@Before`, `@After` для настройки и очистки окружения
* Описание: Если тесты требуют одинаковой настройки окружения или объектов, используйте методы с аннотацией `@Before` для подготовки, а `@After` — для очистки после тестов.
* Пример:
```java
@Before
public void setUp() {
    calculator = new Calculator();
}

@After
public void tearDown() {
    // Очистка ресурсов
}
```

### 10. Поддержка высокой скорости выполнения тестов
* Описание: Модульные тесты должны выполняться быстро. Если тест занимает слишком много времени из-за зависимостей (например, работа с базой данных), используйте моки или стабы для ускорения.
* Совет: Тесты должны быть достаточно быстрыми, чтобы их можно было запускать часто.

### 11. Не полагайтесь на глобальное состояние
* Описание: Избегайте использования глобальных переменных или объектов в тестах. Они могут сохранять состояние между тестами, что приведёт к зависимостям между тестами.
* Пример: Создавайте новые экземпляры объектов для каждого теста.

### 12. Поддержание тестов актуальными
* Описание: Тесты нужно поддерживать так же, как и основной код. При изменении бизнес-логики или рефакторинге кода тесты должны быть обновлены соответственно.
* Пример: Если добавлен новый функционал, добавьте тесты для его проверки.

### 13. Использование модульных тестов для документации
* Описание: Хорошо написанные тесты могут служить неформальной документацией, показывая, как использовать определённые классы и методы.
* Пример: Хорошо написанные тесты помогут новым разработчикам понять, как работает код.

### 14. Покрытие разных сценариев тестирования
* Описание: Для каждого модуля старайтесь покрыть как можно больше различных сценариев — это включает в себя как успешные кейсы, так и случаи с ошибками или исключениями.
* Пример: Тестируйте как положительный (успешный) сценарий, так и негативный, например, когда метод должен выбросить исключение.

### 15. Регулярный запуск тестов
* Описание: Тесты должны запускаться регулярно, например, при каждом коммите в репозиторий (CI/CD). Это поможет вовремя выявлять регрессии и проблемы в коде.
* Совет: Настройте автоматический запуск тестов при каждом изменении кода в системе CI (например, Jenkins, GitLab CI).

### Заключение:
Эти практики помогут вам писать модульные тесты, которые будут:
* Чёткими и понятными.
* Быстрыми и независимыми.
* Легко поддерживаемыми и расширяемыми.
* Полностью проверяющими функционал, который они должны покрывать.

Эффективные модульные тесты облегчают рефакторинг, поддержание и расширение кода, а также повышают доверие к качеству программы.

[наверх](#тестирование-в-java)

## `JUnit` и фреймворки для тестирования
`JUnit` — это один из самых популярных фреймворков для модульного тестирования в `Java`. Он предоставляет набор аннотаций, классов и методов для создания и выполнения тестов. Помимо `JUnit`, существует несколько других фреймворков для тестирования, каждый из которых имеет свои особенности и сферы применения.

### Что такое `JUnit`?
`JUnit` — это тестовый фреймворк, используемый для написания и выполнения тестов в `Java`. Он помогает разработчикам проверять поведение их кода путём создания повторяемых и автоматизированных тестов. `JUnit` поддерживает как модульное тестирование (unit tests), так и интеграционное тестирование.

### Основные возможности `JUnit`:
1. Аннотации для тестов:

    * @Test: обозначает метод как тестовый.
    
    * @BeforeEach: выполняется перед каждым тестом, используется для подготовки окружения.
    
    * @AfterEach: выполняется после каждого теста, используется для очистки окружения.
    
    * @BeforeAll и @AfterAll: выполняются один раз перед всеми тестами и после всех тестов соответственно.
    
    * @Disabled: отключает тест (или набор тестов), чтобы он не запускался.

2. Проверка результатов (Assertions):

    * assertEquals: проверяет, что два значения равны.
    
    * assertTrue/assertFalse: проверяют истинность или ложность выражения.
    
    * assertThrows: проверяет, что выбрасывается исключение.
    
    * assertNull/assertNotNull: проверяют, что объект равен или не равен null.

3. Утверждения с сообщениями:

Позволяет добавить пользовательское сообщение, если проверка не удалась:
```java
assertEquals("Сообщение при провале", expected, actual);
```

4. Организация тестов:

* Тесты можно группировать и запускать с помощью тестовых наборов (Test Suites).

* Можно использовать категории тестов для разделения медленных и быстрых тестов.

### Пример использования JUnit:
```java
import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class CalculatorTest {

    private Calculator calculator;

    @BeforeEach
    public void setUp() {
        calculator = new Calculator();
    }

    @Test
    public void testAddition() {
        assertEquals(5, calculator.add(2, 3));
    }

    @Test
    public void testDivisionByZero() {
        assertThrows(ArithmeticException.class, () -> calculator.divide(10, 0));
    }
}
```

### Другие фреймворки для тестирования:
Помимо `JUnit`, существуют и другие фреймворки для тестирования в Java, каждый из которых имеет свои особенности и цели использования.

### 1. TestNG
TestNG — это мощный фреймворк для тестирования, который предлагает более гибкие возможности по сравнению с JUnit. Он поддерживает различные виды тестов, включая модульные, интеграционные и end-to-end тесты.

* Преимущества:

    * Поддержка аннотаций, как в JUnit, но с дополнительными возможностями.
    
    * Более гибкое управление порядком выполнения тестов.
    
    * Поддержка параллельного выполнения тестов.
    
    * Поддержка зависимости между тестами (например, один тест может зависеть от успешного выполнения другого).

* Пример:

```java
import org.testng.Assert;
import org.testng.annotations.Test;

public class CalculatorTest {

    @Test
    public void testAddition() {
        Calculator calculator = new Calculator();
        Assert.assertEquals(calculator.add(2, 3), 5);
    }
}
```

### 2. Mockito
Mockito — это фреймворк для создания моков (mock) и стабов (stub) при написании тестов. Он используется для изоляции тестируемого кода от внешних зависимостей (например, базы данных, веб-сервисы и т.д.).

* Преимущества:

    * Легко создаёт моки для классов и интерфейсов.
    
    * Позволяет точно настраивать поведение моков.
    
    * Поддерживает проверку того, что методы моков были вызваны с правильными параметрами.

* Пример:

```java
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;

public class UserServiceTest {

    @Test
    public void testUserService() {
        UserRepository mockRepo = mock(UserRepository.class);
        when(mockRepo.getUserById(1)).thenReturn(new User(1, "John"));

        UserService userService = new UserService(mockRepo);
        User user = userService.getUser(1);

        assertEquals("John", user.getName());
        verify(mockRepo).getUserById(1);  // Проверка вызова метода
    }
}
```

### 3. Hamcrest
Hamcrest — это библиотека для создания выразительных утверждений (assertions) в тестах. Он часто используется с JUnit и другими фреймворками для улучшения читаемости проверок.

* Преимущества:

    * Предоставляет выразительные утверждения для работы с коллекциями, строками и объектами.
    
    * Улучшает читаемость кода тестов за счёт более гибких проверок.

* Пример:

```java
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

public class HamcrestExampleTest {

    @Test
    public void testListContainsElements() {
        List<String> list = Arrays.asList("apple", "banana", "cherry");
        assertThat(list, hasItems("apple", "cherry"));
    }
}
```
### 4. Arquillian
Arquillian — это фреймворк для написания интеграционных тестов в Java EE и Jakarta EE приложениях. Он позволяет запускать тесты в контейнерах приложений, таких как WildFly, GlassFish и другие.

* Преимущества:
    * Интеграция с Java EE средой.
    
    * Поддержка запуска тестов в реальных контейнерах.
    
    * Автоматическое развертывание тестируемого приложения.

### 5. Spock
Spock — это фреймворк для тестирования на основе Groovy. Он используется для тестирования Java и Groovy кода, а также предоставляет богатый синтаксис для создания тестов.

* Преимущества:

    * Читаемый и выразительный синтаксис.
    
    * Поддержка mock-объектов, проверок, ассертов и BDD-тестирования.
    
    * Хорошо интегрируется с JUnit.

* Пример:

```groovy
class CalculatorSpec extends Specification {

    def "addition should return correct result"() {
        given:
        Calculator calc = new Calculator()

        expect:
        calc.add(2, 3) == 5
    }
}
```

### 6. Cucumber
Cucumber — это фреймворк для написания тестов в стиле BDD (Behavior-Driven Development). Тесты пишутся на понятном языке, часто близком к естественному, таком как Gherkin.

* Преимущества:

    * Позволяет писать тесты в стиле "сценариев" на естественном языке.
    
    * Поддерживает BDD-подход, где бизнес-логика описана в терминах поведения.
    
    * Легко интегрируется с JUnit или TestNG.

* Пример сценария на языке Gherkin:

```sql
Scenario: User logs in successfully
  Given the user is on the login page
  When the user enters valid credentials
  Then the user should be redirected to the dashboard
  ```

### 7. Powermock
Powermock — это расширение для Mockito, которое позволяет моксировать статические методы, конструкторы и методы финальных классов, что обычно недоступно в чистом Mockito.

* Преимущества:

    * Моксирование статических методов и конструкторов.

    * Моксирование финальных методов и классов.

### Заключение:
Для эффективного тестирования в `Java` используется целый набор инструментов, включая `JUnit` для написания модульных тестов, `Mockito` для создания моков, `Hamcrest` для удобных утверждений, а также `TestNG`, `Arquillian`, `Spock` и другие для более специализированных задач. Выбор фреймворка зависит от типа тестируемого приложения, его структуры и предпочтений команды.

[наверх](#тестирование-в-java)

## Чем отличаются `@Before`, `@BeforeEach`, `@BeforeClass` и `@AfterEach` в `JUnit`

[наверх](#тестирование-в-java)

Как в JUnit проверить, что метод выбрасывает ожидаемое исключение?
[наверх](#тестирование-в-java)

Как провести параметризованные тесты в JUnit, и когда они полезны?
[наверх](#тестирование-в-java)

Что такое assertEquals, assertTrue, assertFalse, и в каких случаях их использовать в JUnit?
[наверх](#тестирование-в-java)

Как организовать набор тестов в JUnit для последовательного выполнения нескольких тестовых классов?
[наверх](#тестирование-в-java)

Какие инструменты вы используете для отладки Java-приложений, и как настроить точку останова (breakpoint)?
[наверх](#тестирование-в-java)

Как включить подробное логгирование (debug logging) в Java-приложении?
[наверх](#тестирование-в-java)

Какие стратегии вы используете для отладки многопоточных (multithreaded) приложений в Java?
[наверх](#тестирование-в-java)

Что такое "stack trace" в Java, и как его правильно анализировать при возникновении исключений?
[наверх](#тестирование-в-java)

Как вы ищете и устраняете проблемы с утечкой памяти (memory leak) в Java-приложении?
[наверх](#тестирование-в-java)

Что такое @SpringBootTest, и когда его следует использовать?
[наверх](#тестирование-в-java)

Как в Spring-тестах использовать @MockBean, и в чем его отличие от @Mock из Mockito?
[наверх](#тестирование-в-java)

Как провести интеграционное тестирование REST API, созданного с использованием Spring Boot?
[наверх](#тестирование-в-java)

Как протестировать компонент, использующий @Autowired, чтобы не загружать полный контекст приложения?
[наверх](#тестирование-в-java)

Что такое "контекст приложения" (Application Context) в Spring, и как его правильно тестировать?
[наверх](#тестирование-в-java)

Чем отличается Mockito от PowerMock, и в каких случаях стоит использовать каждый из них?
[наверх](#тестирование-в-java)

Как подменить зависимость (mock dependency) в JUnit-тестах, если компонент сильно связан (tightly coupled) с другими классами?
[наверх](#тестирование-в-java)

Что такое "spy" и "mock" в контексте Mockito, и в чем их различия?
[наверх](#тестирование-в-java)

Как тестировать код, который выполняет внешние запросы (например, к базе данных или REST API)?
[наверх](#тестирование-в-java)

Как провести юнит-тестирование асинхронных методов в Java?
[наверх](#тестирование-в-java)

Как обеспечить независимость (isolation) модульных тестов, чтобы они не влияли друг на друга?
[наверх](#тестирование-в-java)

Как проверить производительность (performance testing) отдельных методов или компонентов в Java?
[наверх](#тестирование-в-java)

Какие критерии вы используете, чтобы понять, что тест написан хорошо?
[наверх](#тестирование-в-java)

Как организовать структуру тестов в проекте, чтобы они были легко поддерживаемыми и расширяемыми?
[наверх](#тестирование-в-java)

Какие типичные ошибки встречаются при написании тестов в Java, и как их избежать?
[наверх](#тестирование-в-java)

[назад](../README.md)
