# Java OOP

[назад](../README.md)

* [Основные принципы ООП реализованые в Java](#основные-принципы-ооп-реализованые-в-java)
* [Что такое наследование и полиморфизм в Java?](#что-такое-наследование-и-полиморфизм-в-java?)
* [Как реализовать множественное наследование в Java](#как-реализовать-множественное-наследование-в-java)
* [Инкапсуляция и как её достичь в Java](#инкапсуляция-и-как-её-достичь-в-java)
* [Композиция и агрегация в Java](#композиция-и-агрегация-в-java)
* [`SOLID`-принципы в `ООП` и как их применять в `Java`](#solid-принципы-в-ооп-и-как-их-применять-в-java)
* [Что такое полиморфизм и как он реализуется в `Java`](#что-такое-полиморфизм-и-как-он-реализуется-в-java)
* [Отличия между `абстрактным классом` и `интерфейсом` в `Java`, когда стоит их использовать](#отличия-между-абстрактным-классом-и-интерфейсом-в-java-когда-стоит-их-использовать)
* [Что такое композиция и агрегация в `Java`, разница между ними](#что-такое-композиция-и-агрегация-в-java-разница-между-ними)
* [Как работает механизм переопределения метода `equals()` и `hashCode()`, почему важно переопределять оба метода](#как-работает-механизм-переопределения-метода-equals-и-hashcode-почему-важно-переопределять-оба-метода)
* [Принцип инверсии управления (`IoC`) и как он используется в `Java`](#принцип-инверсии-управления-ioc-и-как-он-используется-в-java)
* [Чем отличается перегрузка метода от переопределения метода](#чем-отличается-перегрузка-метода-от-переопределения-метода)
* [Как реализовать паттерн `Singleton` в `Java`, какие способы существуют и какие их преимущества/недостатки](#как-реализовать-паттерн-singleton-в-java-какие-способы-существуют-и-какие-их-преимуществанедостатки)
* [Объясните принцип `Tell, don’t ask` и как его можно применять в ООП](#объясните-принцип-tell-don’t-ask-и-как-его-можно-применять-в-ооп)
* [Что такое "текучесть абстракций" (`Leaky Abstraction`), как её избежать](#что-такое-текучесть-абстракций-leaky-abstraction-как-её-избежать)


## Основные принципы `ООП` реализованые в Java

`Java` является объектно-ориентированным языком программирования (`ООП`), и она включает в себя ряд основных принципов ООП. Вот некоторые из них:

1. **Инкапсуляция** (`Encapsulation`): Инкапсуляция означает скрытие внутренних деталей объекта и предоставление доступа к ним только через публичные методы. В `Java` это достигается с использованием модификаторов доступа (например, `private`, `protected`, `public`) для полей и методов класса.

2. **Наследование** (`Inheritance`): Наследование позволяет создавать новые классы на основе существующих классов, наследуя их свойства и методы. Это позволяет повторно использовать код и создавать иерархию классов. В `Java` наследование реализуется с помощью ключевого слова `extends`.

3. **Полиморфизм** (`Polymorphism`): Полиморфизм позволяет объектам разных классов обладать общим интерфейсом и выполнять одни и те же действия по-разному. В `Java` полиморфизм может быть достигнут через перегрузку методов и полиморфизм времени выполнения (`runtime polymorphism`) с использованием методов подклассов.

4. **Абстракция** (`Abstraction`): Абстракция позволяет скрыть сложность объекта и предоставить упрощенное представление. В `Java` абстракция достигается с использованием абстрактных классов и интерфейсов. Абстрактные классы могут содержать абстрактные методы, которые должны быть реализованы в подклассах.

5. **Композиция** (`Composition`): Композиция позволяет создавать более сложные объекты, комбинируя другие объекты. В `Java` это может быть достигнуто путем создания классов, которые содержат экземпляры других классов в качестве своих полей.

6. **Интерфейсы** (`Interfaces`): Интерфейсы в `Java` предоставляют абстрактные спецификации методов, которые классы могут реализовать. Это позволяет создавать классы, которые соответствуют определенному контракту, независимо от их фактической реализации.

7. **Пакеты** (`Packages`): Пакеты в `Java` позволяют организовать классы в логические группы и предоставить уровень сокрытия. Это помогает управлять и структурировать большие проекты.

8. **Повторное использование кода** (`Code Reusability`): ООП позволяет повторно использовать код через наследование, композицию и создание библиотек классов.

Эти принципы позволяют создавать гибкие, расширяемые и поддерживаемые программы, а ООП является мощным инструментом для организации кода и абстрагирования сложности.

[наверх](#java-oop)



## Что такое `наследование` и `полиморфизм` в Java?

В Java, `наследование` и `полиморфизм` - это два из основных принципов объектно-ориентированного программирования (ООП). Давайте разберемся с их определениями и основными концепциями:

1. **Наследование** (`Inheritance`): Наследование в `Java` позволяет создавать новый класс на основе существующего класса. Класс, который наследует свойства и методы другого класса, называется `подклассом` (или производным классом), а класс, который передает свойства и методы, называется `суперклассом` (или базовым классом). Основные идеи наследования в `Java`:

    * **Повторное использование кода**: Вы можете использовать существующий класс и расширить его функциональность, не переписывая код с нуля.

    * **Иерархия классов**: Классы могут быть организованы в иерархическую структуру, где один класс наследует от другого, создавая цепочку классов.

2. **Полиморфизм** (`Polymorphism`): Полиморфизм в `Java` означает, что один и тот же метод может иметь разные реализации в разных классах. Это позволяет обращаться к объектам разных классов с использованием одного и того же интерфейса. Основные концепции полиморфизма в `Java`:

    * **Полиморфизм в методах**: Разные классы могут иметь методы с одним и тем же именем и параметрами, но с разной реализацией. Вызов такого метода будет зависеть от типа объекта во время выполнения (динамическое связывание).

    * **Перегрузка методов**: В Java можно создавать несколько методов с одним и тем же именем, но разными параметрами (перегрузка методов).

    * **Использование интерфейсов и абстрактных классов**: Интерфейсы и абстрактные классы позволяют создавать общие соглашения (контракты) для классов и реализовывать их в различных контекстах.

```java
class Animal {
    void makeSound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();

        animal1.makeSound(); // Вывод: Bark
        animal2.makeSound(); // Вывод: Meow
    }
}
```
Здесь `Dog` и `Cat` наследуют от `Animal`, и у них есть своя реализация метода `makeSound()`. Полиморфизм позволяет вызывать метод `makeSound()` у объектов разных подклассов, и правильная реализация метода будет выбрана во время выполнения программы.

[наверх](#java-oop)



## Как реализовать множественное наследование в `Java`

В `Java`, классы **не поддерживают множественное наследование**, что означает, что класс не может наследовать от нескольких классов одновременно. Однако вы можете использовать интерфейсы для достижения подобного эффекта.

Множественное наследование в `Java` может быть реализовано с использованием `интерфейсов`. Класс может реализовать несколько интерфейсов, что позволяет ему наследовать функциональность от различных источников.

```java
interface Interface1 {
    void method1();
}

interface Interface2 {
    void method2();
}

class MyClass implements Interface1, Interface2 {
    public void method1() {
        System.out.println("Реализация method1");
    }

    public void method2() {
        System.out.println("Реализация method2");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.method1();
        obj.method2();
    }
}
```

В этом примере класс `MyClass` реализует оба интерфейса `Interface1` и `Interface2`, что позволяет ему наследовать функциональность от обоих интерфейсов.

Если вам нужно использовать конкретную реализацию из одного класса в другом классе, то можно воспользоваться композицией, создавая экземпляр этого класса внутри другого класса и делегируя вызовы методов этому экземпляру.

[наверх](#java-oop) 

## `Инкапсуляция` и как её достичь в `Java`

`Инкапсуляция` - это один из принципов `ООП`, который означает сокрытие внутренних деталей реализации класса от внешнего мира и предоставление доступа к данным и методам класса через управляемый интерфейс. Главная цель инкапсуляции - обеспечить безопасность и управляемость данных и функциональности класса.

В Java инкапсуляция достигается с помощью модификаторов доступа (`private`, `protected`, `public`) и `геттеров` (методов для получения данных) и `сеттеров` (методов для установки данных). Вот как можно реализовать инкапсуляцию в Java:

1. Примените модификаторы доступа:

    * `private`: Ограничивает доступ к членам класса только внутри этого класса. Данные, объявленные как private, не доступны извне.
    * `protected`: Доступно внутри класса, в подклассах и внутри пакета (package-private).
    * `public`: Доступно из любого места.
2. Используйте геттеры (методы получения данных) и сеттеры (методы установки данных):

    * Геттеры позволяют получить значение приватной переменной.
    * Сеттеры позволяют установить значение приватной переменной.

```java
public class Person {
    private String name; // Приватное поле

    // Геттер для доступа к имени
    public String getName() {
        return name;
    }

    // Сеттер для установки имени
    public void setName(String name) {
        this.name = name;
    }
}
```
В этом примере поле `name` объявлено как `private`, и к нему можно получить доступ только через публичные геттеры и сеттеры. Это обеспечивает инкапсуляцию данных `name`.

Инкапсуляция позволяет контролировать доступ к данным и методам класса, что делает код более безопасным и уменьшает вероятность ошибок. Она также облегчает изменение внутренней реализации класса, не затрагивая внешний код, который использует этот класс.

[наверх](#java-oop)

## `Композиция` и `агрегация` в Java

Композиция и агрегация - это два способа организации отношений между объектами в Java (и в объектно-ориентированном программировании в целом).

### Композиция:
* Композиция представляет собой более строгий тип отношения между объектами.
* В композиции один объект является частью другого объекта и **не может существовать независимо от него**.
* Если владеющий объект (контейнер) уничтожается, то и вложенный объект также уничтожается.
* Композиция обычно реализуется путем включения одного объекта в другой в качестве его части.
* Например, если у вас есть класс `Car` и класс `Engine`, и каждый объект `Car` имеет свой собственный объект `Engine`, то это композиция.
```java
public class Car {
    private Engine engine;

    public Car() {
        engine = new Engine();
    }
}
```
### Агрегация:
* Агрегация представляет собой более слабое отношение между объектами.
* В агрегации один объект может содержать ссылку на другой объект, но это не означает, что он является его частью.
* Если владеющий объект (контейнер) уничтожается, это не обязательно ведет к уничтожению вложенного объекта.
* Агрегация обычно используется для представления отношений типа "содержит" или "ссылается на".
* Например, если у вас есть класс Library и класс Book, и библиотека содержит ссылки на книги, это агрегация.
```java
public class Library {
    private List<Book> books;

    public Library() {
        books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
    }
}
```
Важно отметить, что различие между композицией и агрегацией не всегда очевидно и может зависеть от контекста. В некоторых случаях можно использовать оба варианта в зависимости от требований проектирования.

[наверх](#java-oop)


## `SOLID`-принципы в `ООП` и как их применять в `Java`

`SOLID` — это набор пяти принципов объектно-ориентированного проектирования, направленных на улучшение структуры и гибкости кода:
* **S: Single Responsibility Principle (SRP)** — каждый класс должен иметь только одну обязанность.

* **O: Open/Closed Principle (OCP)** — классы должны быть открыты для расширения, но закрыты для модификации.

* **L: Liskov Substitution Principle (LSP)** — подклассы должны корректно реализовывать интерфейсы базовых классов и заменять их без изменений в коде.

* **I: Interface Segregation Principle (ISP)** — интерфейсы должны быть узкими, чтобы клиенты не зависели от методов, которые они не используют.

* **D: Dependency Inversion Principle (DIP)** — модули должны зависеть от абстракций, а не от конкретных реализаций.

[наверх](#java-oop)

## Что такое полиморфизм и как он реализуется в `Java`

`Полиморфизм` — это способность одного интерфейса иметь множество реализаций. В `Java` полиморфизм реализуется через наследование и интерфейсы:
* **Перегрузка методов**: Один и тот же метод может иметь разные реализации с различными параметрами.

* **Переопределение методов**: Подкласс может переопределить метод суперкласса, чтобы изменить его поведение.

[наверх](#java-oop)

## Отличия между `абстрактным классом` и `интерфейсом` в `Java`, когда стоит их использовать

**Абстрактный класс**: Может содержать как абстрактные, так и конкретные методы. Предназначен для частичной реализации.

**Интерфейс**: Содержит только объявления методов (начиная с Java 8 может иметь методы по умолчанию и статические методы).

Когда использовать:

* **Интерфейсы** — для определения контракта (API) для множества несвязанных классов.

* **Абстрактные классы** — когда требуется создать общий функционал для классов с близкой логикой.

[наверх](#java-oop)

## Что такое композиция и агрегация в `Java`, разница между ними

* **Композиция**: Это сильная связь, когда один объект содержит другой объект, и этот объект не может существовать отдельно от основного объекта. Если основной объект уничтожается, уничтожается и зависимый.

* **Агрегация**: Это слабая связь, когда один объект связан с другим, но может существовать независимо от него.

[наверх](#java-oop)


## Как работает механизм переопределения метода `equals()` и `hashCode()`, почему важно переопределять оба метода

* `equals()`: Проверяет логическое равенство объектов.

* `hashCode()`: Возвращает хеш-код объекта, который используется в структурах данных, таких как `HashMap` и `HashSet`.

* Почему нужно переопределять оба: Согласно контракту, если два объекта равны по методу `equals()`, их хеш-коды также должны быть одинаковыми. В противном случае могут возникнуть проблемы с коллекциями, основанными на хешах.

[наверх](#java-oop)


## Принцип инверсии управления (`IoC`) и как он используется в `Java`

Инверсия управления (`Inversion of Control`, `IoC`) — это принцип, при котором объект не контролирует создание своих зависимостей, а эти зависимости передаются извне. В `Java` это реализуется через фреймворки вроде `Spring`, где используется механизм `Dependency Injection` (`DI`) для передачи зависимостей.

[наверх](#java-oop)


## Чем отличается перегрузка метода от переопределения метода

* Перегрузка (`overloading`): Означает создание методов с одинаковым именем, но с разными параметрами (в одном классе или в подклассе). Это статический полиморфизм.

* Переопределение (`overriding`): Означает изменение реализации метода, унаследованного от суперкласса, при сохранении его сигнатуры. Это динамический полиморфизм.

[наверх](#java-oop)


## Как реализовать паттерн `Singleton` в `Java`, какие способы существуют и какие их преимущества/недостатки

Самый простой способ реализации `Singleton`:
```java
public class Singleton {
    private static Singleton instance;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```
**Способы реализации**:

* Ленивая инициализация (как выше).

* Синхронизированный метод (synchronized).

* Реализация через Enum (рекомендуется в большинстве случаев, поскольку обеспечивает защиту от сериализации и рефлексии).

[наверх](#java-oop)


##  Объясните принцип `Tell, don’t ask` и как его можно применять в ООП

Принцип "Tell, don’t ask" заключается в том, что вместо запроса информации у объекта и выполнения действий над ним в другом месте, следует позволить самому объекту выполнять операции, относящиеся к его состоянию. Это улучшает инкапсуляцию и упрощает структуру кода.

* Пример плохой практики:
```java
if (user.isActive()) {
    user.performAction();
}
```
* Пример хорошей практики:
```java
user.performActionIfActive();
```

[наверх](#java-oop)


## Что такое "текучесть абстракций" (`Leaky Abstraction`), как её избежать

**Текучесть абстракций** — это когда детали реализации абстракции просачиваются наружу и заставляют пользователей этой абстракции учитывать их при работе с ней. Это нарушение принципа инкапсуляции.

**Как избежать**: Нужно проектировать чёткие интерфейсы и скрывать сложные детали реализации, предоставляя пользователям только то, что им действительно нужно.

[наверх](#java-oop) 

[назад](../README.md)