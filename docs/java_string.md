# Работа со строкой в Java

[назад](../README.md)

* [Что такое `String` в `Java` и как она работает](#что-такое-string-в-java-и-как-она-работает)
* [Неизменяемость строк в `Java` и какие преимущества это дает](#неизменяемость-строк-в-java-и-какие-преимущества-это-дает)
* [Отличие `String`, `StringBuilder` и `StringBuffer`, их использование и производительность](#отличие-string-stringbuilder-и-stringbuffer-их-использование-и-производительность)
* [`String Pool` и как он работает](#string-pool-и-как-он-работает)
* [Как работает метод `equals()` и `hashCode()` в `String`, почему они переопределены](#как-работает-метод-equals-и-hashcode-в-string-почему-они-переопределены)
* [Cравнение строки, разница между `==` и `.equals()` и метод `compareTo()` в `String`](#cравнение-строки-разница-между-==-и-equals-и-метод-compareto-в-string)
* [Метод `substring()` в классе `String`, как он изменился в `Java 7`](#метод-substring-в-классе-string-как-он-изменился-в-java-7)

* [Конкатенация строки с помощью оператора `+`, преобразоавание в использование `StringBuilder`](#конкатенация-строки-с-помощью-оператора-+-преобразоавание-в-использование-stringbuilder)
* [Как преобразовать строку в массив символов и наоборот](#как-преобразовать-строку-в-массив-символов-и-наоборот)

10. Как развернуть строку в Java?
Напишите код для реверсирования строки.
Какова будет сложность вашего решения?
11. Как проверить, является ли строка палиндромом?
Напишите метод, который проверяет, является ли строка палиндромом.
12. Как найти все подстроки строки?
Объясните алгоритм нахождения всех возможных подстрок строки.
13. Как удалить все пробелы из строки в Java?
Напишите метод для удаления всех пробелов из строки.
Чем отличаются методы trim(), strip() и использование регулярных выражений для удаления пробелов?
14. Как разделить строку на подстроки в Java?
Объясните использование метода split() в классе String.
Как можно использовать регулярные выражения с split()?
15. Как искать подстроку в строке?
Как работает метод indexOf() и как найти все вхождения подстроки в строку?
16. Как заменить символы или подстроки в строке?
Объясните работу метода replace() и чем он отличается от replaceAll().
17. Как преобразовать строку в целое число или дробное?
Как использовать метод Integer.parseInt() и Double.parseDouble() для преобразования строки в число?
18. Как преобразовать строку в массив байт или обратно?
Как можно конвертировать строку в байтовый массив и обратно, учитывая кодировки?
19. Как правильно работать с кодировкой в Java?
Как указать кодировку при преобразовании строки в байты и обратно?
Чем отличается UTF-8 от других кодировок в Java?
20. Какие существуют способы поиска уникальных символов в строке?
Как найти первый неповторяющийся символ в строке?
Напишите метод для поиска всех уникальных символов.


## Что такое `String` в `Java` и как она работает

`String` в `Java` — это неизменяемый (`immutable`) класс, представляющий последовательность символов. После создания строки её содержимое нельзя изменить. Изменение строки создает новый объект.

### Основные особенности:
* **Неизменяемость**: Строки нельзя изменять, это повышает безопасность и оптимизирует использование памяти.

* **String Pool**: Строки, созданные через литералы, сохраняются в пуле строк для экономии памяти. Если строка уже существует в пуле, новый объект не создается.

* **Конкатенация**: Оператор `+` создает новый объект строки, для оптимизации лучше использовать `StringBuilder` или `StringBuffer`.

* **Сравнение**: Оператор `==` проверяет ссылки, а `equals()` сравнивает содержимое.

```java
String s1 = "Hello";
String s2 = "Hello";
System.out.println(s1 == s2);  // true
System.out.println(s1.equals(s2));  // true
```

`String` — неизменяемый, безопасный и часто используемый класс в `Java`.

[наверх](#работа-со-строкой-в-java)

## Неизменяемость строк в `Java` и какие преимущества это дает

Неизменяемость (`immutable`) строк в `Java` означает, что после создания объекта `String` его содержимое нельзя изменить. Если строка изменяется (например, через конкатенацию), создается новый объект.

### Почему строки неизменяемы:

1. **Безопасность**: Защищает конфиденциальные данные от непреднамеренных изменений.
2. **Пул строк**: Позволяет переиспользовать строки в памяти, улучшая её использование.

3. **Потокобезопасность**: Неизменяемые строки безопасны для многопоточности без синхронизации.

4. **Производительность**: Оптимизация кэширования и снижение нагрузки на сборщик мусора.


**Преимущества**: Меньше ошибок, безопасность, экономия памяти, кэширование и улучшенная производительность.

[наверх](#работа-со-строкой-в-java)

## Отличие `String`, `StringBuilder` и `StringBuffer`, их использование и производительность

### 1. Чем отличается `String`, `StringBuilder` и `StringBuffer`

* **String**: Неизменяемый (`immutable`) класс. Любое изменение строки создает новый объект.
* **StringBuilder**: Изменяемый (`mutable`) класс. Не синхронизирован, быстрее в однопоточной среде.
* **StringBuffer**: Изменяемый (`mutable`) класс. Синхронизирован, безопасен для многопоточных операций.

### 2. Когда использовать каждый из этих классов

* **String**: Используется, когда строки не требуют изменения.
* **StringBuilder**: Для эффективного изменения строк в однопоточных приложениях.
* **StringBuffer**: Для изменения строк в многопоточных приложениях, где требуется синхронизация.

### 3. Как их производительность различается

* **String**: Самый медленный при частых изменениях (создает новые объекты).
* **StringBuilder**: Быстрее, так как не синхронизирован.
* **StringBuffer**: Медленнее, чем `StringBuilder`, из-за синхронизации, но безопасен в многопоточности.

[наверх](#работа-со-строкой-в-java)

## `String Pool` и как он работает

### 1. Как работает `String Pool` в `Java`

`String Pool` — это специальная область памяти в куче, где хранятся строковые литералы. Строки, созданные с помощью литералов, автоматически помещаются в пул.

### 2. Что такое строковый пул (`interned strings`)

`String pool` — это набор уникальных строк, где строки с одинаковым значением хранятся в одном экземпляре. Если строка уже существует в пуле, новая переменная будет ссылаться на этот объект.

### 3. Как строки добавляются в пул, и как это влияет на производительность

Строки, созданные через литералы, автоматически добавляются в пул. Это уменьшает количество дублирующих строк, экономит память и улучшает производительность, поскольку строковые объекты переиспользуются. Однако строки, созданные через `new String()`, не добавляются в пул автоматически - они будут храниться в `Heap`.

[наверх](#работа-со-строкой-в-java)

## Как работает метод `equals()` и `hashCode()` в `String`, почему они переопределены

### 1. Как работают `equals()` и `hashCode()` в классе `String`

* `equals()` в классе `String` сравнивает содержимое строк, а не ссылки на объекты.
* `hashCode()` генерирует хэш-код на основе содержимого строки, чтобы строки с одинаковым содержимым имели одинаковый хэш-код.

### 2. Почему эти методы переопределены

* В классе `Object` метод `equals()` сравнивает ссылки на объекты, а `hashCode()` основывается на внутреннем представлении объекта. В `String` они переопределены для корректного сравнения содержимого строк и обеспечения правильного поведения в коллекциях (например, в `HashMap` или `HashSet`).

### 3. Что произойдет, если `hashCode()` и `equals()` будут работать по-разному

* Если два объекта равны по `equals()`, но имеют разные хэш-коды, это нарушит контракт между этими методами. Это приведет к некорректной работе коллекций, основанных на хэшировании (например, `HashMap` или `HashSet`), что может вызвать ошибки при поиске или хранении объектов.

[наверх](#работа-со-строкой-в-java)

## Cравнение строки, разница между `==` и `.equals()` и метод `compareTo()` в `String`

### 1. Как сравнивать строки в `Java`

* Для сравнения строк используйте метод `equals()` для сравнения содержимого строк.

### 2. Разница между `==` и `.equals()`

* `==` сравнивает ссылки на объекты, проверяя, указывают ли переменные на один и тот же объект.
* `.equals()` сравнивает содержимое строк, проверяя их равенство по символам.

```java
String s1 = "Hello";
String s2 = new String("Hello");
System.out.println(s1 == s2);  // false, так как это разные объекты
System.out.println(s1.equals(s2));  // true, так как содержимое одинаковое
```

### 3. Как работает `compareTo()` в `String`

* `compareTo()` сравнивает строки лексикографически и возвращает:
    * 0, если строки равны;
    * Положительное число, если текущая строка больше;
    * Отрицательное число, если текущая строка меньше.

```java
String s1 = "apple";
String s2 = "banana";
System.out.println(s1.compareTo(s2));  // Отрицательное число, так как "apple" меньше "banana"
```

[наверх](#работа-со-строкой-в-java)

## Метод `substring()` в классе `String`, как он изменился в `Java 7`

### 1. Что делает метод `substring()` в классе `String`

* Метод `substring()` возвращает новую строку, которая является подстрокой оригинальной строки, начиная с указанного индекса и заканчивая указанным индексом (не включая его).

### 2. Как он работает с памятью

До `Java 7` `substring()` создавал новую строку, которая ссылалась на тот же массив символов, что и оригинальная строка, изменяя только границы. **Это экономило память, но могло привести к утечкам памяти, если оригинальная строка была большой**.

### 3. Как это изменилось в `Java 7`, и почему

* В `Java 7` `substring()` стал создавать новый массив символов для подстроки. **Это решение предотвращает утечки памяти, так как подстрока больше не держит ссылку на оригинальный массив**.

[наверх](#работа-со-строкой-в-java)

## Конкатенация строки с помощью оператора `+`, преобразоавание в использование `StringBuilder`

### 1. Что происходит в памяти при конкатенации строк с помощью оператора `+`

* При каждой конкатенации с помощью `+` создается новый объект `String`, так как строки неизменяемы. Это приводит к созданию множества промежуточных строк и лишним затратам памяти.

### 2. Как оператор `+` для строк преобразуется в использование `StringBuilder`

Компилятор автоматически преобразует конкатенации строк с использованием `+` в использование `StringBuilder`. Например:

```java
String result = "Hello" + " World";
```
преобразуется в:
```java
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
String result = sb.toString();
```

### 3. Как это влияет на производительность в циклах

* В циклах, где много раз выполняется конкатенация с помощью `+`, каждый раз создаются новые объекты строк, что значительно замедляет выполнение программы и увеличивает потребление памяти.

* Для повышения производительности в циклах рекомендуется использовать `StringBuilder` напрямую, чтобы избежать лишних операций создания строк:
```java
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 100; i++) {
    sb.append(i);
}
String result = sb.toString();
```

[наверх](#работа-со-строкой-в-java)

## Как преобразовать строку в массив символов и наоборот

### 1. Как выполнить обратное преобразование строки в массив символов

Вы можете преобразовать строку в массив символов с помощью метода `toCharArray()`, который возвращает массив символов, составляющих строку.

```java
String str = "Hello";
char[] charArray = str.toCharArray();
```

### 3. Как преобразовать массив символов обратно в строку
Используйте конструктор класса `String`, принимающий массив символов:

```java
char[] charArray = {'H', 'e', 'l', 'l', 'o'};
String str = new String(charArray);
```

Таким образом, вы можете легко преобразовывать строку в массив символов и обратно с помощью метода `toCharArray()` и конструктора `String`.

[наверх](#работа-со-строкой-в-java)

##

[наверх](#работа-со-строкой-в-java)

##

[наверх](#работа-со-строкой-в-java)

##

[наверх](#работа-со-строкой-в-java)

##

[наверх](#работа-со-строкой-в-java)

##

[наверх](#работа-со-строкой-в-java)

[назад](../README.md)
