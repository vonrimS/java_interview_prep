# Память в Java

[назад](java_main_prep.md)

* [Как устроена память в Java](#как-устроена-память-в-java)
* [Как работает Garbage Collector](#как-работает-garbage-collector)
* [Какие типы GC существуют, как их переключать](#какие-типы-gc-существуют-как-их-переключать)
* [Сборка мусора по поколениям](#сборка-мусора-по-поколениям)
* [Какие методы можно использовать для управления GC](#какие-методы-можно-использовать-для-управления-gc)
* [Что такое memory leak и как её избегать](#что-такое-memory-leak-и-как-её-избегать)


##  Как устроена `память` в Java

Память в Java устроена в несколько различных областей, каждая из которых имеет свои специфические функции и характеристики. Вот основные области памяти в Java:

1. `Heap` (Куча): Это область памяти, в которой хранятся все объекты и массивы, созданные во время выполнения программы Java. Объекты в куче управляются автоматически сборщиком мусора `Garbage Collector`, который отслеживает и удаляет объекты, на которые нет ссылок, чтобы освободить память.

2. `Stack` (Стек): Эта область памяти используется для хранения локальных переменных и вызовов методов. Каждый поток выполнения программы имеет свой собственный стек вызовов, который хранит информацию о вызванных методах и их локальных переменных. Стек управляется автоматически, и его размер ограничен.

3. `Method Area` (Область методов): Эта область памяти содержит информацию о классах, интерфейсах, методах и статических переменных. Здесь также хранится байт-код классов. Она является общей для всех потоков выполнения и не подвергается автоматической очистке.

4. `Native Method Stack` (Стек нативных методов): Эта область памяти используется для вызова нативных (C/C++) методов, которые не управляются средой выполнения Java и выполняются внешними библиотеками.

5. `PC Registers` (Регистры программного счетчика): Каждый поток выполнения имеет свой собственный регистр программного счетчика, который хранит текущую инструкцию, которую выполняет поток.

6. `Constant Pool` (Пул констант): В этой области памяти хранятся константы, такие как строки и числа, используемые в программе. Она связана с загрузкой классов и поддержанием ссылок на константы.

7. `Direct Memory` (Прямая память): Это область памяти, которая может быть использована для работы с данными вне управления сборщика мусора. Это часто используется для работы с нативными библиотеками.

Важно отметить, что управление памятью в Java полностью автоматизировано с помощью сборщика мусора (`GC`), который автоматически освобождает память, занимаемую объектами, на которые нет активных ссылок. Разработчикам не нужно явно выделять или освобождать память, как это может быть необходимо в языках программирования с явным управлением памятью, таких как C++. Это облегчает разработку и снижает риск утечек памяти.

[наверх](#память-в-java)  


## Как работает `Garbage Collector`

Сборщик мусора `Garbage Collector`, `GC` в Java - это часть среды выполнения Java (`JVM`), которая автоматически управляет памятью, освобождая память, занятую объектами, которые больше не нужны, чтобы предотвратить утечки памяти и обеспечить эффективное использование ресурсов. Вот как это работает:

1. **Отслеживание ссылок**: `GC` отслеживает все активные ссылки на объекты в программе. Это включает в себя ссылки из локальных переменных, стека вызовов, статических переменных и других мест.

2. **Определение ненужных объектов**: `GC` определяет, какие объекты больше не имеют активных ссылок на них. Если нет пути от корневых объектов (корневые объекты - это объекты, на которые есть активные ссылки) к какому-либо объекту, то этот объект считается ненужным.

3. **Маркировка**: `GC` производит маркировку (или пометку) всех объектов, которые будут удалены. Это делается путем обхода объектов в памяти и определения, какие из них достижимы из корневых объектов.

4. **Сжатие и освобождение памяти**: После маркировки `GC` может сжать память, чтобы уменьшить фрагментацию, и затем освободить память, занимаемую ненужными объектами. Освобожденная память становится доступной для новых объектов.

5. **Планирование и выполнение**: Сборка мусора выполняется автоматически, но не постоянно. Вместо этого она запускается, когда `JVM` определяет, что это необходимо. Это может происходить при достижении определенного порога использования памяти или при приостановке программы  - `stop-the-world` событие.

Сборка мусора в `Java` позволяет разработчикам избежать ручного управления памятью, что упрощает разработку и снижает риск утечек памяти. Однако это также может влиять на производительность, поэтому важно хорошо оптимизировать код и учитывать использование памяти в приложении.

[наверх](#память-в-java)  

## Какие типы `GC` существуют, как их переключать

В `Java` существует несколько типов сборщиков мусора (`GC`), каждый из которых оптимизирован для выполнения определенных задач и имеет свои особенности. Выбор типа `GC` и его настройки зависят от конкретных требований приложения и целей производительности. Вот некоторые из наиболее распространенных типов `GC`:

1. `Serial GC` (Serial Garbage Collector): Этот GC выполняет сборку мусора в один поток. Он подходит для однопоточных приложений или тестирования, но не рекомендуется для многозадачных приложений с большой нагрузкой.

2. `Parallel GC` (Parallel Garbage Collector): Также известен как `Throughput GC`. Он выполняет сборку мусора в нескольких параллельных потоках, что делает его хорошим выбором для многозадачных приложений, которые имеют несколько ядер процессора.

3. `Concurrent Mark-Sweep` (CMS) GC: Этот GC разработан для уменьшения пауз сборки мусора. Он выполняет маркировку и освобождение объектов в фоновом режиме, что позволяет приложению продолжать работу во время сборки мусора. Он хорошо подходит для приложений, где кратковременные паузы критичны.

4. `G1` GC (Garbage-First Garbage Collector): Этот GC также ориентирован на минимизацию пауз сборки мусора. Он разбивает память на регионы и собирает сначала те регионы, в которых наибольшее количество мусора, что позволяет добиваться предсказуемых и коротких пауз.

5. `Z Garbage Collector`: Введен в Java 11. Он также ориентирован на минимизацию пауз сборки мусора и разработан для использования в больших приложениях с большим объемом памяти.

Для переключения между типами `GC` и их настройки, вы можете использовать опции командной строки `JVM` при запуске приложения. Например, для выбора G1 GC, вы можете использовать опцию: `-XX:+UseG1GC`.

Для настройки параметров `GC`, таких как размер кучи, выделение памяти под объекты и другие, вы можете использовать опции `-Xmx`, `-Xms`, `-XX:MaxPermSize`, `-XX:NewSize` и многие другие.

Выбор и настройка `GC` зависят от требований вашего приложения к производительности и паузам сборки мусора. Рекомендуется проводить тестирование и профилирование вашего приложения, чтобы определить наилучшие параметры `GC` для вашей конкретной ситуации.

[наверх](#память-в-java)  


## Сборка мусора по поколениям 

Сборка мусора по поколениям в Java использует следующие области памяти:

1. `Permanent Generation`: Это область памяти, где хранятся метаданные классов, методов и другие данные, связанные с структурой классов. С `PermGen` связаны классы и методы, а не объекты. В Java 8 и более поздних версиях `PermGen` заменен на `Metaspace`.

2. `Young Generation`: Состоит из трех областей памяти:
    * `Eden Space` - здесь создаются все новые объекты
    * `Survivor Spaces` (S0 и S1) - после нескольких циклов сборки мусора в молодом поколении, объекты, которые пережили, могут быть перемещены сюда.

3. `Old Generation` или `Tenured Space`:  Представляет собой область памяти, где хранятся "старые" объекты, которые пережили несколько циклов сборки мусора в молодом поколении и Survivor Space. Этот поколение имеет больший срок службы, и сборка мусора здесь выполняется реже, чем в молодом поколении.

Сборка мусора по поколениям позволяет оптимизировать производительность, так как большинство объектов быстро умирают, и их сборка происходит в молодом поколении с минимальными затратами на производительность. Небольшое количество объектов выживает и переходит в более стойкие поколения, такие как `Old Generation`, где сборка мусора выполняется реже.

`Permanent Generation` (или `Metaspace` в более поздних версиях) отличается от молодого и старшего поколений тем, что хранит метаданные классов и методов, а не объекты, и не подвергается сборке мусора в том же контексте, что и поколения объектов.

[наверх](#память-в-java)

## Какие методы можно использовать для управления `GC`

В Java можно использовать несколько методов и опций для управления сборщиком мусора и его поведением:

1. `System.gc()`: Метод `System.gc()` можно вызвать для явной инициации сборки мусора. Однако **не существует гарантии, что сборщик мусора немедленно выполнит сборку**. Вызов этого метода **не рекомендуется**, так как он может привести к нежелательным простоям в приложении.

2. `Опции командной строки`: `Java` позволяет настраивать сборщик мусора и его параметры с помощью опций командной строки. Например, с помощью опции `-Xmx` можно установить максимальный размер кучи (`heap`), а опциями `-XX` можно настроить различные параметры сборки мусора, такие как тип сборщика, интервалы сборки и другие.

3. `Управление сборщиком мусора`: В `Java 9` и более поздних версиях появилась возможность управлять сборщиком мусора с помощью модуля `G1` (Garbage-First) и команды `-XX:+UseG1GC`. Этот сборщик обеспечивает более предсказуемое поведение и позволяет более точно настраивать параметры сборки мусора.

4. `Слежение за памятью и профилирование`: Существуют инструменты для слежения за использованием памяти и профилирования приложений, такие как `VisualVM`, `JVisualVM`, и другие. Они позволяют анализировать использование памяти и выявлять утечки памяти, что может помочь оптимизировать работу сборщика мусора.

5. `Использование сборщиков мусора с разными характеристиками`: В зависимости от характеристик приложения (например, частота создания и удаления объектов, требования к производительности), можно выбирать подходящий сборщик мусора. В `Java` существует несколько сборщиков мусора, такие как `G1`, `CMS`, `Parallel` и другие, каждый из которых имеет свои особенности и подходит для определенных сценариев.

Обратите внимание, что оптимальная настройка сборщика мусора зависит от конкретных характеристик вашего приложения и его нагрузки. Необходимо провести профилирование и тестирование, чтобы выбрать подходящие параметры сборки мусора и обеспечить стабильную и эффективную работу приложения.

[наверх](#память-в-java)


## Что такое `memory leak` и как её избегать

`memory leak` - это ситуация, когда в приложении происходит постепенное накопление объектов в памяти, которые больше не используются, но не освобождаются сборщиком мусора. Постепенное увеличение занимаемой памяти может привести к исчерпанию ресурсов и снижению производительности приложения, а в конечном итоге - к его аварийному завершению.

Избегание утечек памяти важно для поддержания стабильной работы приложения. Вот некоторые советы по предотвращению утечек памяти:

1. **Освобождайте ресурсы**: Вручную освобождайте ресурсы, которые больше не нужны, такие как файлы, сетевые соединения, базы данных и другие. Не полагайтесь только на сборщик мусора для управления этими ресурсами.

2. **Используйте `try-with-resources`**: Если вы работаете с ресурсами, которые реализуют интерфейс `AutoCloseable` (например, файлы, сокеты), используйте блок `try-with-resources` для автоматического закрытия ресурсов после завершения операции.

3. **Избегайте циклических ссылок**: Убедитесь, что объекты не имеют циклических ссылок друг на друга, так как это может привести к тому, что они не будут удалены сборщиком мусора. Для разорвания циклических ссылок можно использовать слабые ссылки (`WeakReference`).

4. **Профилирование и мониторинг**: Используйте инструменты для профилирования памяти и мониторинга использования ресурсов. Это поможет выявить утечки и найти их источники.

5. **Тестирование**: Включите тестирование на утечки памяти в свой процесс разработки. Существуют инструменты, такие как `LeakCanary` для `Android` и другие, которые могут помочь автоматически выявлять утечки памяти во время тестирования.

6. **Обновляйте зависимости**: Постоянно обновляйте библиотеки и зависимости в вашем проекте, так как разработчики могут выпускать исправления утечек памяти в новых версиях.

7. **Мониторьте производительность**: Внимательно отслеживайте производительность вашего приложения и реагируйте на изменения в использовании памяти. Например, если вы замечаете резкое увеличение потребления памяти, проводите анализ и устраняйте утечки.

Избегание утечек памяти является важной частью разработки качественного программного обеспечения. Своевременное обнаружение и устранение утечек помогает сохранить производительность и стабильность приложения.

[наверх](#память-в-java)


[наверх](#память-в-java) | [назад](java_main_prep.md)