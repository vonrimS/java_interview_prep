# Java OOP

[назад](java_main_prep.md)

* [Основные принципы ООП реализованые в Java](#основные-принципы-ооп-реализованые-в-java)
* [Что такое наследование и полиморфизм в Java?](#что-такое-наследование-и-полиморфизм-в-java?)
* [Как реализовать множественное наследование в Java](#как-реализовать-множественное-наследование-в-java)
* [Инкапсуляция и как её достичь в Java](#инкапсуляция-и-как-её-достичь-в-java)
* [Композиция и агрегация в Java](#композиция-и-агрегация-в-java)


## Основные принципы `ООП` реализованые в Java

`Java` является объектно-ориентированным языком программирования (`ООП`), и она включает в себя ряд основных принципов ООП. Вот некоторые из них:

1. **Инкапсуляция** (`Encapsulation`): Инкапсуляция означает скрытие внутренних деталей объекта и предоставление доступа к ним только через публичные методы. В `Java` это достигается с использованием модификаторов доступа (например, `private`, `protected`, `public`) для полей и методов класса.

2. **Наследование** (`Inheritance`): Наследование позволяет создавать новые классы на основе существующих классов, наследуя их свойства и методы. Это позволяет повторно использовать код и создавать иерархию классов. В `Java` наследование реализуется с помощью ключевого слова `extends`.

3. **Полиморфизм** (`Polymorphism`): Полиморфизм позволяет объектам разных классов обладать общим интерфейсом и выполнять одни и те же действия по-разному. В `Java` полиморфизм может быть достигнут через перегрузку методов и полиморфизм времени выполнения (`runtime polymorphism`) с использованием методов подклассов.

4. **Абстракция** (`Abstraction`): Абстракция позволяет скрыть сложность объекта и предоставить упрощенное представление. В `Java` абстракция достигается с использованием абстрактных классов и интерфейсов. Абстрактные классы могут содержать абстрактные методы, которые должны быть реализованы в подклассах.

5. **Композиция** (`Composition`): Композиция позволяет создавать более сложные объекты, комбинируя другие объекты. В `Java` это может быть достигнуто путем создания классов, которые содержат экземпляры других классов в качестве своих полей.

6. **Интерфейсы** (`Interfaces`): Интерфейсы в `Java` предоставляют абстрактные спецификации методов, которые классы могут реализовать. Это позволяет создавать классы, которые соответствуют определенному контракту, независимо от их фактической реализации.

7. **Пакеты** (`Packages`): Пакеты в `Java` позволяют организовать классы в логические группы и предоставить уровень сокрытия. Это помогает управлять и структурировать большие проекты.

8. **Повторное использование кода** (`Code Reusability`): ООП позволяет повторно использовать код через наследование, композицию и создание библиотек классов.

Эти принципы позволяют создавать гибкие, расширяемые и поддерживаемые программы, а ООП является мощным инструментом для организации кода и абстрагирования сложности.

[наверх](#java-oop)



## Что такое `наследование` и `полиморфизм` в Java?

В Java, `наследование` и `полиморфизм` - это два из основных принципов объектно-ориентированного программирования (ООП). Давайте разберемся с их определениями и основными концепциями:

1. **Наследование** (`Inheritance`): Наследование в `Java` позволяет создавать новый класс на основе существующего класса. Класс, который наследует свойства и методы другого класса, называется `подклассом` (или производным классом), а класс, который передает свойства и методы, называется `суперклассом` (или базовым классом). Основные идеи наследования в `Java`:

    * **Повторное использование кода**: Вы можете использовать существующий класс и расширить его функциональность, не переписывая код с нуля.

    * **Иерархия классов**: Классы могут быть организованы в иерархическую структуру, где один класс наследует от другого, создавая цепочку классов.

2. **Полиморфизм** (`Polymorphism`): Полиморфизм в `Java` означает, что один и тот же метод может иметь разные реализации в разных классах. Это позволяет обращаться к объектам разных классов с использованием одного и того же интерфейса. Основные концепции полиморфизма в `Java`:

    * **Полиморфизм в методах**: Разные классы могут иметь методы с одним и тем же именем и параметрами, но с разной реализацией. Вызов такого метода будет зависеть от типа объекта во время выполнения (динамическое связывание).

    * **Перегрузка методов**: В Java можно создавать несколько методов с одним и тем же именем, но разными параметрами (перегрузка методов).

    * **Использование интерфейсов и абстрактных классов**: Интерфейсы и абстрактные классы позволяют создавать общие соглашения (контракты) для классов и реализовывать их в различных контекстах.

```java
class Animal {
    void makeSound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal1 = new Dog();
        Animal animal2 = new Cat();

        animal1.makeSound(); // Вывод: Bark
        animal2.makeSound(); // Вывод: Meow
    }
}
```
Здесь `Dog` и `Cat` наследуют от `Animal`, и у них есть своя реализация метода `makeSound()`. Полиморфизм позволяет вызывать метод `makeSound()` у объектов разных подклассов, и правильная реализация метода будет выбрана во время выполнения программы.

[наверх](#java-oop)



## Как реализовать множественное наследование в `Java`

В `Java`, классы **не поддерживают множественное наследование**, что означает, что класс не может наследовать от нескольких классов одновременно. Однако вы можете использовать интерфейсы для достижения подобного эффекта.

Множественное наследование в `Java` может быть реализовано с использованием `интерфейсов`. Класс может реализовать несколько интерфейсов, что позволяет ему наследовать функциональность от различных источников.

```java
interface Interface1 {
    void method1();
}

interface Interface2 {
    void method2();
}

class MyClass implements Interface1, Interface2 {
    public void method1() {
        System.out.println("Реализация method1");
    }

    public void method2() {
        System.out.println("Реализация method2");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.method1();
        obj.method2();
    }
}
```

В этом примере класс `MyClass` реализует оба интерфейса `Interface1` и `Interface2`, что позволяет ему наследовать функциональность от обоих интерфейсов.

Если вам нужно использовать конкретную реализацию из одного класса в другом классе, то можно воспользоваться композицией, создавая экземпляр этого класса внутри другого класса и делегируя вызовы методов этому экземпляру.

[наверх](#java-oop) 

## `Инкапсуляция` и как её достичь в `Java`

`Инкапсуляция` - это один из принципов `ООП`, который означает сокрытие внутренних деталей реализации класса от внешнего мира и предоставление доступа к данным и методам класса через управляемый интерфейс. Главная цель инкапсуляции - обеспечить безопасность и управляемость данных и функциональности класса.

В Java инкапсуляция достигается с помощью модификаторов доступа (`private`, `protected`, `public`) и `геттеров` (методов для получения данных) и `сеттеров` (методов для установки данных). Вот как можно реализовать инкапсуляцию в Java:

1. Примените модификаторы доступа:

    * `private`: Ограничивает доступ к членам класса только внутри этого класса. Данные, объявленные как private, не доступны извне.
    * `protected`: Доступно внутри класса, в подклассах и внутри пакета (package-private).
    * `public`: Доступно из любого места.
2. Используйте геттеры (методы получения данных) и сеттеры (методы установки данных):

    * Геттеры позволяют получить значение приватной переменной.
    * Сеттеры позволяют установить значение приватной переменной.

```java
public class Person {
    private String name; // Приватное поле

    // Геттер для доступа к имени
    public String getName() {
        return name;
    }

    // Сеттер для установки имени
    public void setName(String name) {
        this.name = name;
    }
}
```
В этом примере поле `name` объявлено как `private`, и к нему можно получить доступ только через публичные геттеры и сеттеры. Это обеспечивает инкапсуляцию данных `name`.

Инкапсуляция позволяет контролировать доступ к данным и методам класса, что делает код более безопасным и уменьшает вероятность ошибок. Она также облегчает изменение внутренней реализации класса, не затрагивая внешний код, который использует этот класс.

[наверх](#java-oop)

## `Композиция` и `агрегация` в Java

Композиция и агрегация - это два способа организации отношений между объектами в Java (и в объектно-ориентированном программировании в целом).

### Композиция:
* Композиция представляет собой более строгий тип отношения между объектами.
* В композиции один объект является частью другого объекта и **не может существовать независимо от него**.
* Если владеющий объект (контейнер) уничтожается, то и вложенный объект также уничтожается.
* Композиция обычно реализуется путем включения одного объекта в другой в качестве его части.
* Например, если у вас есть класс `Car` и класс `Engine`, и каждый объект `Car` имеет свой собственный объект `Engine`, то это композиция.
```java
public class Car {
    private Engine engine;

    public Car() {
        engine = new Engine();
    }
}
```
### Агрегация:
* Агрегация представляет собой более слабое отношение между объектами.
* В агрегации один объект может содержать ссылку на другой объект, но это не означает, что он является его частью.
* Если владеющий объект (контейнер) уничтожается, это не обязательно ведет к уничтожению вложенного объекта.
* Агрегация обычно используется для представления отношений типа "содержит" или "ссылается на".
* Например, если у вас есть класс Library и класс Book, и библиотека содержит ссылки на книги, это агрегация.
```java
public class Library {
    private List<Book> books;

    public Library() {
        books = new ArrayList<>();
    }

    public void addBook(Book book) {
        books.add(book);
    }
}
```
Важно отметить, что различие между композицией и агрегацией не всегда очевидно и может зависеть от контекста. В некоторых случаях можно использовать оба варианта в зависимости от требований проектирования.

[наверх](#java-oop)


##

[наверх](#java-oop)

[наверх](#java-oop) | [назад](java_main_prep.md)